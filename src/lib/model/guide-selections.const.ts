export const GUIDE_SELECTIONS = [
  {
    "id": 0,
    "file": "elements",
    "fullFileName": "adev/src/content/guide/elements.md",
    "startLine": 5,
    "content": "# Angular elements overview\n\n_Angular elements_ are Angular components packaged as _custom elements_ \\(also called Web Components\\), a web standard for defining new HTML elements in a framework-agnostic way.\n\n[Custom elements](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) are a Web Platform feature available on all browsers supported by Angular.\nA custom element extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code.\nThe browser maintains a `CustomElementRegistry` of defined custom elements, which maps an instantiable JavaScript class to an HTML tag.\n\nThe `@angular/elements` package exports a `createCustomElement()` API that provides a bridge from Angular's component interface and change detection functionality to the built-in DOM API.\n\nTransforming a component to a custom element makes all the required Angular infrastructure available to the browser.\nCreating a custom element is simple and straightforward, and automatically connects your component-defined view with change detection and data binding, mapping Angular functionality to the corresponding built-in HTML equivalents.\n\n## Using custom elements\n\nCustom elements bootstrap themselves - they start when they are added to the DOM, and are destroyed when removed from the DOM.\nOnce a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular terms or usage conventions.\n\nTo add the `@angular/elements` package to your workspace, run the following command:\n\n<docs-code language=\"shell\">\n\nnpm install @angular/elements --save\n\n</docs-code>\n\n### How it works\n\nThe `createCustomElement()` function converts a component into a class that can be registered with the browser as a custom element.\nAfter you register your configured class with the browser's custom-element registry, use the new element just like a built-in HTML element in content that you add directly into the DOM:\n\n<docs-code language=\"html\">\n\n<my-popup message=\"Use Angular!\"></my-popup>\n\n</docs-code>\n\nWhen your custom element is placed on a page, the browser creates an instance of the registered class and adds it to the DOM.\nThe content is provided by the component's template, which uses Angular template syntax, and is rendered using the component and DOM data.\nInput properties in the component correspond to input attributes for the element.\n\n## Transforming components to custom elements\n\nAngular provides the `createCustomElement()` function for converting an Angular component, together with its dependencies, to a custom element.\n\nThe conversion process implements the `NgElementConstructor` interface, and creates a\nconstructor class that is configured to produce a self-bootstrapping instance of your component.\n\nUse the browser's native [`customElements.define()`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define) function to register the configured constructor and its associated custom-element tag with the browser's [`CustomElementRegistry`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry).\nWhen the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.\n\nIMPORTANT: Avoid using the component's selector as the custom element tag name.\nThis can lead to unexpected behavior, due to Angular creating two component instances for a single DOM element:\nOne regular Angular component and a second one using the custom element.\n\n### Mapping\n\nA custom element _hosts_ an Angular component, providing a bridge between the data and logic defined in the component and standard DOM APIs.\nComponent properties and logic maps directly into HTML attributes and the browser's event system.\n\n* The creation API parses the component looking for input properties, and defines corresponding attributes for the custom element.\n  It transforms the property names to make them compatible with custom elements, which do not recognize case distinctions.\n  The resulting attribute names use dash-separated lowercase.\n  For example, for a component with `@Input('myInputProp') inputProp`, the corresponding custom element defines an attribute `my-input-prop`.\n\n* Component outputs are dispatched as HTML [Custom Events](https://developer.mozilla.org/docs/Web/API/CustomEvent), with the name of the custom event matching the output name.\n    For example, for a component with `@Output() valueChanged = new EventEmitter()`, the corresponding custom element dispatches events with the name \"valueChanged\", and the emitted data is stored on the event's `detail` property.\n    If you provide an alias, that value is used; for example, `@Output('myClick') clicks = new EventEmitter<string>();` results in dispatch events with the name \"myClick\".\n\nFor more information, see Web Component documentation for [Creating custom events](https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events).\n\n## Example: A Popup Service\n\nPreviously, when you wanted to add a component to an application at runtime, you had to define a _dynamic component_, and then you would have to load it, attach it to an element in the DOM, and wire up all of the dependencies, change detection, and event handling.\n\nUsing an Angular custom element makes the process simpler and more transparent, by providing all the infrastructure and framework automatically —all you have to do is define the kind of event handling you want.\n\\(You do still have to exclude the component from compilation, if you are not going to use it in your application.\\)\n\nThe following Popup Service example application defines a component that you can either load dynamically or convert to a custom element.\n\n| Files                | Details                                                                                                                                                                                                                      |\n| :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `popup.component.ts` | Defines a simple pop-up element that displays an input message, with some animation and styling.                                                                                                                             |\n| `popup.service.ts`   | Creates an injectable service that provides two different ways to invoke the `PopupComponent`; as a dynamic component, or as a custom element. Notice how much more setup is required for the dynamic-loading method.        |  |\n| `app.component.ts`   | Defines the application's root component, which uses the `PopupService` to add the pop-up to the DOM at run time. When the application runs, the root component's constructor converts `PopupComponent` to a custom element. |\n\nFor comparison, the demo shows both methods.\nOne button adds the popup using the dynamic-loading method, and the other uses the custom element.\nThe result is the same, but the preparation is different.\n\n<docs-code-multifile>\n    <docs-code header=\"popup.component.ts\" path=\"adev/src/content/examples/elements/src/app/popup.component.ts\"/>\n    <docs-code header=\"popup.service.ts\" path=\"adev/src/content/examples/elements/src/app/popup.service.ts\"/>\n    <docs-code header=\"app.component.ts\" path=\"adev/src/content/examples/elements/src/app/app.component.ts\"/>\n</docs-code-multifile>\n\n## Typings for custom elements\n\nGeneric DOM APIs, such as `document.createElement()` or `document.querySelector()`, return an element type that is appropriate for the specified arguments.\nFor example, calling `document.createElement('a')` returns an `HTMLAnchorElement`, which TypeScript knows has an `href` property.\nSimilarly, `document.createElement('div')` returns an `HTMLDivElement`, which TypeScript knows has no `href` property.\n\nWhen called with unknown elements, such as a custom element name \\(`popup-element` in our example\\), the methods return a generic type, such as `HTMLElement`, because TypeScript can't infer the correct type of the returned element.\n\nCustom elements created with Angular extend `NgElement` \\(which in turn extends `HTMLElement`\\).\nAdditionally, these custom elements will have a property for each input of the corresponding component.\nFor example, our `popup-element` has a `message` property of type `string`.\n\nThere are a few options if you want to get correct types for your custom elements.\nAssume you create a `my-dialog` custom element based on the following component:\n\n<docs-code language=\"typescript\">\n\n@Component(…)\nclass MyDialog {\n  @Input() content: string;\n}\n\n</docs-code>\n\nThe most straightforward way to get accurate typings is to cast the return value of the relevant DOM methods to the correct type.\nFor that, use the `NgElement` and `WithProperties` types \\(both exported from `@angular/elements`\\):\n\n<docs-code language=\"typescript\">\n\nconst aDialog = document.createElement('my-dialog') as NgElement & WithProperties<{content: string}>;\naDialog.content = 'Hello, world!';\naDialog.content = 123;  // <-- ERROR: TypeScript knows this should be a string.\naDialog.body = 'News';  // <-- ERROR: TypeScript knows there is no `body` property on `aDialog`.\n\n</docs-code>\n\nThis is a good way to quickly get TypeScript features, such as type checking and autocomplete support, for your custom element.\nBut it can get cumbersome if you need it in several places, because you have to cast the return type on every occurrence.\n\nAn alternative way, that only requires defining each custom element's type once, is augmenting the `HTMLElementTagNameMap`, which TypeScript uses to infer the type of a returned element based on its tag name \\(for DOM methods such as `document.createElement()`, `document.querySelector()`, etc.\\):\n\n<docs-code language=\"typescript\">\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'my-dialog': NgElement & WithProperties<{content: string}>;\n    'my-other-element': NgElement & WithProperties<{foo: 'bar'}>;\n    …\n  }\n}\n\n</docs-code>\n\nNow, TypeScript can infer the correct type the same way it does for built-in elements:\n\n<docs-code language=\"typescript\">\n\ndocument.createElement('div')               //--> HTMLDivElement (built-in element)\ndocument.querySelector('foo')               //--> Element        (unknown element)\ndocument.createElement('my-dialog')         //--> NgElement & WithProperties<{content: string}> (custom element)\ndocument.querySelector('my-other-element')  //--> NgElement & WithProperties<{foo: 'bar'}>      (custom element)\n\n</docs-code>\n\n## Limitations\n\nCare should be taken when destroying and then re-attaching custom elements created with `@angular/elements` due to issues with the [disconnect()](https://github.com/angular/angular/issues/38778) callback. Cases where you may run into this issue are:\n\n- Rendering a component in an `ng-if` or `ng-repeat` in `AngularJs`\n- Manually detaching and re-attaching an element to the DOM\n\n\n\n================================================\n",
    "endLine": 173
  },
  {
    "id": 1,
    "file": "hydration",
    "fullFileName": "adev/src/content/guide/hydration.md",
    "startLine": 177,
    "content": "# Hydration\n\n## What is hydration\n\nHydration is the process that restores the server-side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes.\n\n## Why is hydration important?\n\nHydration improves application performance by avoiding extra work to re-create DOM nodes. Instead, Angular tries to match existing DOM elements to the applications structure at runtime and reuses DOM nodes when possible. This results in a performance improvement that can be measured using [Core Web Vitals (CWV)](https://web.dev/learn-core-web-vitals/) statistics, such as reducing the First Input Delay ([FID](https://web.dev/fid/)) and Largest Contentful Paint ([LCP](https://web.dev/lcp/)), as well as Cumulative Layout Shift ([CLS](https://web.dev/cls/)). Improving these numbers also affects things like SEO performance.\n\nWithout hydration enabled, server-side rendered Angular applications will destroy and re-render the application's DOM, which may result in a visible UI flicker. This re-rendering can negatively impact [Core Web Vitals](https://web.dev/learn-core-web-vitals/) like [LCP](https://web.dev/lcp/) and cause a layout shift. Enabling hydration allows the existing DOM to be re-used and prevents a flicker.\n\n## How do you enable hydration in Angular\n\nHydration can be enabled for server-side rendered (SSR) applications only. Follow the [Angular SSR Guide](guide/ssr) to enable server-side rendering first.\n\n### Using Angular CLI\n\nIf you've used Angular CLI to enable SSR (either by enabling it during application creation or later via `ng add @angular/ssr`), the code that enables hydration should already be included into your application.\n\n### Manual setup\n\nIf you have a custom setup and didn't use Angular CLI to enable SSR, you can enable hydration manually by visiting your main application component or module and importing `provideClientHydration` from `@angular/platform-browser`. You'll then add that provider to your app's bootstrapping providers list.\n\n```typescript\nimport {\n  bootstrapApplication,\n  provideClientHydration,\n} from '@angular/platform-browser';\n...\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration()]\n});\n```\n\nAlternatively if you are using NgModules, you would add `provideClientHydration` to your root app module's provider list.\n\n```typescript\nimport {provideClientHydration} from '@angular/platform-browser';\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n  declarations: [AppComponent],\n  exports: [AppComponent],\n  bootstrap: [AppComponent],\n  providers: [provideClientHydration()],\n})\nexport class AppModule {}\n```\n\nIMPORTANT: Make sure that the `provideClientHydration()` call is also included into a set of providers that is used to bootstrap an application on the **server**. In applications with the default project structure (generated by the `ng new` command), adding a call to the root `AppModule` should be sufficient, since this module is imported by the server module. If you use a custom setup, add the `provideClientHydration()` call to the providers list in the server bootstrap configuration.\n\n### Verify that hydration is enabled\n\nAfter you've configured hydration and have started up your server, load your application in the browser.\n\nHELPFUL: You will likely need to fix instances of Direct DOM Manipulation before hydration will fully work either by switching to Angular constructs or by using `ngSkipHydration`. See [Constraints](#constraints), [Direct DOM Manipulation](#direct-dom-manipulation), and [How to skip hydration for particular components](#how-to-skip-hydration-for-particular-components) for more details.\n\nWhile running an application in dev mode, you can confirm hydration is enabled by opening the Developer Tools in your browser and viewing the console. You should see a message that includes hydration-related stats, such as the number of components and nodes hydrated. Angular calculates the stats based on all components rendered on a page, including those that come from third-party libraries.\n\nYou can also use [Angular DevTools browser extension](tools/devtools) to see hydration status of components on a page. Angular DevTools also allows to enable an overlay to indicate which parts of the page were hydrated. If there is a hydration mismatch error - DevTools would also highlight a component that caused the error.\n\n## Capturing and replaying events\n\nWhen an application is rendered on the server, it is visible in a browser as soon as produced HTML loads. Users may assume that they can interact with the page, but event listeners are not attached until hydration completes. Starting from v18, you can enable the Event Replay feature that allows to capture all events that happen before hydration and replay those events once hydration has completed. You can enable it using the `withEventReplay()` function, for example:\n\n```typescript\nimport {provideClientHydration, withEventReplay} from '@angular/platform-browser';\n\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(withEventReplay())\n  ]\n});\n```\n\n### How event replay works\nEvent Replay is a feature that improves user experience by capturing user events that were triggered before the hydration process is complete. Then those events are replayed, ensuring none of that interaction was lost.\n\nThe Event Replay is divided into three main phases:\n\n- **Capturing user interactions**<br>\nPrior to **Hydration**, Event Replay captures and stores all interactions that the user may perform, such as clicks and other browser native events.\n\n- **Storing events**<br>\nThe **Event Contract** keeps in memory all the interactions recorded in the previous step, ensuring that they are not lost for later replay.\n\n- **Relaunch of events**<br>\nOnce **Hydration** is complete, Angular re-invokes the captured events.\n\nEvent replay supports _native browser events_, for example `click`, `mouseover`, and `focusin`. If you'd like to learn more about JSAction, the library that powers event replay, you can read more [on the readme](https://github.com/angular/angular/tree/main/packages/core/primitives/event-dispatch#readme).\n\n---\n\nThis feature ensures a consistent user experience, preventing user actions performed before Hydration from being ignored. NOTE: if you have [incremental hydration](guide/incremental-hydration) enabled, event replay is automatically enabled under the hood.\n\n## Constraints\n\nHydration imposes a few constraints on your application that are not present without hydration enabled. Your application must have the same generated DOM structure on both the server and the client. The process of hydration expects the DOM tree to have the same structure in both places. This also includes whitespaces and comment nodes that Angular produces during the rendering on the server. Those whitespaces and nodes must be present in the HTML generated by the server-side rendering process.\n\nIMPORTANT: The HTML produced by the server side rendering operation **must not** be altered between the server and the client.\n\nIf there is a mismatch between server and client DOM tree structures, the hydration process will encounter problems attempting to match up what was expected to what is actually present in the DOM. Components that do direct DOM manipulation using native DOM APIs are the most common culprit.\n\n### Direct DOM Manipulation\n\nIf you have components that manipulate the DOM using native DOM APIs or use `innerHTML` or `outerHTML`, the hydration process will encounter errors. Specific cases where DOM manipulation is a problem are situations like accessing the `document`, querying for specific elements, and injecting additional nodes using `appendChild`. Detaching DOM nodes and moving them to other locations will also result in errors.\n\nThis is because Angular is unaware of these DOM changes and cannot resolve them during the hydration process. Angular will expect a certain structure, but it will encounter a different structure when attempting to hydrate. This mismatch will result in hydration failure and throw a DOM mismatch error ([see below](#errors)).\n\nIt is best to refactor your component to avoid this sort of DOM manipulation. Try to use Angular APIs to do this work, if you can. If you cannot refactor this behavior, use the `ngSkipHydration` attribute ([described below](#how-to-skip-hydration-for-particular-components)) until you can refactor into a hydration friendly solution.\n\n### Valid HTML structure\n\nThere are a few cases where if you have a component template that does not have valid HTML structure, this could result in a DOM mismatch error during hydration.\n\nAs an example, here are some of the most common cases of this issue.\n\n- `<table>` without a `<tbody>`\n- `<div>` inside a `<p>`\n- `<a>` inside another `<a>`\n\nIf you are uncertain about whether your HTML is valid, you can use a [syntax validator](https://validator.w3.org/) to check it.\n\nNOTE: While the HTML standard does not require the `<tbody>` element inside tables, modern browsers automatically create a `<tbody>` element in tables that do not declare one. Because of this inconsistency, always explicitly declare a `<tbody>` element in tables to avoid hydration errors.\n\n### Preserve Whitespaces Configuration\n\nWhen using the hydration feature, we recommend using the default setting of `false` for `preserveWhitespaces`. If this setting is not in your tsconfig, the value will be `false` and no changes are required. If you choose to enable preserving whitespaces by adding `preserveWhitespaces: true` to your tsconfig, it is possible you may encounter issues with hydration. This is not yet a fully supported configuration.\n\nHELPFUL: Make sure that this setting is set **consistently** in `tsconfig.server.json` for your server and `tsconfig.app.json` for your browser builds. A mismatched value will cause hydration to break.\n\nIf you choose to set this setting in your tsconfig, we recommend to set it only in `tsconfig.app.json` which by default the `tsconfig.server.json` will inherit it from.\n\n### Custom or Noop Zone.js are not yet supported\n\nHydration relies on a signal from Zone.js when it becomes stable inside an application, so that Angular can start the serialization process on the server or post-hydration cleanup on the client to remove DOM nodes that remained unclaimed.\n\nProviding a custom or a \"noop\" Zone.js implementation may lead to a different timing of the \"stable\" event, thus triggering the serialization or the cleanup too early or too late. This is not yet a fully supported configuration and you may need to adjust the timing of the `onStable` event in the custom Zone.js implementation.\n\n## Errors\n\nThere are several hydration related errors you may encounter ranging from node mismatches to cases when the `ngSkipHydration` was used on an invalid host node. The most common error case that may occur is due to direct DOM manipulation using native APIs that results in hydration being unable to find or match the expected DOM tree structure on the client that was rendered by the server. The other case you may encounter this type of error was mentioned in the [Valid HTML structure](#valid-html-structure) section earlier. So, make sure the HTML in your templates are using valid structure, and you'll avoid that error case.\n\nFor a full reference on hydration related errors, visit the [Errors Reference Guide](/errors).\n\n## How to skip hydration for particular components\n\nSome components may not work properly with hydration enabled due to some of the aforementioned issues, like [Direct DOM Manipulation](#direct-dom-manipulation). As a workaround, you can add the `ngSkipHydration` attribute to a component's tag in order to skip hydrating the entire component.\n\n```angular-html\n<app-example ngSkipHydration />\n```\n\nAlternatively you can set `ngSkipHydration` as a host binding.\n\n```typescript\n@Component({\n  ...\n  host: {ngSkipHydration: 'true'},\n})\nclass ExampleComponent {}\n```\n\nThe `ngSkipHydration` attribute will force Angular to skip hydrating the entire component and its children. Using this attribute means that the component will behave as if hydration is not enabled, meaning it will destroy and re-render itself.\n\nHELPFUL: This will fix rendering issues, but it means that for this component (and its children), you don't get the benefits of hydration. You will need to adjust your component's implementation to avoid hydration-breaking patterns (i.e. Direct DOM Manipulation) to be able to remove the skip hydration annotation.\n\nThe `ngSkipHydration` attribute can only be used on component host nodes. Angular throws an error if this attribute is added to other nodes.\n\nKeep in mind that adding the `ngSkipHydration` attribute to your root application component would effectively disable hydration for your entire application. Be careful and thoughtful about using this attribute. It is intended as a last resort workaround. Components that break hydration should be considered bugs that need to be fixed.\n\n## Hydration Timing and Application Stability\n\nApplication stability is an important part of the hydration process. Hydration and any post-hydration processes only occur once the application has reported stability. There are a number of ways that stability can be delayed. Examples include setting timeouts and intervals, unresolved promises, and pending microtasks. In those cases, you may encounter the [Application remains unstable](errors/NG0506) error, which indicates that your app has not yet reached the stable state after 10 seconds. If you're finding that your application is not hydrating right away, take a look at what is impacting application stability and refactor to avoid causing these delays.\n\n## I18N\n\nHELPFUL: Support for internationalization with hydration is currently in [developer preview](/reference/releases#developer-preview). By default, Angular will skip hydration for components that use i18n blocks, effectively re-rendering those components from scratch.\n\nTo enable hydration for i18n blocks, you can add [`withI18nSupport`](/api/platform-browser/withI18nSupport) to your `provideClientHydration` call.\n\n```typescript\nimport {\n  bootstrapApplication,\n  provideClientHydration,\n  withI18nSupport,\n} from '@angular/platform-browser';\n...\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration(withI18nSupport())]\n});\n```\n\n## Consistent rendering across server-side and client-side\nAvoid introducing `@if` blocks and other conditionals that display different content when server-side rendering than client-side rendering, such as using an `@if` block with Angular's `isPlatformBrowser` function. These rendering differences cause layout shifts, negatively impacting end-user experience and core web vitals.\n\n## Third Party Libraries with DOM Manipulation\n\nThere are a number of third party libraries that depend on DOM manipulation to be able to render. D3 charts is a prime example. These libraries worked without hydration, but they may cause DOM mismatch errors when hydration is enabled. For now, if you encounter DOM mismatch errors using one of these libraries, you can add the `ngSkipHydration` attribute to the component that renders using that library.\n\n## Third Party Scripts with DOM Manipulation\n\nMany third party scripts, such as ad trackers and analytics, modify the DOM before hydration can occur. These scripts may cause hydration errors because the page no longer matches the structure expected by Angular. Prefer deferring this type of script until after hydration whenever possible. Consider using [`AfterNextRender`](api/core/afterNextRender) to delay the script until post-hydration processes have occured.\n\n## Incremental Hydration\n\nIncremental hydration is an advanced form of hydration that allows for more granular control over when hydration happens. See the [incremental hydration guide](guide/incremental-hydration) for more information.\n\n\n\n================================================\n",
    "endLine": 389
  },
  {
    "id": 2,
    "file": "image-optimization",
    "fullFileName": "adev/src/content/guide/image-optimization.md",
    "startLine": 393,
    "content": "# Getting started with NgOptimizedImage\n\nThe `NgOptimizedImage` directive makes it easy to adopt performance best practices for loading images.\n\nThe directive ensures that the loading of the [Largest Contentful Paint (LCP)](http://web.dev/lcp) image is prioritized by:\n\n* Automatically setting the `fetchpriority` attribute on the `<img>` tag\n* Lazy loading other images by default\n* Automatically generating a preconnect link tag in the document head\n* Automatically generating a `srcset` attribute\n* Generating a [preload hint](https://developer.mozilla.org/docs/Web/HTML/Link_types/preload) if app is using SSR\n\nIn addition to optimizing the loading of the LCP image, `NgOptimizedImage` enforces a number of image best practices, such as:\n\n* Using [image CDN URLs to apply image optimizations](https://web.dev/image-cdns/#how-image-cdns-use-urls-to-indicate-optimization-options)\n* Preventing layout shift by requiring `width` and `height`\n* Warning if `width` or `height` have been set incorrectly\n* Warning if the image will be visually distorted when rendered\n\nIf you're using a background image in CSS, [start here](#how-to-migrate-your-background-image).\n\n**NOTE: Although the `NgOptimizedImage` directive was made a stable feature in Angular version 15, it has been backported and is available as a stable feature in versions 13.4.0 and 14.3.0 as well.**\n\n## Getting Started\n\n<docs-workflow>\n<docs-step title=\"Import `NgOptimizedImage` directive\">\nImport `NgOptimizedImage` directive from `@angular/common`:\n\n<docs-code language=\"typescript\">\n\nimport { NgOptimizedImage } from '@angular/common'\n\n</docs-code>\n\nand include it into the `imports` array of a standalone component or an NgModule:\n\n<docs-code language=\"typescript\">\n\nimports: [\n  NgOptimizedImage,\n  // ...\n],\n\n</docs-code>\n</docs-step>\n<docs-step title=\"(Optional) Set up a Loader\">\nAn image loader is not **required** in order to use NgOptimizedImage, but using one with an image CDN enables powerful performance features, including automatic `srcset`s for your images.\n\nA brief guide for setting up a loader can be found in the [Configuring an Image Loader](#configuring-an-image-loader-for-ngoptimizedimage) section at the end of this page.\n</docs-step>\n<docs-step title=\"Enable the directive\">\nTo activate the `NgOptimizedImage` directive, replace your image's `src` attribute with `ngSrc`.\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\">\n\n</docs-code>\n\nIf you're using a [built-in third-party loader](#built-in-loaders), make sure to omit the base URL path from `src`, as that will be prepended automatically by the loader.\n</docs-step>\n<docs-step title=\"Mark images as `priority`\">\nAlways mark the [LCP image](https://web.dev/lcp/#what-elements-are-considered) on your page as `priority` to prioritize its loading.\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" priority>\n\n</docs-code>\n\nMarking an image as `priority` applies the following optimizations:\n\n* Sets `fetchpriority=high` (read more about priority hints [here](https://web.dev/priority-hints))\n* Sets `loading=eager` (read more about native lazy loading [here](https://web.dev/browser-level-image-lazy-loading))\n* Automatically generates a [preload link element](https://developer.mozilla.org/docs/Web/HTML/Link_types/preload) if [rendering on the server](guide/ssr).\n\nAngular displays a warning during development if the LCP element is an image that does not have the `priority` attribute. A page’s LCP element can vary based on a number of factors - such as the dimensions of a user's screen, so a page may have multiple images that should be marked `priority`. See [CSS for Web Vitals](https://web.dev/css-web-vitals/#images-and-largest-contentful-paint-lcp) for more details.\n</docs-step>\n<docs-step title=\"Include Width and Height\">\nIn order to prevent [image-related layout shifts](https://web.dev/css-web-vitals/#images-and-layout-shifts), NgOptimizedImage requires that you specify a height and width for your image, as follows:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\">\n\n</docs-code>\n\nFor **responsive images** (images which you've styled to grow and shrink relative to the viewport), the `width` and `height` attributes should be the intrinsic size of the image file. For responsive images it's also important to [set a value for `sizes`.](#responsive-images)\n\nFor **fixed size images**, the `width` and `height` attributes should reflect the desired rendered size of the image. The aspect ratio of these attributes should always match the intrinsic aspect ratio of the image.\n\nNOTE: If you don't know the size of your images, consider using \"fill mode\" to inherit the size of the parent container, as described below.\n</docs-step>\n</docs-workflow>\n\n## Using `fill` mode\n\nIn cases where you want to have an image fill a containing element, you can use the `fill` attribute. This is often useful when you want to achieve a \"background image\" behavior. It can also be helpful when you don't know the exact width and height of your image, but you do have a parent container with a known size that you'd like to fit your image into (see \"object-fit\" below).\n\nWhen you add the `fill` attribute to your image, you do not need and should not include a `width` and `height`, as in this example:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" fill>\n\n</docs-code>\n\nYou can use the [object-fit](https://developer.mozilla.org/docs/Web/CSS/object-fit) CSS property to change how the image will fill its container. If you style your image with `object-fit: \"contain\"`, the image will maintain its aspect ratio and be \"letterboxed\" to fit the element. If you set `object-fit: \"cover\"`, the element will retain its aspect ratio, fully fill the element, and some content may be \"cropped\" off.\n\nSee visual examples of the above at the [MDN object-fit documentation.](https://developer.mozilla.org/docs/Web/CSS/object-fit)\n\nYou can also style your image with the [object-position property](https://developer.mozilla.org/docs/Web/CSS/object-position) to adjust its position within its containing element.\n\nIMPORTANT: For the \"fill\" image to render properly, its parent element **must** be styled with `position: \"relative\"`, `position: \"fixed\"`, or `position: \"absolute\"`.\n\n## How to migrate your background image\n\nHere's a simple step-by-step process for migrating from `background-image` to `NgOptimizedImage`. For these steps, we'll refer to the element that has an image background as the \"containing element\":\n\n1) Remove the `background-image` style from the containing element.\n2) Ensure that the containing element has `position: \"relative\"`, `position: \"fixed\"`, or `position: \"absolute\"`.\n3) Create a new image element as a child of the containing element, using `ngSrc` to enable the `NgOptimizedImage` directive.\n4) Give that element the `fill` attribute. Do not include a `height` and `width`.\n5) If you believe this image might be your [LCP element](https://web.dev/lcp/), add the `priority` attribute to the image element.\n\nYou can adjust how the background image fills the container as described in the [Using fill mode](#using-fill-mode) section.\n\n\n## Using placeholders\n\n### Automatic placeholders\n\nNgOptimizedImage can display an automatic low-resolution placeholder for your image if you're using a CDN or image host that provides automatic image resizing. Take advantage of this feature by adding the `placeholder` attribute to your image:\n\n<docs-code format=\"typescript\" language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" placeholder>\n\n</docs-code>\n\nAdding this attribute automatically requests a second, smaller version of the image using your specified image loader. This small image will be applied as a `background-image` style with a CSS blur while your image loads. If no image loader is provided, no placeholder image can be generated and an error will be thrown.\n\nThe default size for generated placeholders is 30px wide. You can change this size by specifying a pixel value in the `IMAGE_CONFIG` provider, as seen below:\n\n<docs-code format=\"typescript\" language=\"typescript\">\nproviders: [\n  {\n    provide: IMAGE_CONFIG,\n    useValue: {\n      placeholderResolution: 40\n    }\n  },\n],\n</docs-code>\n\nIf you want sharp edges around your blurred placeholder, you can wrap your image in a containing `<div>` with the `overflow: hidden` style. As long as the `<div>` is the same size as the image (such as by using the `width: fit-content` style), the \"fuzzy edges\" of the placeholder will be hidden.\n\n### Data URL placeholders\n\nYou can also specify a placeholder using a base64 [data URL](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) without an image loader. The data url format is `data:image/[imagetype];[data]`, where `[imagetype]` is the image format, just as `png`, and `[data]` is a base64 encoding of the image. That encoding can be done using the command line or in JavaScript. For specific commands, see [the MDN documentation](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URLs#encoding_data_into_base64_format). An example of a data URL placeholder with truncated data is shown below:\n\n<docs-code language=\"angular-html\">\n\n<img\n  ngSrc=\"cat.jpg\"\n  width=\"400\"\n  height=\"200\"\n  placeholder=\"data:image/png;base64,iVBORw0K...\"\n/>\n\n</docs-code>\n\nHowever, large data URLs  increase the size of your Angular bundles and slow down page load. If you cannot use an image loader, the Angular team recommends keeping base64 placeholder images smaller than 4KB and using them exclusively on critical images. In addition to decreasing placeholder dimensions, consider changing image formats or parameters used when saving images. At very low resolutions, these parameters can have a large effect on file size.\n\n### Non-blurred placeholders\n\nBy default, NgOptimizedImage applies a CSS blur effect to image placeholders. To render a placeholder without blur, provide a `placeholderConfig` argument with an object that includes the `blur` property, set to false. For example:\n\n<docs-code language=\"angular-html\">\n\n<img\n  ngSrc=\"cat.jpg\"\n  width=\"400\"\n  height=\"200\"\n  placeholder\n  [placeholderConfig]=\"{blur: false}\"\n/>\n\n</docs-code>\n\n## Adjusting image styling\n\nDepending on the image's styling, adding `width` and `height` attributes may cause the image to render differently. `NgOptimizedImage` warns you if your image styling renders the image at a distorted aspect ratio.\n\nYou can typically fix this by adding `height: auto` or `width: auto` to your image styles. For more information, see the [web.dev article on the `<img>` tag](https://web.dev/patterns/web-vitals-patterns/images/img-tag).\n\nIf the `width` and `height` attribute on the image are preventing you from sizing the image the way you want with CSS, consider using `fill` mode instead, and styling the image's parent element.\n\n## Performance Features\n\nNgOptimizedImage includes a number of features designed to improve loading performance in your app. These features are described in this section.\n\n### Add resource hints\n\nA [`preconnect` resource hint](https://web.dev/preconnect-and-dns-prefetch) for your image origin ensures that the LCP image loads as quickly as possible.\n\nPreconnect links are automatically generated for domains provided as an argument to a [loader](#optional-set-up-a-loader). If an image origin cannot be automatically identified, and no preconnect link is detected for the LCP image, `NgOptimizedImage` will warn during development. In that case, you should manually add a resource hint to `index.html`. Within the `<head>` of the document, add a `link` tag with `rel=\"preconnect\"`, as shown below:\n\n<docs-code language=\"html\">\n\n<link rel=\"preconnect\" href=\"https://my.cdn.origin\" />\n\n</docs-code>\n\n\nTo disable preconnect warnings, inject the `PRECONNECT_CHECK_BLOCKLIST` token:\n\n<docs-code language=\"typescript\">\n\nproviders: [\n  {provide: PRECONNECT_CHECK_BLOCKLIST, useValue: 'https://your-domain.com'}\n],\n\n</docs-code>\n\nSee more information on automatic preconnect generation [here](#why-is-a-preconnect-element-not-being-generated-for-my-image-domain).\n\n\n### Request images at the correct size with automatic `srcset`\n\nDefining a [`srcset` attribute](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/srcset) ensures that the browser requests an image at the right size for your user's viewport, so it doesn't waste time downloading an image that's too large. `NgOptimizedImage` generates an appropriate `srcset` for the image, based on the presence and value of the [`sizes` attribute](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes) on the image tag.\n\n#### Fixed-size images\n\nIf your image should be \"fixed\" in size  (i.e. the same size across devices, except for [pixel density](https://web.dev/codelab-density-descriptors/)), there is no need to set a `sizes` attribute. A `srcset` can be generated automatically from the image's width and height attributes with no further input required.\n\nExample srcset generated:\n```angular-html\n<img ... srcset=\"image-400w.jpg 1x, image-800w.jpg 2x\">\n```\n\n#### Responsive images\n\nIf your image should be responsive (i.e. grow and shrink according to viewport size), then you will need to define a [`sizes` attribute](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes) to generate the `srcset`.\n\nIf you haven't used `sizes` before, a good place to start is to set it based on viewport width. For example, if your CSS causes the image to fill 100% of viewport width, set `sizes` to `100vw` and the browser will select the image in the `srcset` that is closest to the viewport width (after accounting for pixel density). If your image is only likely to take up half the screen (ex: in a sidebar), set `sizes` to `50vw` to ensure the browser selects a smaller image. And so on.\n\nIf you find that the above does not cover your desired image behavior, see the documentation on [advanced sizes values](#advanced-sizes-values).\n\nNote that `NgOptimizedImage` automatically prepends `\"auto\"` to the provided `sizes` value. This is an optimization that increases the accuracy of srcset selection on browsers which support `sizes=\"auto\"`, and is ignored by browsers which do not.\n\nBy default, the responsive breakpoints are:\n\n`[16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840]`\n\nIf you would like to customize these breakpoints, you can do so using the `IMAGE_CONFIG` provider:\n\n<docs-code language=\"typescript\">\nproviders: [\n  {\n    provide: IMAGE_CONFIG,\n    useValue: {\n      breakpoints: [16, 48, 96, 128, 384, 640, 750, 828, 1080, 1200, 1920]\n    }\n  },\n],\n</docs-code>\n\nIf you would like to manually define a `srcset` attribute, you can provide your own using the `ngSrcset` attribute:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"hero.jpg\" ngSrcset=\"100w, 200w, 300w\">\n\n</docs-code>\n\nIf the `ngSrcset` attribute is present, `NgOptimizedImage` generates and sets the `srcset` based on the sizes included. Do not include image file names in `ngSrcset` - the directive infers this information from `ngSrc`. The directive supports both width descriptors (e.g. `100w`) and density descriptors (e.g. `1x`).\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"hero.jpg\" ngSrcset=\"100w, 200w, 300w\" sizes=\"50vw\">\n\n</docs-code>\n\n### Disabling automatic srcset generation\n\nTo disable srcset generation for a single image, you can add the `disableOptimizedSrcset` attribute on the image:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"about.jpg\" disableOptimizedSrcset>\n\n</docs-code>\n\n### Disabling image lazy loading\n\nBy default, `NgOptimizedImage` sets `loading=lazy` for all images that are not marked `priority`. You can disable this behavior for non-priority images by setting the `loading` attribute. This attribute accepts values: `eager`, `auto`, and `lazy`. [See the documentation for the standard image `loading` attribute for details](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/loading#value).\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" loading=\"eager\">\n\n</docs-code>\n\n### Advanced 'sizes' values\n\nYou may want to have images displayed at varying widths on differently-sized screens. A common example of this pattern is a grid- or column-based layout that renders a single column on mobile devices, and two columns on larger devices. You can capture this behavior in the `sizes` attribute, using a \"media query\" syntax, such as the following:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"cat.jpg\" width=\"400\" height=\"200\" sizes=\"(max-width: 768px) 100vw, 50vw\">\n\n</docs-code>\n\nThe `sizes` attribute in the above example says \"I expect this image to be 100 percent of the screen width on devices under 768px wide. Otherwise, I expect it to be 50 percent of the screen width.\n\nFor additional information about the `sizes` attribute, see [web.dev](https://web.dev/learn/design/responsive-images/#sizes) or [mdn](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/sizes).\n\n## Configuring an image loader for `NgOptimizedImage`\n\nA \"loader\" is a function that generates an [image transformation URL](https://web.dev/image-cdns/#how-image-cdns-use-urls-to-indicate-optimization-options) for a given image file. When appropriate, `NgOptimizedImage` sets the size, format, and image quality transformations for an image.\n\n`NgOptimizedImage` provides both a generic loader that applies no transformations, as well as loaders for various third-party image services. It also supports writing your own custom loader.\n\n| Loader type| Behavior |\n|:--- |:--- |\n| Generic loader | The URL returned by the generic loader will always match the value of `src`. In other words, this loader applies no transformations. Sites that use Angular to serve images are the primary intended use case for this loader.|\n| Loaders for third-party image services | The URL returned by the loaders for third-party image services will follow API conventions used by that particular image service. |\n| Custom loaders | A custom loader's behavior is defined by its developer. You should use a custom loader if your image service isn't supported by the loaders that come preconfigured with `NgOptimizedImage`.|\n\nBased on the image services commonly used with Angular applications, `NgOptimizedImage` provides loaders preconfigured to work with the following image services:\n\n| Image Service | Angular API | Documentation |\n|:--- |:--- |:--- |\n| Cloudflare Image Resizing | `provideCloudflareLoader` | [Documentation](https://developers.cloudflare.com/images/image-resizing/) |\n| Cloudinary | `provideCloudinaryLoader` | [Documentation](https://cloudinary.com/documentation/resizing_and_cropping) |\n| ImageKit | `provideImageKitLoader` | [Documentation](https://docs.imagekit.io/) |\n| Imgix | `provideImgixLoader` | [Documentation](https://docs.imgix.com/) |\n| Netlify | `provideNetlifyLoader` | [Documentation](https://docs.netlify.com/image-cdn/overview/) |\n\nTo use the **generic loader** no additional code changes are necessary. This is the default behavior.\n\n### Built-in Loaders\n\nTo use an existing loader for a **third-party image service**, add the provider factory for your chosen service to the `providers` array. In the example below, the Imgix loader is used:\n\n<docs-code language=\"typescript\">\nproviders: [\n  provideImgixLoader('https://my.base.url/'),\n],\n</docs-code>\n\nThe base URL for your image assets should be passed to the provider factory as an argument. For most sites, this base URL should match one of the following patterns:\n\n* <https://yoursite.yourcdn.com>\n* <https://subdomain.yoursite.com>\n* <https://subdomain.yourcdn.com/yoursite>\n\nYou can learn more about the base URL structure in the docs of a corresponding CDN provider.\n\n### Custom Loaders\n\nTo use a **custom loader**, provide your loader function as a value for the `IMAGE_LOADER` DI token. In the example below, the custom loader function returns a URL starting with `https://example.com` that includes `src` and `width` as URL parameters.\n\n<docs-code language=\"typescript\">\nproviders: [\n  {\n    provide: IMAGE_LOADER,\n    useValue: (config: ImageLoaderConfig) => {\n      return `https://example.com/images?src=${config.src}&width=${config.width}`;\n    },\n  },\n],\n</docs-code>\n\nA loader function for the `NgOptimizedImage` directive takes an object with the `ImageLoaderConfig` type (from `@angular/common`) as its argument and returns the absolute URL of the image asset. The `ImageLoaderConfig` object contains the `src` property, and optional `width` and `loaderParams` properties.\n\nNOTE: even though the `width` property may not always be present, a custom loader must use it to support requesting images at various widths in order for `ngSrcset` to work properly.\n\n### The `loaderParams` Property\n\nThere is an additional attribute supported by the `NgOptimizedImage` directive, called `loaderParams`, which is specifically designed to support the use of custom loaders. The `loaderParams` attribute takes an object with any properties as a value, and does not do anything on its own. The data in `loaderParams` is added to the `ImageLoaderConfig` object passed to your custom loader, and can be used to control the behavior of the loader.\n\nA common use for `loaderParams` is controlling advanced image CDN features.\n\n### Example custom loader\n\nThe following shows an example of a custom loader function. This example function concatenates `src` and `width`, and uses `loaderParams` to control a custom CDN feature for rounded corners:\n\n<docs-code language=\"typescript\">\nconst myCustomLoader = (config: ImageLoaderConfig) => {\n  let url = `https://example.com/images/${config.src}?`;\n  let queryParams = [];\n  if (config.width) {\n    queryParams.push(`w=${config.width}`);\n  }\n  if (config.loaderParams?.roundedCorners) {\n    queryParams.push('mask=corners&corner-radius=5');\n  }\n  return url + queryParams.join('&');\n};\n</docs-code>\n\nNote that in the above example, we've invented the 'roundedCorners' property name to control a feature of our custom loader. We could then use this feature when creating an image, as follows:\n\n<docs-code language=\"angular-html\">\n\n<img ngSrc=\"profile.jpg\" width=\"300\" height=\"300\" [loaderParams]=\"{roundedCorners: true}\">\n\n</docs-code>\n\n## Frequently Asked Questions\n\n### Does NgOptimizedImage support the `background-image` css property?\n\nThe NgOptimizedImage does not directly support the `background-image` css property, but it is designed to easily accommodate the use case of having an image as the background of another element.\n\nFor a step-by-step process for migration from `background-image` to `NgOptimizedImage`, see the [How to migrate your background image](#how-to-migrate-your-background-image) section above.\n\n### Why can't I use `src` with `NgOptimizedImage`?\n\nThe `ngSrc` attribute was chosen as the trigger for NgOptimizedImage due to technical considerations around how images are loaded by the browser. NgOptimizedImage makes programmatic changes to the `loading` attribute -- if the browser sees the `src` attribute before those changes are made, it will begin eagerly downloading the image file, and the loading changes will be ignored.\n\n### Why is a preconnect element not being generated for my image domain?\nPreconnect generation is performed based on static analysis of your application. That means that the image domain must be directly included in the loader parameter, as in the following example:\n\n<docs-code language=\"typescript\">\nproviders: [\n  provideImgixLoader('https://my.base.url/'),\n],\n</docs-code>\n\nIf you use a variable to pass the domain string to the loader, or you're not using a loader, the static analysis will not be able to identify the domain, and no preconnect link will be generated. In this case you should manually add a preconnect link to the document head, as [described above](#add-resource-hints).\n\n\n### Can I use two different image domains in the same page?\n\nThe [image loaders](#configuring-an-image-loader-for-ngoptimizedimage) provider pattern is designed to be as simple as possible for the common use case of having only a single image CDN used within a component. However, it's still very possible to manage multiple image CDNs using a single provider.\n\nTo do this, we recommend writing a [custom image loader](#custom-loaders) which uses the [`loaderParams` property](#the-loaderparams-property) to pass a flag that specifies which image CDN should be used, and then invokes the appropriate loader based on that flag.\n\n### Can you add a new built-in loader for my preferred CDN?\n\nFor maintenance reasons, we don't currently plan to support additional built-in loaders in the Angular repository. Instead, we encourage developers to publish any additional image loaders as third-party packages.\n\n### Can I use this with the `<picture>` tag\n\nNo, but this is on our roadmap, so stay tuned.\n\nIf you're waiting on this feature, please upvote the Github issue [here](https://github.com/angular/angular/issues/56594).\n\n### How do I find my LCP image with Chrome DevTools?\n\n1. Using the performance tab of the Chrome DevTools, click on the \"start profiling and reload page\" button on the top left. It looks like a page refresh icon.\n\n2. This will trigger a profiling snapshot of your Angular application.\n\n3. Once the profiling result is available, select \"LCP\" in the timings section.\n\n4. A summary entry should appear in the panel at the bottom. You can find the LCP element in the row for \"related node\".  Clicking on it will reveal the element in the Elements panel.\n\n<img alt=\"LCP in the Chrome DevTools\" src=\"assets/images/guide/image-optimization/devtools-lcp.png\">\n\nNOTE: This only identifies the LCP element within the viewport of the page you are testing. It is also recommended to use mobile emulation to identify the LCP element for smaller screens.\n\n\n\n================================================\n",
    "endLine": 860
  },
  {
    "id": 3,
    "file": "incremental-hydration",
    "fullFileName": "adev/src/content/guide/incremental-hydration.md",
    "startLine": 864,
    "content": "# Incremental Hydration\n\nTIP: Incremental hydration is currently in [developer preview](/reference/releases#developer-preview).\n\n**Incremental hydration** is an advanced type of [hydration](guide/hydration) that can leave sections of your application dehydrated and _incrementally_ trigger hydration of those sections as they are needed.\n\n## Why use incremental hydration?\n\nIncremental hydration is a performance improvement that builds on top of full application hydration. It can produce smaller initial bundles while still providing an end-user experience that is comparable to a full application hydration experience. Smaller bundles improve initial load times, reducing [First Input Delay (FID)](https://web.dev/fid) and [Cumulative Layout Shift (CLS)](https://web.dev/cls).\n\nIncremental hydration also lets you use deferrable views (`@defer`) for content that may not have been deferrable before. Specifically, you can now use deferrable views for content that is above the fold. Prior to incremental hydration, putting a `@defer` block above the fold would result in placeholder content rendering and then being replaced by the `@defer` block's main template content. This would result in a layout shift. Incremental hydration means the main template of the `@defer` block will render with no layout shift on hydration.\n\n## How do you enable incremental hydration in Angular?\n\nYou can enable incremental hydration for applications that already use server-side rendering (SSR) with hydration. Follow the [Angular SSR Guide](guide/ssr) to enable server-side rendering and the [Angular Hydration Guide](guide/hydration) to enable hydration first.\n\nEnable incremental hydration by adding the `withIncrementalHydration()` function to the `provideClientHydration` provider.\n\n```typescript\nimport {\n  bootstrapApplication,\n  provideClientHydration,\n  withIncrementalHydration,\n} from '@angular/platform-browser';\n...\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration(withIncrementalHydration())]\n});\n```\n\nIncremental Hydration depends on and enables [event replay](guide/hydration#capturing-and-replaying-events) automatically. If you already have `withEventReplay()` in your list, you can safely remove it after enabling incremental hydration.\n\n## How does incremental hydration work?\n\nIncremental hydration builds on top of full-application [hydration](guide/hydration), [deferrable views](guide/defer), and [event replay](guide/hydration#capturing-and-replaying-events). With incremental hydration, you can add additional triggers to `@defer` blocks that define incremental hydration boundaries. Adding a `hydrate` trigger to a defer block tells Angular that it should load that defer block's dependencies during server-side rendering and render the main template rather than the `@placeholder`. When client-side rendering, the dependencies are still deferred, and the defer block content stays dehydrated until its `hydrate` trigger fires. That trigger tells the defer block to fetch its dependencies and hydrate the content. Any browser events, specifically those that match listeners registered in your component, that are triggered by the user prior to hydration are queued up and replayed once the hydration process is complete.\n\n## Controlling hydration of content with triggers\n\nYou can specify **hydrate triggers** that control when Angular loads and hydrates deferred content. These are additional triggers that can be used alongside regular `@defer` triggers.\n\nEach `@defer` block may have multiple hydrate event triggers, separated with a semicolon (`;`). Angular triggers hydration when _any_ of the triggers fire.\n\nThere are three types of hydrate triggers: `hydrate on`, `hydrate when`, and `hydrate never`.\n\n### `hydrate on`\n\n`hydrate on` specifies a condition for when hydration is triggered for the `@defer` block.\n\nThe available triggers are as follows:\n\n| Trigger                                             | Description                                                            |\n| --------------------------------------------------- | ---------------------------------------------------------------------- |\n| [`hydrate on idle`](#hydrate-on-idle)               | Triggers when the browser is idle.                                     |\n| [`hydrate on viewport`](#hydrate-on-viewport)       | Triggers when specified content enters the viewport                    |\n| [`hydrate on interaction`](#hydrate-on-interaction) | Triggers when the user interacts with specified element                |\n| [`hydrate on hover`](#hydrate-on-hover)             | Triggers when the mouse hovers over specified area                     |\n| [`hydrate on immediate`](#hydrate-on-immediate)     | Triggers immediately after non-deferred content has finished rendering |\n| [`hydrate on timer`](#hydrate-on-timer)             | Triggers after a specific duration                                     |\n\n#### `hydrate on idle`\n\nThe `hydrate on idle` trigger loads the deferrable view's dependencies and hydrates the content once the browser has reached an idle state, based on `requestIdleCallback`.\n\n```angular-html\n@defer (hydrate on idle) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `hydrate on viewport`\n\nThe `hydrate on viewport` trigger loads the deferrable view's dependencies and hydrates the corresponding page of the app when the specified content enters the viewport using the\n[Intersection Observer API](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API).\n\n```angular-html\n@defer (hydrate on viewport) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `hydrate on interaction`\n\nThe `hydrate on interaction` trigger loads the deferrable view's dependencies and hydrates the content when the user interacts with the specified element through\n`click` or `keydown` events.\n\n```angular-html\n@defer (hydrate on interaction) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `hydrate on hover`\n\nThe `hydrate on hover` trigger loads the deferrable view's dependencies and hydrates the content when the mouse has hovered over the triggered area through the\n`mouseover` and `focusin` events.\n\n```angular-html\n@defer (hydrate on hover) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `hydrate on immediate`\n\nThe `hydrate on immediate` trigger loads the deferrable view's dependencies and hydrates the content immediately. This means that the deferred block loads as soon\nas all other non-deferred content has finished rendering.\n\n```angular-html\n@defer (hydrate on immediate) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `hydrate on timer`\n\nThe `hydrate on timer` trigger loads the deferrable view's dependencies and hydrates the content after a specified duration.\n\n```angular-html\n@defer (hydrate on timer(500ms)) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nThe duration parameter must be specified in milliseconds (`ms`) or seconds (`s`).\n\n### `hydrate when`\n\nThe `hydrate when` trigger accepts a custom conditional expression and loads the deferrable view's dependencies and hydrates the content when the\ncondition becomes truthy.\n\n```angular-html\n@defer (hydrate when condition) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nNOTE: `hydrate when` conditions only trigger when they are the top-most dehydrated `@defer` block. The condition provided for the trigger is\nspecified in the parent component, which needs to exist before it can be triggered. If the parent block is dehydrated, that expression will not yet\nbe resolvable by Angular.\n\n### `hydrate never`\n\nThe `hydrate never` allows users to specify that the content in the defer block should remain dehydrated indefinitely, effectively becoming static\ncontent. Note that this applies to the initial render only. During a subsequent client-side render, a `@defer` block with `hydrate never` would\nstill fetch dependencies, as hydration only applies to initial load of server-side rendered content. In the example below, subsequent client-side\nrenders would load the `@defer` block dependencies on viewport.\n\n```angular-html\n@defer (on viewport; hydrate never) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nNOTE: Using `hydrate never` prevents hydration of the entire nested subtree of a given `@defer` block. No other `hydrate` triggers fire for content nested underneath that block.\n\n## Hydrate triggers alongside regular triggers\n\nHydrate triggers are additional triggers that are used alongside regular triggers on a `@defer` block. Hydration is an initial load optimization, and that means hydrate triggers only apply to that initial load. Any subsequent client side render will still use the regular trigger.\n\n```angular-html\n@defer (on idle; hydrate on interaction) {\n  <example-cmp />\n} @placeholder{\n  <div>Example Placeholder</div>\n}\n```\n\nIn this example, on the initial load, the `hydrate on interaction` applies. Hydration will be triggered on interaction with the `<example-cmp />` component. On any subsequent page load that is client-side rendered, for example when a user clicks a routerLink that loads a page with this component, the `on idle` will apply.\n\n## How does incremental hydration work with nested `@defer` blocks?\n\nAngular's component and dependency system is hierarchical, which means hydrating any component requires all of its parents also be hydrated. So if hydration is triggered for a child `@defer` block of a nested set of dehydrated `@defer` blocks, hydration is triggered from the top-most dehydrated `@defer` block down to the triggered child and fire in that order.\n\n```angular-html\n@defer (hydrate on interaction) {\n  <parent-block-cmp />\n  @defer (hydrate on hover) {\n    <child-block-cmp />\n  } @placeholder {\n    <div>Child placeholder</div>\n  }\n} @placeholder{\n  <div>Parent Placeholder</div>\n}\n```\n\nIn the above example, hovering over the nested `@defer` block triggers hydration. The parent `@defer` block with the `<parent-block-cmp />` hydrates first, then the child `@defer` block with `<child-block-cmp />` hydrates after.\n\n## Constraints\n\nIncremental hydration has the same constraints as full-application hydration, including limits on direct DOM manipulation and requiring valid HTML structure. Visit the [Hydration guide constraints](guide/hydration#constraints) section for more details.\n\n## Do I still need to specify `@placeholder` blocks?\n\nYes. `@placeholder` block content is not used for incremental hydration, but a `@placeholder` is still necessary for subsequent client-side rendering cases. If your content was not on the route that was part of the initial load, then any navigation to the route that has your `@defer` block content renders like a regular `@defer` block. So the `@placeholder` is rendered in those client-side rendering cases.\n\n\n\n================================================\n",
    "endLine": 1078
  },
  {
    "id": 4,
    "file": "security",
    "fullFileName": "adev/src/content/guide/security.md",
    "startLine": 1082,
    "content": "# Security\n\nThis topic describes Angular's built-in protections against common web application vulnerabilities and attacks such as cross-site scripting attacks.\nIt doesn't cover application-level security, such as authentication and authorization.\n\nFor more information about the attacks and mitigations described below, see the [Open Web Application Security Project (OWASP) Guide](https://www.owasp.org/index.php/Category:OWASP_Guide_Project).\n\n<a id=\"report-issues\"></a>\n\n<docs-callout title=\"Reporting vulnerabilities\">\n\nAngular is part of Google [Open Source Software Vulnerability Reward Program](https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules). For vulnerabilities in Angular, please submit your report at [https://bughunters.google.com](https://bughunters.google.com/report).\n\nFor more information about how Google handles security issues, see [Google's security philosophy](https://www.google.com/about/appsecurity).\n\n</docs-callout>\n\n## Best practices\n\nThese are some best practices to ensure that your Angular application is secure.\n\n1. **Keep current with the latest Angular library releases** - The Angular libraries get regular updates, and these updates might fix security defects discovered in previous versions. Check the Angular [change log](https://github.com/angular/angular/blob/main/CHANGELOG.md) for security-related updates.\n2. **Don't alter your copy of Angular** - Private, customized versions of Angular tend to fall behind the current version and might not include important security fixes and enhancements. Instead, share your Angular improvements with the community and make a pull request.\n3. **Avoid Angular APIs marked in the documentation as \"_Security Risk_\"** - For more information, see the [Trusting safe values](#trusting-safe-values) section of this page.\n\n## Preventing cross-site scripting (XSS)\n\n[Cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) enables attackers to inject malicious code into web pages.\nSuch code can then, for example, steal user and login data, or perform actions that impersonate the user.\nThis is one of the most common attacks on the web.\n\nTo block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).\nFor example, if attackers can trick you into inserting a `<script>` tag in the DOM, they can run arbitrary code on your website.\nThe attack isn't limited to `<script>` tags —many elements and properties in the DOM allow code execution, for example, `<img alt=\"\" onerror=\"...\">` and `<a href=\"javascript:...\">`.\nIf attacker-controlled data enters the DOM, expect security vulnerabilities.\n\n### Angular's cross-site scripting security model\n\nTo systematically block XSS bugs, Angular treats all values as untrusted by default.\nWhen a value is inserted into the DOM from a template binding, or interpolation, Angular sanitizes and escapes untrusted values.\nIf a value was already sanitized outside of Angular and is considered safe, communicate this to Angular by marking the [value as trusted](#trusting-safe-values).\n\nUnlike values to be used for rendering, Angular templates are considered trusted by default, and should be treated as executable code.\nNever create templates by concatenating user input and template syntax.\nDoing this would enable attackers to [inject arbitrary code](https://en.wikipedia.org/wiki/Code_injection) into your application.\nTo prevent these vulnerabilities, always use the default [Ahead-Of-Time (AOT) template compiler](#use-the-aot-template-compiler) in production deployments.\n\nAn extra layer of protection can be provided through the use of Content security policy and Trusted Types.\nThese web platform features operate at the DOM level which is the most effective place to prevent XSS issues. Here they can't be bypassed using other, lower-level APIs.\nFor this reason, it is strongly encouraged to take advantage of these features. To do this, configure the [content security policy](#content-security-policy) for the application and enable [trusted types enforcement](#enforcing-trusted-types).\n\n### Sanitization and security contexts\n\n*Sanitization* is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM.\nIn many cases, sanitization doesn't change a value at all.\nSanitization depends on a context.\nFor example, a value that's harmless in CSS is potentially dangerous in a URL.\n\nAngular defines the following security contexts:\n\n| Security contexts | Details                                                                           |\n| :---------------- | :-------------------------------------------------------------------------------- |\n| HTML              | Used when interpreting a value as HTML, for example, when binding to `innerHtml`. |\n| Style             | Used when binding CSS into the `style` property.                                  |\n| URL               | Used for URL properties, such as `<a href>`.                                      |\n| Resource URL      | A URL that is loaded and executed as code, for example, in `<script src>`.        |\n\nAngular sanitizes untrusted values for HTML and URLs. Sanitizing resource URLs isn't possible because they contain arbitrary code.\nIn development mode, Angular prints a console warning when it has to change a value during sanitization.\n\n### Sanitization example\n\nThe following template binds the value of `htmlSnippet`. Once by interpolating it into an element's content, and once by binding it to the `innerHTML` property of an element:\n\n<docs-code header=\"src/app/inner-html-binding.component.html\" path=\"adev/src/content/examples/security/src/app/inner-html-binding.component.html\"/>\n\nInterpolated content is always escaped —the HTML isn't interpreted and the browser displays angle brackets in the element's text content.\n\nFor the HTML to be interpreted, bind it to an HTML property such as `innerHTML`.\nBe aware that binding a value that an attacker might control into `innerHTML` normally causes an XSS vulnerability.\nFor example, one could run JavaScript in a following way:\n\n<docs-code header=\"src/app/inner-html-binding.component.ts (class)\" path=\"adev/src/content/examples/security/src/app/inner-html-binding.component.ts\" visibleRegion=\"class\"/>\n\nAngular recognizes the value as unsafe and automatically sanitizes it, which removes the `script` element but keeps safe content such as the `<b>` element.\n\n<img alt=\"A screenshot showing interpolated and bound HTML values\" src=\"assets/images/guide/security/binding-inner-html.png#small\">\n\n### Direct use of the DOM APIs and explicit sanitization calls\n\nUnless you enforce Trusted Types, the built-in browser DOM APIs don't automatically protect you from security vulnerabilities.\nFor example, `document`, the node available through `ElementRef`, and many third-party APIs contain unsafe methods.\nLikewise, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations.\nAvoid directly interacting with the DOM and instead use Angular templates where possible.\n\nFor cases where this is unavoidable, use the built-in Angular sanitization functions.\nSanitize untrusted values with the [DomSanitizer.sanitize](api/platform-browser/DomSanitizer#sanitize) method and the appropriate `SecurityContext`.\nThat function also accepts values that were marked as trusted using the `bypassSecurityTrust` functions, and does not sanitize them, as [described below](#trusting-safe-values).\n\n### Trusting safe values\n\nSometimes applications genuinely need to include executable code, display an `<iframe>` from some URL, or construct potentially dangerous URLs.\nTo prevent automatic sanitization in these situations, tell Angular that you inspected a value, checked how it was created, and made sure it is secure.\nDo _be careful_.\nIf you trust a value that might be malicious, you are introducing a security vulnerability into your application.\nIf in doubt, find a professional security reviewer.\n\nTo mark a value as trusted, inject `DomSanitizer` and call one of the following methods:\n\n* `bypassSecurityTrustHtml`\n* `bypassSecurityTrustScript`\n* `bypassSecurityTrustStyle`\n* `bypassSecurityTrustUrl`\n* `bypassSecurityTrustResourceUrl`\n\nRemember, whether a value is safe depends on context, so choose the right context for your intended use of the value.\nImagine that the following template needs to bind a URL to a `javascript:alert(...)` call:\n\n<docs-code header=\"src/app/bypass-security.component.html (URL)\" path=\"adev/src/content/examples/security/src/app/bypass-security.component.html\" visibleRegion=\"URL\"/>\n\nNormally, Angular automatically sanitizes the URL, disables the dangerous code, and in development mode, logs this action to the console.\nTo prevent this, mark the URL value as a trusted URL using the `bypassSecurityTrustUrl` call:\n\n<docs-code header=\"src/app/bypass-security.component.ts (trust-url)\" path=\"adev/src/content/examples/security/src/app/bypass-security.component.ts\" visibleRegion=\"trust-url\"/>\n\n<img alt=\"A screenshot showing an alert box created from a trusted URL\" src=\"assets/images/guide/security/bypass-security-component.png#medium\">\n\nIf you need to convert user input into a trusted value, use a component method.\nThe following template lets users enter a YouTube video ID and load the corresponding video in an `<iframe>`.\nThe `<iframe src>` attribute is a resource URL security context, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users could run.\nTo prevent this, call a method on the component to construct a trusted video URL, which causes Angular to let binding into `<iframe src>`:\n\n<docs-code header=\"src/app/bypass-security.component.html (iframe)\" path=\"adev/src/content/examples/security/src/app/bypass-security.component.html\" visibleRegion=\"iframe\"/>\n\n<docs-code header=\"src/app/bypass-security.component.ts (trust-video-url)\" path=\"adev/src/content/examples/security/src/app/bypass-security.component.ts\" visibleRegion=\"trust-video-url\"/>\n\n### Content security policy\n\nContent Security Policy \\(CSP\\) is a defense-in-depth technique to prevent XSS.\nTo enable CSP, configure your web server to return an appropriate `Content-Security-Policy` HTTP header.\nRead more about content security policy at the [Web Fundamentals guide](https://developers.google.com/web/fundamentals/security/csp) on the Google Developers website.\n\nThe minimal policy required for a brand-new Angular application is:\n\n<docs-code language=\"text\">\n\ndefault-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';\n\n</docs-code>\n\nWhen serving your Angular application, the server should include a  randomly-generated nonce in the HTTP header for each request.\nYou must provide this nonce to Angular so that the framework can render `<style>` elements.\nYou can set the nonce for Angular in one of two ways:\n\n1. Set the `ngCspNonce` attribute on the root application element as `<app ngCspNonce=\"randomNonceGoesHere\"></app>`. Use this approach if you have access to server-side templating that can add the nonce both to the header and the `index.html` when constructing the response.\n2. Provide the nonce using the `CSP_NONCE` injection token. Use this approach if you have access to the nonce at runtime and you want to be able to cache the `index.html`.\n\n<docs-code language=\"typescript\">\n\nimport {bootstrapApplication, CSP_NONCE} from '@angular/core';\nimport {AppComponent} from './app/app.component';\n\nbootstrapApplication(AppComponent, {\n  providers: [{\n    provide: CSP_NONCE,\n    useValue: globalThis.myRandomNonceValue\n  }]\n});\n\n</docs-code>\n\n<docs-callout title=\"Unique nonces\">\n\nAlways ensure that the nonces you provide are <strong>unique per request</strong> and that they are not predictable or guessable.\nIf an attacker can predict future nonces, they can circumvent the protections offered by CSP.\n\n</docs-callout>\n\nIf you cannot generate nonces in your project, you can allow inline styles by adding `'unsafe-inline'` to the `style-src` section of the CSP header.\n\n| Sections                                         | Details                                                                                                                                                                                                         |\n| :----------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `default-src 'self';`                            | Allows the page to load all its required resources from the same origin.                                                                                                                                        |\n| `style-src 'self' 'nonce-randomNonceGoesHere';`  | Allows the page to load global styles from the same origin \\(`'self'`\\) and styles inserted by Angular with the `nonce-randomNonceGoesHere`.                                                                    |\n| `script-src 'self' 'nonce-randomNonceGoesHere';` | Allows the page to load JavaScript from the same origin \\(`'self'`\\) and scripts inserted by the Angular CLI with the `nonce-randomNonceGoesHere`. This is only required if you're using critical CSS inlining. |\n\nAngular itself requires only these settings to function correctly.\nAs your project grows, you may need to expand your CSP settings to accommodate extra features specific to your application.\n\n### Enforcing Trusted Types\n\nIt is recommended that you use [Trusted Types](https://w3c.github.io/trusted-types/dist/spec/) as a way to help secure your applications from cross-site scripting attacks.\nTrusted Types is a [web platform](https://en.wikipedia.org/wiki/Web_platform) feature that can help you prevent cross-site scripting attacks by enforcing safer coding practices.\nTrusted Types can also help simplify the auditing of application code.\n\n<docs-callout title=\"Trusted types\">\n\nTrusted Types might not yet be available in all browsers your application targets.\nIn the case your Trusted-Types-enabled application runs in a browser that doesn't support Trusted Types, the features of the application are preserved. Your application is guarded against XSS by way of Angular's DomSanitizer.\nSee [caniuse.com/trusted-types](https://caniuse.com/trusted-types) for the current browser support.\n\n</docs-callout>\n\nTo enforce Trusted Types for your application, you must configure your application's web server to emit HTTP headers with one of the following Angular policies:\n\n| Policies                 | Detail                                                                                                                                                                                                                                                                                     |\n| :----------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `angular`                | This policy is used in security-reviewed code that is internal to Angular, and is required for Angular to function when Trusted Types are enforced. Any inline template values or content sanitized by Angular is treated as safe by this policy.                                          |\n| `angular#bundler`        | This policy is used by the Angular CLI bundler when creating lazy chunk files.                                                                                                                                                                                                             |\n| `angular#unsafe-bypass`  | This policy is used for applications that use any of the methods in Angular's [DomSanitizer](api/platform-browser/DomSanitizer) that bypass security, such as `bypassSecurityTrustHtml`. Any application that uses these methods must enable this policy.                                  |\n| `angular#unsafe-jit`     | This policy is used by the [Just-In-Time (JIT) compiler](api/core/Compiler). You must enable this policy if your application interacts directly with the JIT compiler or is running in JIT mode using the [platform browser dynamic](api/platform-browser-dynamic/platformBrowserDynamic). |\n| `angular#unsafe-upgrade` | This policy is used by the [@angular/upgrade](api/upgrade/static/UpgradeModule) package. You must enable this policy if your application is an AngularJS hybrid. |\n\nYou should configure the HTTP headers for Trusted Types in the following locations:\n\n* Production serving infrastructure\n* Angular CLI \\(`ng serve`\\), using the `headers` property in the `angular.json` file, for local development and end-to-end testing\n* Karma \\(`ng test`\\), using the `customHeaders` property in the `karma.config.js` file, for unit testing\n\nThe following is an example of a header specifically configured for Trusted Types and Angular:\n\n<docs-code language=\"html\">\n\nContent-Security-Policy: trusted-types angular; require-trusted-types-for 'script';\n\n</docs-code>\n\nAn example of a header specifically configured for Trusted Types and Angular applications that use any of Angular's methods in [DomSanitizer](api/platform-browser/DomSanitizer) that bypasses security:\n\n<docs-code language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';\n\n</docs-code>\n\nThe following is an example of a header specifically configured for Trusted Types and Angular applications using JIT:\n\n<docs-code language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';\n\n</docs-code>\n\nThe following is an example of a header specifically configured for Trusted Types and Angular applications that use lazy loading of modules:\n\n<docs-code language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';\n\n</docs-code>\n\n<docs-callout title=\"Community contributions\">\n\nTo learn more about troubleshooting Trusted Type configurations, the following resource might be helpful:\n\n[Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types](https://web.dev/trusted-types/#how-to-use-trusted-types)\n\n</docs-callout>\n\n### Use the AOT template compiler\n\nThe AOT template compiler prevents a whole class of vulnerabilities called template injection, and greatly improves application performance.\nThe AOT template compiler is the default compiler used by Angular CLI applications, and you should use it in all production deployments.\n\nAn alternative to the AOT compiler is the JIT compiler which compiles templates to executable template code within the browser at runtime.\nAngular trusts template code, so dynamically generating templates and compiling them, in particular templates containing user data, circumvents Angular's built-in protections. This is a security anti-pattern.\nFor information about dynamically constructing forms in a safe way, see the [Dynamic Forms](guide/forms/dynamic-forms) guide.\n\n### Server-side XSS protection\n\nHTML constructed on the server is vulnerable to injection attacks.\nInjecting template code into an Angular application is the same as injecting executable code into the application:\nIt gives the attacker full control over the application.\nTo prevent this, use a templating language that automatically escapes values to prevent XSS vulnerabilities on the server.\nDon't create Angular templates on the server side using a templating language. This carries a high risk of introducing template-injection vulnerabilities.\n\n## HTTP-level vulnerabilities\n\nAngular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery \\(CSRF or XSRF\\) and cross-site script inclusion \\(XSSI\\).\nBoth of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier.\n\n### Cross-site request forgery\n\nIn a cross-site request forgery \\(CSRF or XSRF\\), an attacker tricks the user into visiting a different web page \\(such as `evil.com`\\) with malignant code. This web page secretly sends a malicious request to the application's web server \\(such as `example-bank.com`\\).\n\nAssume the user is logged into the application at `example-bank.com`.\nThe user opens an email and clicks a link to `evil.com`, which opens in a new tab.\n\nThe `evil.com` page immediately sends a malicious request to `example-bank.com`.\nPerhaps it's a request to transfer money from the user's account to the attacker's account.\nThe browser automatically sends the `example-bank.com` cookies, including the authentication cookie, with this request.\n\nIf the `example-bank.com` server lacks XSRF protection, it can't tell the difference between a legitimate request from the application and the forged request from `evil.com`.\n\nTo prevent this, the application must ensure that a user request originates from the real application, not from a different site.\nThe server and client must cooperate to thwart this attack.\n\nIn a common anti-XSRF technique, the application server sends a randomly created authentication token in a cookie.\nThe client code reads the cookie and adds a custom request header with the token in all following requests.\nThe server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match.\n\nThis technique is effective because all browsers implement the _same origin policy_.\nOnly code from the website on which cookies are set can read the cookies from that site and set custom headers on requests to that site.\nThat means only your application can read this cookie token and set the custom header.\nThe malicious code on `evil.com` can't.\n\n### `HttpClient` XSRF/CSRF security\n\n`HttpClient` supports a [common mechanism](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) used to prevent XSRF attacks. When performing HTTP requests, an interceptor reads a token from a cookie, by default `XSRF-TOKEN`, and sets it as an HTTP header, `X-XSRF-TOKEN`. Because only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.\n\nBy default, an interceptor sends this header on all mutating requests (such as `POST`) to relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.\n\n<docs-callout helpful title=\"Why not protect GET requests?\">\nCSRF protection is only needed for requests that can change state on the backend. By their nature, CSRF attacks cross domain boundaries, and the web's [same-origin policy](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) will prevent an attacking page from retrieving the results of authenticated GET requests.\n</docs-callout>\n\nTo take advantage of this, your server needs to set a token in a JavaScript readable session cookie called `XSRF-TOKEN` on either the page load or the first GET request. On subsequent requests the server can verify that the cookie matches the `X-XSRF-TOKEN` HTTP header, and therefore be sure that only code running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens. Set the token to a digest of your site's authentication cookie with a salt for added security.\n\nTo prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.\n\n<docs-callout important title=\"HttpClient supports only the client half of the XSRF protection scheme\">\n  Your backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests. Failing to do so renders Angular's default protection ineffective.\n</docs-callout>\n\n### Configure custom cookie/header names\n\nIf your backend service uses different names for the XSRF token cookie or header, use `withXsrfConfiguration` to override the defaults.\n\nAdd it to the `provideHttpClient` call as follows:\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withXsrfConfiguration({\n        cookieName: 'CUSTOM_XSRF_TOKEN',\n        headerName: 'X-Custom-Xsrf-Header',\n      }),\n    ),\n  ]\n};\n</docs-code>\n\n### Disabling XSRF protection\n\nIf the built-in XSRF protection mechanism doesn't work for your application, you can disable it using the `withNoXsrfProtection` feature:\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withNoXsrfProtection(),\n    ),\n  ]\n};\n</docs-code>\n\nFor information about CSRF at the Open Web Application Security Project \\(OWASP\\), see [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) and [Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html).\nThe Stanford University paper [Robust Defenses for Cross-Site Request Forgery](https://seclab.stanford.edu/websec/csrf/csrf.pdf) is a rich source of detail.\n\nSee also Dave Smith's [talk on XSRF at AngularConnect 2016](https://www.youtube.com/watch?v=9inczw6qtpY \"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\").\n\n### Cross-site script inclusion (XSSI)\n\nCross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to read data from a JSON API.\nThe attack works on older browsers by overriding built-in JavaScript object constructors, and then including an API URL using a `<script>` tag.\n\nThis attack is only successful if the returned JSON is executable as JavaScript.\nServers can prevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the well-known string `\")]}',\\n\"`.\n\nAngular's `HttpClient` library recognizes this convention and automatically strips the string `\")]}',\\n\"` from all responses before further parsing.\n\nFor more information, see the XSSI section of this [Google web security blog post](https://security.googleblog.com/2011/05/website-security-for-webmasters.html).\n\n## Auditing Angular applications\n\nAngular applications must follow the same security principles as regular web applications, and must be audited as such.\nAngular-specific APIs that should be audited in a security review, such as the [_bypassSecurityTrust_](#trusting-safe-values) methods, are marked in the documentation as security sensitive.\n\n\n\n================================================\n",
    "endLine": 1462
  },
  {
    "id": 5,
    "file": "ssr",
    "fullFileName": "adev/src/content/guide/ssr.md",
    "startLine": 1466,
    "content": "# Server and hybrid rendering\n\n## What is hybrid rendering?\n\nHybrid rendering combines the benefits of server-side rendering (SSR), pre-rendering (also known as \"static site generation\" or SSG) and client-side rendering (CSR) to optimize your Angular application. It allows you to render different parts of your application using different strategies, giving you fine-grained control over how your app is delivered to users.\n\n## Setting up hybrid rendering\n\nYou can create a **new** project with server-side rendering with the Angular CLI:\n\n```shell\nng new --ssr\n```\n\nYou can also add server-side rendering to an existing project with the `ng add` command:\n\n```shell\nng add @angular/ssr\n```\n\nNOTE: By default, Angular prerenders your entire application and generates a server file. To disable this and create a fully static app, set `outputMode` to `static`. To enable SSR, update the server routes to use `RenderMode.Server`.\nFor more details, see [`Server routing`](#server-routing) and [`Generate a fully static application`](#generate-a-fully-static-application).\n\n## Server routing\n\n### Configuring server routes\n\nYou can create a server route config by declaring an array of [`ServerRoute`](api/ssr/ServerRoute 'API reference') objects. This configuration typically lives in a file named `app.routes.server.ts`.\n\n```typescript\n// app.routes.server.ts\nimport { RenderMode, ServerRoute } from '@angular/ssr';\n\nexport const serverRoutes: ServerRoute[] = [\n  {\n    path: '', // This renders the \"/\" route on the client (CSR)\n    renderMode: RenderMode.Client,\n  },\n  {\n    path: 'about', // This page is static, so we prerender it (SSG)\n    renderMode: RenderMode.Prerender,\n  },\n  {\n    path: 'profile', // This page requires user-specific data, so we use SSR\n    renderMode: RenderMode.Server,\n  },\n  {\n    path: '**', // All other routes will be rendered on the server (SSR)\n    renderMode: RenderMode.Server,\n  },\n];\n```\n\nYou can add this config to your application with [`provideServerRendering`](api/ssr/provideServerRendering 'API reference') using the [`withRoutes`](api/ssr/withRoutes 'API reference') function:\n\n```typescript\nimport { provideServerRendering, withRoutes } from '@angular/ssr';\nimport { serverRoutes } from './app.routes.server';\n\n// app.config.server.ts\nconst serverConfig: ApplicationConfig = {\n  providers: [\n    provideServerRendering(withRoutes(serverRoutes)),\n    // ... other providers ...\n  ]\n};\n```\n\nWhen using the [App shell pattern](ecosystem/service-workers/app-shell), you must specify the component to be used as the app shell for client-side rendered routes. To do this, use the [`withAppShell`](api/ssr/withAppShell 'API reference') fetaure:\n\n```typescript\nimport { provideServerRendering, withRoutes, withAppShell } from '@angular/ssr';\nimport { AppShellComponent } from './app-shell/app-shell.component';\n\nconst serverConfig: ApplicationConfig = {\n  providers: [\n    provideServerRendering(\n      withRoutes(serverRoutes),\n      withAppShell(AppShellComponent),\n    ),\n    // ... other providers ...\n  ]\n};\n```\n\n### Rendering modes\n\nThe server routing configuration lets you specify how each route in your application should render by setting a [`RenderMode`](api/ssr/RenderMode 'API reference'):\n\n| Rendering mode      | Description                                                                                                 |\n| ------------------- | ----------------------------------------------------------------------------------------------------------- |\n| **Server (SSR)**    | Renders the application on the server for each request, sending a fully populated HTML page to the browser. |\n| **Client (CSR)**    | Renders the application in the browser. This is the default Angular behavior.                               |\n| **Prerender (SSG)** | Prerenders the application at build time, generating static HTML files for each route.                      |\n\n#### Choosing a rendering mode\n\nEach rendering mode has different benefits and drawbacks. You can choose rendering modes based on the specific needs of your application.\n\n##### Client-side rendering\n\nClient-side rendering has the simplest development model, as you can write code that assumes it always runs in a web browser. This lets you use a wide range of client-side libraries that also assume they run in a browser.\n\nClient-side rendering generally has worse performance than other rendering modes, as it must download, parse, and execute your page's JavaScript before the user can see any rendered content. If your page fetches more data from the server as it renders, users also have to wait for those additional requests before they can view the complete content.\n\nIf your page is indexed by search crawlers, client-side rendering may negatively affect search engine optimization (SEO), as search crawlers have limits to how much JavaScript they execute when indexing a page.\n\nWhen client-side rendering, the server does not need to do any work to render a page beyond serving static JavaScript assets. You may consider this factor if server cost is a concern.\n\nApplications that support installable, offline experiences with [service workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) can rely on client-side rendering without needing to communicate with a server.\n\n##### Server-side rendering\n\nServer-side rendering offers faster page loads than client-side rendering. Instead of waiting for JavaScript to download and run, the server directly renders an HTML document upon receiving a request from the browser. The user experiences only the latency necessary for the server to fetch data and render the requested page. This mode also eliminates the need for additional network requests from the browser, as your code can fetch data during rendering on the server.\n\nServer-side rendering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document.\n\nServer-side rendering requires you to author code that does not strictly depend on browser APIs and limits your selection of JavaScript libraries that assume they run in a browser.\n\nWhen server-side rendering, your server runs Angular to produce an HTML response for every request which may increase server hosting costs.\n\n##### Build-time prerendering\n\nPrerendering offers faster page loads than both client-side rendering and server-side rendering. Because prerendering creates HTML documents at _build-time_, the server can directly respond to requests with the static HTML document without any additional work.\n\nPrerendering requires that all information necessary to render a page is available at _build-time_. This means that prerendered pages cannot include any data to the specific user loading the page. Prerendering is primarily useful for pages that are the same for all users of your application.\n\nBecause prerendering occurs at build-time, it may add significant time to your production builds. Using [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') to produce a large number of HTML documents may affect the total file size of your deployments, and thus lead to slower deployments.\n\nPrerendering generally has excellent search engine optimization (SEO), as search crawlers receive a fully rendered HTML document.\n\nPrerendering requires you to author code that does not strictly depend on browser APIs and limits your selection of JavaScript libraries that assume they run in a browser.\n\nPrerendering incurs extremely little overhead per server request, as your server responds with static HTML documents. Static files are also easily cached by Content Delivery Networks (CDNs), browsers, and intermediate caching layers for even faster subsequent page loads. Fully static sites can also be deployed solely through a CDN or static file server, eliminating the need to maintain a custom server runtime for your application. This enhances scalability by offloading work from an application web server, making it particularly beneficial for high-traffic applications.\n\nNOTE: When using Angular service worker, the first request is server-rendered, but all subsequent requests are handled by the service worker and rendered client-side.\n\n### Setting headers and status codes\n\nYou can set custom headers and status codes for individual server routes using the `headers` and `status` properties in the `ServerRoute` configuration.\n\n```typescript\n// app.routes.server.ts\nimport { RenderMode, ServerRoute } from '@angular/ssr';\n\nexport const serverRoutes: ServerRoute[] = [\n  {\n    path: 'profile',\n    renderMode: RenderMode.Server,\n    headers: {\n      'X-My-Custom-Header': 'some-value',\n    },\n    status: 201,\n  },\n  // ... other routes\n];\n```\n\n### Redirects\n\nAngular handles redirects specified by the [`redirectTo`](api/router/Route#redirectTo 'API reference') property in route configurations, differently on the server-side.\n\n**Server-Side Rendering (SSR)**\nRedirects are performed using standard HTTP redirects (e.g., 301, 302) within the server-side rendering process.\n\n**Prerendering (SSG)**\nRedirects are implemented as \"soft redirects\" using [`<meta http-equiv=\"refresh\">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#refresh) tags in the prerendered HTML.\n\n### Customizing build-time prerendering (SSG)\n\nWhen using [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference'), you can specify several configuration options to customize the prerendering and serving process.\n\n#### Parameterized routes\n\nFor each route with [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference'), you can specify a [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') function. This function lets you control which specific parameters produce separate prerendered documents.\n\nThe [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') function returns a `Promise` that resolves to an array of objects. Each object is a key-value map of route parameter name to value. For example, if you define a route like `posts/:id`, `getPrerenderParams ` could return the array `[{id: 123}, {id: 456}]`, and thus render separate documents for `posts/123` and `posts/456`.\n\nThe body of [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') can use Angular's [`inject`](api/core/inject 'API reference') function to inject dependencies and perform any work to determine which routes to prerender. This typically includes making requests to fetch data to construct the array of parameter values.\n\n```typescript\n// app.routes.server.ts\nimport { RenderMode, ServerRoute } from '@angular/ssr';\n\nexport const serverRoutes: ServerRoute[] = [\n  {\n    path: 'post/:id',\n    renderMode: RenderMode.Prerender,\n    async getPrerenderParams() {\n      const dataService = inject(PostService);\n      const ids = await dataService.getIds(); // Assuming this returns ['1', '2', '3']\n\n      return ids.map(id => ({ id })); // Transforms IDs into an array of objects for prerendering\n\n      // This will prerender the paths: `/post/1`, `/post/2` and `/post/3`\n    },\n  },\n];\n```\n\nBecause [`getPrerenderParams`](api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams 'API reference') exclusively applies to [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference'), this function always runs at _build-time_. `getPrerenderParams` must not rely on any browser-specific or server-specific APIs for data.\n\nIMPORTANT: When using [`inject`](api/core/inject 'API reference') inside `getPrerenderParams`, please remember that `inject` must be used synchronously. It cannot be invoked within asynchronous callbacks or following any `await` statements. For more information, refer to [`runInInjectionContext`](api/core/runInInjectionContext).\n\n#### Fallback strategies\n\nWhen using [`RenderMode.Prerender`](api/ssr/RenderMode#Prerender 'API reference') mode, you can specify a fallback strategy to handle requests for paths that haven't been prerendered.\n\nThe available fallback strategies are:\n\n- **Server:** Falls back to server-side rendering. This is the **default** behavior if no `fallback` property is specified.\n- **Client:** Falls back to client-side rendering.\n- **None:** No fallback. Angular will not handle requests for paths that are not prerendered.\n\n```typescript\n// app.routes.server.ts\nimport { RenderMode, PrerenderFallback, ServerRoute } from '@angular/ssr';\n\nexport const serverRoutes: ServerRoute[] = [\n  {\n    path: 'post/:id',\n    renderMode: RenderMode.Prerender,\n    fallback: PrerenderFallback.Client, // Fallback to CSR if not prerendered\n    async getPrerenderParams() {\n      // This function returns an array of objects representing prerendered posts at the paths:\n      // `/post/1`, `/post/2`, and `/post/3`.\n      // The path `/post/4` will utilize the fallback behavior if it's requested.\n      return [{ id: 1 }, { id: 2 }, { id: 3 }];\n    },\n  },\n];\n```\n\n## Accessing Request and Response via DI\n\nThe `@angular/core` package provides several tokens for interacting with the server-side rendering environment. These tokens give you access to crucial information and objects within your Angular application during SSR.\n\n- **[`REQUEST`](api/core/REQUEST 'API reference'):** Provides access to the current request object, which is of type [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) from the Web API. This allows you to access headers, cookies, and other request information.\n- **[`RESPONSE_INIT`](api/core/RESPONSE_INIT 'API reference'):** Provides access to the response initialization options, which is of type [`ResponseInit`](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#parameters) from the Web API. This allows you to set headers and the status code for the response dynamically. Use this token to set headers or status codes that need to be determined at runtime.\n- **[`REQUEST_CONTEXT`](api/core/REQUEST_CONTEXT 'API reference'):** Provides access to additional context related to the current request. This context can be passed as the second parameter of the [`handle`](api/ssr/AngularAppEngine#handle 'API reference') function. Typically, this is used to provide additional request-related information that is not part of the standard Web API.\n\n```angular-ts\nimport { inject, REQUEST } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  template: `<h1>My Component</h1>`,\n})\nexport class MyComponent {\n  constructor() {\n    const request = inject(REQUEST);\n    console.log(request?.url);\n  }\n}\n```\n\nIMPORTANT: The above tokens will be `null` in the following scenarios:\n- During the build processes.\n- When the application is rendered in the browser (CSR).\n- When performing static site generation (SSG).\n- During route extraction in development (at the time of the request).\n\n## Configuring a server\n\n### Node.js\n\nThe `@angular/ssr/node` extends `@angular/ssr` specifically for Node.js environments. It provides APIs that make it easier to implement server-side rendering within your Node.js application. For a complete list of functions and usage examples, refer to the [`@angular/ssr/node` API reference](api/ssr/node/AngularNodeAppEngine) API reference.\n\n```typescript\n// server.ts\nimport { AngularNodeAppEngine, createNodeRequestHandler, writeResponseToNodeResponse } from '@angular/ssr/node';\nimport express from 'express';\n\nconst app = express();\nconst angularApp = new AngularNodeAppEngine();\n\napp.use('*', (req, res, next) => {\n  angularApp\n    .handle(req)\n    .then(response => {\n      if (response) {\n        writeResponseToNodeResponse(response, res);\n      } else {\n        next(); // Pass control to the next middleware\n      }\n    })\n    .catch(next);\n});\n\n/**\n * The request handler used by the Angular CLI (dev-server and during build).\n */\nexport const reqHandler = createNodeRequestHandler(app);\n```\n\n### Non-Node.js\n\nThe `@angular/ssr` provides essential APIs for server-side rendering your Angular application on platforms other than Node.js. It leverages the standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects from the Web API, enabling you to integrate Angular SSR into various server environments. For detailed information and examples, refer to the [`@angular/ssr` API reference](api/ssr/AngularAppEngine).\n\n```typescript\n// server.ts\nimport { AngularAppEngine, createRequestHandler } from '@angular/ssr';\n\nconst angularApp = new AngularAppEngine();\n\n/**\n * This is a request handler used by the Angular CLI (dev-server and during build).\n */\nexport const reqHandler = createRequestHandler(async (req: Request) => {\n  const res: Response|null = await angularApp.render(req);\n\n  // ...\n});\n```\n\n## Generate a fully static application\n\nBy default, Angular prerenders your entire application and generates a server file for handling requests. This allows your app to serve pre-rendered content to users. However, if you prefer a fully static site without a server, you can opt out of this behavior by setting the `outputMode` to `static` in your `angular.json` configuration file.\n\nWhen `outputMode` is set to `static`, Angular generates pre-rendered HTML files for each route at build time, but it does not generate a server file or require a Node.js server to serve the app. This is useful for deploying to static hosting providers where a backend server is not needed.\n\nTo configure this, update your `angular.json` file as follows:\n\n```json\n{\n  \"projects\": {\n    \"your-app\": {\n      \"architect\": {\n        \"prerender\": {\n          \"options\": {\n            \"outputMode\": \"static\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## Caching data when using HttpClient\n\n[`HttpClient`](api/common/http/HttpClient) cached outgoing network requests when running on the server. This information is serialized and transferred to the browser as part of the initial HTML sent from the server. In the browser, `HttpClient` checks whether it has data in the cache and if so, reuses it instead of making a new HTTP request during initial application rendering. `HttpClient` stops using the cache once an application becomes [stable](api/core/ApplicationRef#isStable) while running in a browser.\n\nBy default, `HttpClient` caches all `HEAD` and `GET` requests which don't contain `Authorization` or `Proxy-Authorization` headers. You can override those settings by using [`withHttpTransferCacheOptions`](api/platform-browser/withHttpTransferCacheOptions) when providing hydration.\n\n```typescript\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideClientHydration(withHttpTransferCacheOptions({\n      includePostRequests: true\n    }))\n  ]\n});\n```\n\n## Authoring server-compatible components\n\nSome common browser APIs and capabilities might not be available on the server. Applications cannot make use of browser-specific global objects like `window`, `document`, `navigator`, or `location` as well as certain properties of `HTMLElement`.\n\nIn general, code which relies on browser-specific symbols should only be executed in the browser, not on the server. This can be enforced through the [`afterRender`](api/core/afterRender) and [`afterNextRender`](api/core/afterNextRender) lifecycle hooks. These are only executed on the browser and skipped on the server.\n\n```angular-ts\nimport { Component, ViewChild, afterNextRender } from '@angular/core';\n\n@Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterNextRender(() => {\n      // Safe to check `scrollHeight` because this will only run in the browser, not the server.\n      console.log('content height: ' + this.contentRef.nativeElement.scrollHeight);\n    });\n  }\n}\n```\n\n\n\n================================================\n",
    "endLine": 1847
  },
  {
    "id": 6,
    "file": "zoneless",
    "fullFileName": "adev/src/content/guide/zoneless.md",
    "startLine": 1851,
    "content": "# Angular without ZoneJS (Zoneless)\n\n## Why use Zoneless?\n\nThe main advantages to removing ZoneJS as a dependency are:\n\n- **Improved performance**: ZoneJS uses DOM events and async tasks as indicators of when application state _might_ have updated and subsequently triggers application synchronization to run change detection on the application's views. ZoneJS does not have any insight into whether application state actually changed and so this synchronization is triggered more frequently than necessary.\n- **Improved Core Web Vitals**: ZoneJS brings a fair amount of overhead, both in payload size and in startup time cost.\n- **Improved debugging experience**: ZoneJS makes debugging code more difficult. Stack traces are harder to understand with ZoneJS. It's also difficult to understand when code breaks as a result of being outside the Angular Zone.\n- **Better ecosystem compatibility**: ZoneJS works by patching browser APIs but does not automatically have patches for every new browser API. Some APIs cannot be patched effectively, such as `async`/`await`, and have to be downleveled to work with ZoneJS. Sometimes libraries in the ecosystem are also incompatible with the way ZoneJS patches the native APIs. Removing ZoneJS as a dependency ensures better long-term compatibility by removing a source of complexity, monkey patching, and ongoing maintenance.\n\n## Enabling Zoneless in an application\n\nThe API for enabling Zoneless is currently experimental. Neither the shape, nor the underlying behavior is stable and can change\nin patch versions. There are known feature gaps, including the lack of an ergonomic API which prevents the application from serializing too early with Server Side Rendering.\n\n```typescript\n// standalone bootstrap\nbootstrapApplication(MyApp, {providers: [\n  provideExperimentalZonelessChangeDetection(),\n]});\n\n// NgModule bootstrap\nplatformBrowser().bootstrapModule(AppModule);\n@NgModule({\n  providers: [provideExperimentalZonelessChangeDetection()]\n})\nexport class AppModule {}\n```\n\n## Removing ZoneJS\n\nZoneless applications should remove ZoneJS entirely from the build to reduce bundle size. ZoneJS is typically\nloaded via the `polyfills` option in `angular.json`, both in the `build` and `test` targets. Remove `zone.js`\nand `zone.js/testing` from both to remove it from the build. Projects which use an explicit `polyfills.ts` file\nshould remove `import 'zone.js';` and `import 'zone.js/testing';` from the file.\n\nAfter removing ZoneJS from the build, there is no longer a need for a `zone.js` dependency either and the\npackage can be removed entirely:\n\n```shell\nnpm uninstall zone.js\n```\n\n## Requirements for Zoneless compatibility\n\nAngular relies on notifications from core APIs in order to determine when to run change detection and on which views.\nThese notifications include:\n\n- `ChangeDetectorRef.markForCheck` (called automatically by `AsyncPipe`)\n- `ComponentRef.setInput`\n- Updating a signal that's read in a template\n- Bound host or template listeners callbacks\n- Attaching a view that was marked dirty by one of the above\n\n### `OnPush`-compatible components\n\nOne way to ensure that a component is using the correct notification mechanisms from above is to\nuse [ChangeDetectionStrategy.OnPush](/best-practices/skipping-subtrees#using-onpush).\n\nThe `OnPush` change detection strategy is not required, but it is a recommended step towards zoneless compatibility for application components. It is not always possible for library components to use `ChangeDetectionStrategy.OnPush`.\nWhen a library component is a host for user-components which might use `ChangeDetectionStrategy.Default`, it cannot use `OnPush` because that would prevent the child component from being refreshed if it is not `OnPush` compatible and relies on ZoneJS to trigger change detection. Components can use the `Default` strategy as long as they notify Angular when change detection needs to run (calling `markForCheck`, using signals, `AsyncPipe`, etc.).\nBeing a host for a user component means using an API such as `ViewContainerRef.createComponent` and not just hosting a portion of a template from a user component (i.e. content projection or a using a template ref input).\n\n### Remove `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable`, `NgZone.isStable`, or `NgZone.onStable`\n\nApplications and libraries need to remove uses of `NgZone.onMicrotaskEmpty`, `NgZone.onUnstable` and `NgZone.onStable`.\nThese observables will never emit when an Application enables zoneless change detection.\nSimilarly, `NgZone.isStable` will always be `true` and should not be used as a condition for code execution.\n\nThe `NgZone.onMicrotaskEmpty` and `NgZone.onStable` observables are most often used to wait for Angular to\ncomplete change detection before performing a task. Instead, these can be replaced by `afterNextRender`\nif they need to wait for a single change detection or `afterRender` if there is some condition that might span\nseveral change detection rounds. In other cases, these observables were used because they happened to be\nfamiliar and have similar timing to what was needed. More straightforward or direct DOM APIs can be used instead,\nsuch as `MutationObserver` when code needs to wait for certain DOM state (rather than waiting for it indirectly\nthrough Angular's render hooks).\n\n<docs-callout title=\"NgZone.run and NgZone.runOutsideAngular are compatible with Zoneless\">\n`NgZone.run` and `NgZone.runOutsideAngular` do not need to be removed in order for code to be compatible with\nZoneless applications. In fact, removing these calls can lead to performance regressions for libraries that\nare used in applications that still rely on ZoneJS.\n</docs-callout>\n\n### `PendingTasks` for Server Side Rendering (SSR)\n\nIf you are using SSR with Angular, you may know that it relies on ZoneJS to help determine when the application\nis \"stable\" and can be serialized. If there are asynchronous tasks that should prevent serialization, an application\nnot using ZoneJS must make Angular aware of these with the [PendingTasks](/api/core/PendingTasks) service. Serialization\nwill wait for the first moment that all pending tasks have been removed.\n\n\nThe two most straightforward uses of pending tasks are the `run` method:\n\n```typescript\nconst taskService = inject(PendingTasks);\ntaskService.run(async () => {\n  const someResult = await doSomeWorkThatNeedsToBeRendered();\n  this.someState.set(someResult);\n});\n```\n\nFor more complicated use-cases, you can manuall add and remove a pending tasks:\n\n```typescript\nconst taskService = inject(PendingTasks);\nconst taskCleanup = taskService.add();\ntry {\n  await doSomeWorkThatNeedsToBeRendered();\n} catch {\n  // handle error\n} finally {\n  taskCleanup();\n}\n```\n\nIn addition, the [pendingUntilEvent](/api/core/rxjs-interop/pendingUntilEvent#) helper in `rxjs-interop` ensures\nthe application remains unstable until the observable emits, complets, errors, or is unsubscribed.\n\n```typescript\nreadonly myObservableState = someObservable.pipe(pendingUntilEvent());\n```\n\nThe framework uses this service internally as well to prevent serialization until asynchronous tasks are complete. These include, but are not limited to,\nan ongoing Router navigation and an incomplete `HttpClient` request.\n\n## Testing and Debugging\n\n### Using Zoneless in `TestBed`\n\nThe zoneless provider function can also be used with `TestBed` to help\nensure the components under test are compatible with a Zoneless\nAngular application.\n\n```typescript\nTestBed.configureTestingModule({\n  providers: [provideExperimentalZonelessChangeDetection()]\n});\n\nconst fixture = TestBed.createComponent(MyComponent);\nawait fixture.whenStable();\n```\n\nTo ensure tests have the most similar behavior to production code,\navoid using `fixture.detectChanges()` when possible. This forces\nchange detection to run when Angular might otherwise have not\nscheduled change detection. Tests should ensure these notifications\nare happening and allow Angular to handle when to synchronize\nstate rather than manually forcing it to happen in the test.\n\nFor existing test suites, using `fixture.detectChanges()` is a common pattern\nand it is likely not worth the effort of converting these to\n`await fixture.whenStable()`. `TestBed` will still enforce that the\nfixture's component is `OnPush` compatible and throws `ExpressionChangedAfterItHasBeenCheckedError`\nif it finds that template values were updated without a\nchange notification (i.e. `fixture.componentInstance.someValue = 'newValue';`).\nIf the component is used in production, this issue should be addressed by updating\nthe component to use signals for state or call `ChangeDetectorRef.markForCheck()`.\nIf the component is only used as a test wrapper and never used in an application,\nit is acceptable to use `fixture.changeDetectorRef.markForCheck()`.\n\n### Debug-mode check to ensure updates are detected\n\nAngular also provides an additional tool to help verify that an application is making\nupdates to state in a zoneless-compatible way. `provideExperimentalCheckNoChangesForDebug`\ncan be used to periodically check to ensure that no bindings have been updated\nwithout a notification. Angular throws `ExpressionChangedAfterItHasBeenCheckedError`\nif there is an updated binding that would not have refreshed by the zoneless change\ndetection.\n\n\n\n================================================\nFILE: adev/src/content/guide/animations/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"animations\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 2040
  },
  {
    "id": 7,
    "file": "complex-sequences",
    "fullFileName": "adev/src/content/guide/animations/complex-sequences.md",
    "startLine": 2044,
    "content": "# Complex animation sequences\n\nSo far, we've learned simple animations of single HTML elements.\nAngular also lets you animate coordinated sequences, such as an entire grid or list of elements as they enter and leave a page.\nYou can choose to run multiple animations in parallel, or run discrete animations sequentially, one following another.\n\nThe functions that control complex animation sequences are:\n\n| Functions                         | Details |\n|:---                               |:---     |\n| `query()`                         | Finds one or more inner HTML elements. |\n| `stagger()`                       | Applies a cascading delay to animations for multiple elements. |\n| [`group()`](api/animations/group) | Runs multiple animation steps in parallel. |\n| `sequence()`                      | Runs animation steps one after another. |\n\n## The query() function\n\nMost complex animations rely on the `query()` function to find child elements and apply animations to them, basic examples of such are:\n\n| Examples                               | Details |\n|:---                                    |:---     |\n| `query()` followed by `animate()`      | Used to query simple HTML elements and directly apply animations to them.                                                                                                                            |\n| `query()` followed by `animateChild()` | Used to query child elements, which themselves have animations metadata applied to them and trigger such animation \\(which would be otherwise be blocked by the current/parent element's animation\\). |\n\nThe first argument of `query()` is a [css selector](https://developer.mozilla.org/docs/Web/CSS/CSS_Selectors) string which can also contain the following Angular-specific tokens:\n\n| Tokens                     | Details |\n|:---                        |:---     |\n| `:enter` <br /> `:leave`   | For entering/leaving elements.               |\n| `:animating`               | For elements currently animating.            |\n| `@*` <br /> `@triggerName` | For elements with any—or a specific—trigger. |\n| `:self`                    | The animating element itself.                |\n\n<docs-callout title=\"Entering and Leaving Elements\">\n\nNot all child elements are actually considered as entering/leaving; this can, at times, be counterintuitive and confusing. Please see the [query api docs](api/animations/query#entering-and-leaving-elements) for more information.\n\nYou can also see an illustration of this in the animations example \\(introduced in the animations [introduction section](guide/animations#about-this-guide)\\) under the Querying tab.\n\n</docs-callout>\n\n## Animate multiple elements using query() and stagger() functions\n\nAfter having queried child elements via `query()`, the `stagger()` function lets you define a timing gap between each queried item that is animated and thus animates elements with a delay between them.\n\nThe following example demonstrates how to use the `query()` and `stagger()` functions to animate a list \\(of heroes\\) adding each in sequence, with a slight delay, from top to bottom.\n\n* Use `query()` to look for an element entering the page that meets certain criteria\n* For each of these elements, use `style()` to set the same initial style for the element.\n    Make it transparent and use `transform` to move it out of position so that it can slide into place.\n\n* Use `stagger()` to delay each animation by 30 milliseconds\n* Animate each element on screen for 0.5 seconds using a custom-defined easing curve, simultaneously fading it in and un-transforming it\n\n<docs-code header=\"src/app/hero-list-page.component.ts\" path=\"adev/src/content/examples/animations/src/app/hero-list-page.component.ts\" visibleRegion=\"page-animations\"/>\n\n## Parallel animation using group() function\n\nYou've seen how to add a delay between each successive animation.\nBut you might also want to configure animations that happen in parallel.\nFor example, you might want to animate two CSS properties of the same element but use a different `easing` function for each one.\nFor this, you can use the animation [`group()`](api/animations/group) function.\n\nHELPFUL: The [`group()`](api/animations/group) function is used to group animation *steps*, rather than animated elements.\n\nThe following example uses [`group()`](api/animations/group)s on both `:enter` and `:leave` for two different timing configurations, thus applying two independent animations to the same element in parallel.\n\n<docs-code header=\"src/app/hero-list-groups.component.ts (excerpt)\" path=\"adev/src/content/examples/animations/src/app/hero-list-groups.component.ts\" visibleRegion=\"animationdef\"/>\n\n## Sequential vs. parallel animations\n\nComplex animations can have many things happening at once.\nBut what if you want to create an animation involving several animations happening one after the other? Earlier you used [`group()`](api/animations/group) to run multiple animations all at the same time, in parallel.\n\nA second function called `sequence()` lets you run those same animations one after the other.\nWithin `sequence()`, the animation steps consist of either `style()` or `animate()` function calls.\n\n* Use `style()` to apply the provided styling data immediately.\n* Use `animate()` to apply styling data over a given time interval.\n\n## Filter animation example\n\nTake a look at another animation on the example page.\nUnder the Filter/Stagger tab, enter some text into the **Search Heroes** text box, such as `Magnet` or `tornado`.\n\nThe filter works in real time as you type.\nElements leave the page as you type each new letter and the filter gets progressively stricter.\nThe heroes list gradually re-enters the page as you delete each letter in the filter box.\n\nThe HTML template contains a trigger called `filterAnimation`.\n\n<docs-code header=\"src/app/hero-list-page.component.html\" path=\"adev/src/content/examples/animations/src/app/hero-list-page.component.html\" visibleRegion=\"filter-animations\" language=\"angular-html\"/>\n\nThe `filterAnimation` in the component's decorator contains three transitions.\n\n<docs-code header=\"src/app/hero-list-page.component.ts\" path=\"adev/src/content/examples/animations/src/app/hero-list-page.component.ts\" visibleRegion=\"filter-animations\"/>\n\nThe code in this example performs the following tasks:\n\n* Skips animations when the user first opens or navigates to this page \\(the filter animation narrows what is already there, so it only works on elements that already exist in the DOM\\)\n* Filters heroes based on the search input's value\n\nFor each change:\n\n* Hides an element leaving the DOM by setting its opacity and width to 0\n* Animates an element entering the DOM over 300 milliseconds.\n    During the animation, the element assumes its default width and opacity.\n\n* If there are multiple elements entering or leaving the DOM, staggers each animation starting at the top of the page, with a 50-millisecond delay between each element\n\n## Animating the items of a reordering list\n\nAlthough Angular animates correctly `*ngFor` list items out of the box, it will not be able to do so if their ordering changes.\nThis is because it will lose track of which element is which, resulting in broken animations.\nThe only way to help Angular keep track of such elements is by assigning a `TrackByFunction` to the `NgForOf` directive.\nThis makes sure that Angular always knows which element is which, thus allowing it to apply the correct animations to the correct elements all the time.\n\nIMPORTANT: If you need to animate the items of an `*ngFor` list and there is a possibility that the order of such items will change during runtime, always use a `TrackByFunction`.\n\n## Animations and Component View Encapsulation\n\nAngular animations are based on the components DOM structure and do not directly take [View Encapsulation](guide/components/styling#style-scoping) into account, this means that components using `ViewEncapsulation.Emulated` behave exactly as if they were using `ViewEncapsulation.None` (`ViewEncapsulation.ShadowDom` behaves differently as we'll discuss shortly).\n\nFor example if the `query()` function (which you'll see more of in the rest of the Animations guide) were to be applied at the top of a tree of components using the emulated view encapsulation, such query would be able to identify (and thus animate) DOM elements on any depth of the tree.\n\nOn the other hand the `ViewEncapsulation.ShadowDom` changes the component's DOM structure by \"hiding\" DOM elements inside [`ShadowRoot`](https://developer.mozilla.org/docs/Web/API/ShadowRoot) elements. Such DOM manipulations do prevent some of the animations implementation to work properly since it relies on simple DOM structures and doesn't take `ShadowRoot` elements into account. Therefore it is advised to avoid applying animations to views incorporating components using the ShadowDom view encapsulation.\n\n## Animation sequence summary\n\nAngular functions for animating multiple elements start with `query()` to find inner elements; for example, gathering all images within a `<div>`.\nThe remaining functions, `stagger()`, [`group()`](api/animations/group), and `sequence()`, apply cascades or let you control how multiple animation steps are applied.\n\n## More on Angular animations\n\nYou might also be interested in the following:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/animations\" title=\"Introduction to Angular animations\"/>\n  <docs-pill href=\"guide/animations/transition-and-triggers\" title=\"Transition and triggers\"/>\n  <docs-pill href=\"guide/animations/reusable-animations\" title=\"Reusable animations\"/>\n  <docs-pill href=\"guide/animations/route-animations\" title=\"Route transition animations\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 2188
  },
  {
    "id": 8,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/animations/overview.md",
    "startLine": 2192,
    "content": "# Introduction to Angular animations\n\nAnimation provides the illusion of motion: HTML elements change styling over time.\nWell-designed animations can make your application more fun and straightforward to use, but they aren't just cosmetic.\nAnimations can improve your application and user experience in a number of ways:\n\n* Without animations, web page transitions can seem abrupt and jarring\n* Motion greatly enhances the user experience, so animations give users a chance to detect the application's response to their actions\n* Good animations intuitively call the user's attention to where it is needed\n\nTypically, animations involve multiple style *transformations* over time.\nAn HTML element can move, change color, grow or shrink, fade, or slide off the page.\nThese changes can occur simultaneously or sequentially. You can control the timing of each transformation.\n\nAngular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable.\nThis includes positions, sizes, transforms, colors, borders, and more.\nThe W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1) page.\n\n## About this guide\n\nThis guide covers the basic Angular animation features to get you started on adding Angular animations to your project.\n\n## Getting started\n\nThe main Angular modules for animations are `@angular/animations` and `@angular/platform-browser`.\n\nTo get started with adding Angular animations to your project, import the animation-specific modules along with standard Angular functionality.\n\n<docs-workflow>\n<docs-step title=\"Enabling the animations module\">\nImport `provideAnimationsAsync` from `@angular/platform-browser/animations/async` and add it to the providers list in the `bootstrapApplication` function call.\n\n<docs-code header=\"Enabling Animations\" language=\"ts\" linenums>\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideAnimationsAsync(),\n  ]\n});\n</docs-code>\n\n<docs-callout important title=\"If you need immediate animations in your application\">\n  If you need to have an animation happen immediately when your application is loaded,\n  you will want to switch to the eagerly loaded animations module. Import `provideAnimations`\n  from `@angular/platform-browser/animations` instead, and use `provideAnimations` **in place of**\n  `provideAnimationsAsync` in the `bootstrapApplication` function call.\n</docs-callout>\n\nFor `NgModule` based applications import `BrowserAnimationsModule`, which introduces the animation capabilities into your Angular root application module.\n\n<docs-code header=\"src/app/app.module.ts\" path=\"adev/src/content/examples/animations/src/app/app.module.1.ts\"/>\n</docs-step>\n<docs-step title=\"Importing animation functions into component files\">\nIf you plan to use specific animation functions in component files, import those functions from `@angular/animations`.\n\n<docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/animations/src/app/app.component.ts\" visibleRegion=\"imports\"/>\n\nSee all [available animation functions](guide/animations#animations-api-summary) at the end of this guide.\n\n</docs-step>\n<docs-step title=\"Adding the animation metadata property\">\nIn the component file, add a metadata property called `animations:` within the `@Component()` decorator.\nYou put the trigger that defines an animation within the `animations` metadata property.\n\n<docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/animations/src/app/app.component.ts\" visibleRegion=\"decorator\"/>\n</docs-step>\n</docs-workflow>\n\n## Animating a transition\n\nLet's animate a transition that changes a single HTML element from one state to another.\nFor example, you can specify that a button displays either **Open** or **Closed** based on the user's last action.\nWhen the button is in the `open` state, it's visible and yellow.\nWhen it's the `closed` state, it's translucent and blue.\n\nIn HTML, these attributes are set using ordinary CSS styles such as color and opacity.\nIn Angular, use the `style()` function to specify a set of CSS styles for use with animations.\nCollect a set of styles in an animation state, and give the state a name, such as `open` or `closed`.\n\nHELPFUL: Let's create a new `open-close` component to animate with simple transitions.\n\nRun the following command in terminal to generate the component:\n\n<docs-code language=\"shell\">\n\nng g component open-close\n\n</docs-code>\n\nThis will create the component at `src/app/open-close.component.ts`.\n\n### Animation state and styles\n\nUse Angular's [`state()`](api/animations/state) function to define different states to call at the end of each transition.\nThis function takes two arguments:\nA unique name like `open` or `closed` and a `style()` function.\n\nUse the `style()` function to define a set of styles to associate with a given state name.\nYou must use *camelCase* for style attributes that contain dashes, such as `backgroundColor` or wrap them in quotes, such as `'background-color'`.\n\nLet's see how Angular's [`state()`](api/animations/state) function works with the `style⁣­(⁠)` function to set CSS style attributes.\nIn this code snippet, multiple style attributes are set at the same time for the state.\nIn the `open` state, the button has a height of 200 pixels, an opacity of 1, and a yellow background color.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"state1\"/>\n\nIn the following `closed` state, the button has a height of 100 pixels, an opacity of 0.8, and a background color of blue.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"state2\"/>\n\n### Transitions and timing\n\nIn Angular, you can set multiple styles without any animation.\nHowever, without further refinement, the button instantly transforms with no fade, no shrinkage, or other visible indicator that a change is occurring.\n\nTo make the change less abrupt, you need to define an animation *transition* to specify the changes that occur between one state and another over a period of time.\nThe `transition()` function accepts two arguments:\nThe first argument accepts an expression that defines the direction between two transition states, and the second argument accepts one or a series of `animate()` steps.\n\nUse the `animate()` function to define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place.\nUse the `animate()` function to define the `keyframes()` function for multi-step animations.\nThese definitions are placed in the second argument of the `animate()` function.\n\n#### Animation metadata: duration, delay, and easing\n\nThe `animate()` function \\(second argument of the transition function\\) accepts the `timings` and `styles` input parameters.\n\nThe `timings` parameter takes either a number or a string defined in three parts.\n\n<docs-code language=\"typescript\">\n\nanimate (duration)\n\n</docs-code>\n\nor\n\n<docs-code language=\"typescript\">\n\nanimate ('duration delay easing')\n\n</docs-code>\n\nThe first part, `duration`, is required.\nThe duration can be expressed in milliseconds as a number without quotes, or in seconds with quotes and a time specifier.\nFor example, a duration of a tenth of a second can be expressed as follows:\n\n* As a plain number, in milliseconds:\n    `100`\n\n* In a string, as milliseconds:\n    `'100ms'`\n\n* In a string, as seconds:\n    `'0.1s'`\n\nThe second argument, `delay`, has the same syntax as `duration`.\nFor example:\n\n* Wait for 100ms and then run for 200ms: `'0.2s 100ms'`\n\nThe third argument, `easing`, controls how the animation [accelerates and decelerates](https://easings.net) during its runtime.\nFor example, `ease-in` causes the animation to begin slowly, and to pick up speed as it progresses.\n\n* Wait for 100ms, run for 200ms.\n    Use a deceleration curve to start out fast and slowly decelerate to a resting point:\n    `'0.2s 100ms ease-out'`\n\n* Run for 200ms, with no delay.\n    Use a standard curve to start slow, accelerate in the middle, and then decelerate slowly at the end:\n    `'0.2s ease-in-out'`\n\n* Start immediately, run for 200ms.\n    Use an acceleration curve to start slow and end at full velocity:\n    `'0.2s ease-in'`\n\nHELPFUL: See the Material Design website's topic on [Natural easing curves](https://material.io/design/motion/speed.html#easing) for general information on easing curves.\n\nThis example provides a state transition from `open` to `closed` with a 1-second transition between states.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"transition1\"/>\n\nIn the preceding code snippet, the `=>` operator indicates unidirectional transitions, and `<=>` is bidirectional.\nWithin the transition, `animate()` specifies how long the transition takes.\nIn this case, the state change from `open` to `closed` takes 1 second, expressed here as `1s`.\n\nThis example adds a state transition from the `closed` state to the `open` state with a 0.5-second transition animation arc.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"transition2\"/>\n\nHELPFUL: Some additional notes on using styles within [`state`](api/animations/state) and `transition` functions.\n\n* Use [`state()`](api/animations/state) to define styles that are applied at the end of each transition, they persist after the animation completes\n* Use `transition()` to define intermediate styles, which create the illusion of motion during the animation\n* When animations are disabled, `transition()` styles can be skipped, but [`state()`](api/animations/state) styles can't\n* Include multiple state pairs within the same `transition()` argument:\n\n    <docs-code language=\"typescript\">\n\n    transition( 'on => off, off => void' )\n\n    </docs-code>\n\n### Triggering the animation\n\nAn animation requires a *trigger*, so that it knows when to start.\nThe `trigger()` function collects the states and transitions, and gives the animation a name, so that you can attach it to the triggering element in the HTML template.\n\nThe `trigger()` function describes the property name to watch for changes.\nWhen a change occurs, the trigger initiates the actions included in its definition.\nThese actions can be transitions or other functions, as we'll see later on.\n\nIn this example, we'll name the trigger `openClose`, and attach it to the `button` element.\nThe trigger describes the open and closed states, and the timings for the two transitions.\n\nHELPFUL: Within each `trigger()` function call, an element can only be in one state at any given time.\nHowever, it's possible for multiple triggers to be active at once.\n\n### Defining animations and attaching them to the HTML template\n\nAnimations are defined in the metadata of the component that controls the HTML element to be animated.\nPut the code that defines your animations under the `animations:` property within the `@Component()` decorator.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"component\"/>\n\nWhen you've defined an animation trigger for a component, attach it to an element in that component's template by wrapping the trigger name in brackets and preceding it with an `@` symbol.\nThen, you can bind the trigger to a template expression using standard Angular property binding syntax as shown below, where `triggerName` is the name of the trigger, and `expression` evaluates to a defined animation state.\n\n<docs-code language=\"typescript\">\n\n<div [@triggerName]=\"expression\">…</div>;\n\n</docs-code>\n\nThe animation is executed or triggered when the expression value changes to a new state.\n\nThe following code snippet binds the trigger to the value of the `isOpen` property.\n\n<docs-code header=\"src/app/open-close.component.html\" path=\"adev/src/content/examples/animations/src/app/open-close.component.1.html\" visibleRegion=\"trigger\"/>\n\nIn this example, when the `isOpen` expression evaluates to a defined state of `open` or `closed`, it notifies the trigger `openClose` of a state change.\nThen it's up to the `openClose` code to handle the state change and kick off a state change animation.\n\nFor elements entering or leaving a page \\(inserted or removed from the DOM\\), you can make the animations conditional.\nFor example, use `*ngIf` with the animation trigger in the HTML template.\n\nHELPFUL: In the component file, set the trigger that defines the animations as the value of the `animations:` property in the `@Component()` decorator.\n\nIn the HTML template file, use the trigger name to attach the defined animations to the HTML element to be animated.\n\n### Code review\n\nHere are the code files discussed in the transition example.\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"component\"/>\n    <docs-code header=\"src/app/open-close.component.html\" path=\"adev/src/content/examples/animations/src/app/open-close.component.1.html\" visibleRegion=\"trigger\"/>\n    <docs-code header=\"src/app/open-close.component.css\" path=\"adev/src/content/examples/animations/src/app/open-close.component.css\"/>\n</docs-code-multifile>\n\n### Summary\n\nYou learned to add animation to a transition between two states, using `style()` and [`state()`](api/animations/state) along with `animate()` for the timing.\n\nLearn about more advanced features in Angular animations under the Animation section, beginning with advanced techniques in [transition and triggers](guide/animations/transition-and-triggers).\n\n## Animations API summary\n\nThe functional API provided by the `@angular/animations` module provides a domain-specific language \\(DSL\\) for creating and controlling animations in Angular applications.\nSee the [API reference](api#animations) for a complete listing and syntax details of the core functions and related data structures.\n\n| Function name                     | What it does                                                                                                                                                                                                |\n|:---                               |:---                                                                                                                                                                                                         |\n| `trigger()`                       | Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to `triggerName`. Use the first argument to declare a unique trigger name. Uses array syntax. |\n| `style()`                         | Defines one or more CSS styles to use in animations. Controls the visual appearance of HTML elements during animations. Uses object syntax.                                                                 |\n| [`state()`](api/animations/state) | Creates a named set of CSS styles that should be applied on successful transition to a given state. The state can then be referenced by name within other animation functions.                              |\n| `animate()`                       | Specifies the timing information for a transition. Optional values for `delay` and `easing`. Can contain `style()` calls within.                                                                            |\n| `transition()`                    | Defines the animation sequence between two named states. Uses array syntax.                                                                                                                                 |\n| `keyframes()`                     | Allows a sequential change between styles within a specified time interval. Use within `animate()`. Can include multiple `style()` calls within each `keyframe()`. Uses array syntax.                       |\n| [`group()`](api/animations/group) | Specifies a group of animation steps \\(*inner animations*\\) to be run in parallel. Animation continues only after all inner animation steps have completed. Used within `sequence()` or `transition()`.     |\n| `query()`                         | Finds one or more inner HTML elements within the current element.                                                                                                                                           |\n| `sequence()`                      | Specifies a list of animation steps that are run sequentially, one by one.                                                                                                                                  |\n| `stagger()`                       | Staggers the starting time for animations for multiple elements.                                                                                                                                            |\n| `animation()`                     | Produces a reusable animation that can be invoked from elsewhere. Used together with `useAnimation()`.                                                                                                      |\n| `useAnimation()`                  | Activates a reusable animation. Used with `animation()`.                                                                                                                                                    |\n| `animateChild()`                  | Allows animations on child components to be run within the same timeframe as the parent.                                                                                                                    |\n\n</table>\n\n## More on Angular animations\n\nHELPFUL: Check out this [presentation](https://www.youtube.com/watch?v=rnTK9meY5us), shown at the AngularConnect conference in November 2017, and the accompanying [source code](https://github.com/matsko/animationsftw.in).\n\nYou might also be interested in the following:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/animations/transition-and-triggers\" title=\"Transition and triggers\"/>\n  <docs-pill href=\"guide/animations/complex-sequences\" title=\"Complex animation sequences\"/>\n  <docs-pill href=\"guide/animations/reusable-animations\" title=\"Reusable animations\"/>\n  <docs-pill href=\"guide/animations/route-animations\" title=\"Route transition animations\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 2494
  },
  {
    "id": 9,
    "file": "reusable-animations",
    "fullFileName": "adev/src/content/guide/animations/reusable-animations.md",
    "startLine": 2498,
    "content": "# Reusable animations\n\nThis topic provides some examples of how to create reusable animations.\n\n## Create reusable animations\n\nTo create a reusable animation, use the [`animation()`](api/animations/animation) function to define an animation in a separate `.ts` file and declare this animation definition as a `const` export variable.\nYou can then import and reuse this animation in any of your application components using the [`useAnimation()`](api/animations/useAnimation) function.\n\n<docs-code header=\"src/app/animations.ts\" path=\"adev/src/content/examples/animations/src/app/animations.1.ts\" visibleRegion=\"animation-const\"/>\n\nIn the preceding code snippet, `transitionAnimation` is made reusable by declaring it as an export variable.\n\nHELPFUL: The `height`, `opacity`, `backgroundColor`, and `time` inputs are replaced during runtime.\n\nYou can also export a part of an animation.\nFor example, the following snippet exports the animation `trigger`.\n\n<docs-code header=\"src/app/animations.1.ts\" path=\"adev/src/content/examples/animations/src/app/animations.1.ts\" visibleRegion=\"trigger-const\"/>\n\nFrom this point, you can import reusable animation variables in your component class.\nFor example, the following code snippet imports the `transitionAnimation` variable and uses it via the `useAnimation()` function.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.3.ts\" visibleRegion=\"reusable\"/>\n\n## More on Angular animations\n\nYou might also be interested in the following:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/animations\" title=\"Introduction to Angular animations\"/>\n  <docs-pill href=\"guide/animations/transition-and-triggers\" title=\"Transition and triggers\"/>\n  <docs-pill href=\"guide/animations/complex-sequences\" title=\"Complex animation sequences\"/>\n  <docs-pill href=\"guide/animations/route-animations\" title=\"Route transition animations\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 2535
  },
  {
    "id": 10,
    "file": "route-animations",
    "fullFileName": "adev/src/content/guide/animations/route-animations.md",
    "startLine": 2539,
    "content": "# Route transition animations\n\nWhen a user navigates from one route to another, the Angular Router maps the URL path to the relevant component and displays its view. Animating this route transition can greatly enhance the user experience. The Router has support for the View Transitions API when navigating between routes in Chrome/Chromium browsers.\n\nHELPFUL: The Router's native View Transitions integration is currently in [developer preview](/reference/releases#developer-preview). Native View Transitions are also a relatively new feature so there may be limited support in some browsers.\n\n## How View Transitions work\n\nThe native browser method that’s used for view transitions is `document.startViewTransition`. When `startViewTransition()` is called, the browser captures the current state of the page which includes taking a screenshot. The method takes a callback that updates the DOM and this function can be asynchronous. The new state is captured and the transition begins in the next animation frame when the promise returned by the callback resolves.\n\nHere’s an example of the startViewTransition api:\n\n```ts\ndocument.startViewTransition(async () => {\n  await updateTheDOMSomehow();\n});\n```\n\nIf you’re curious to read more about the details of the browser API, the [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions) is an invaluable resource.\n\n## How the Router uses view transitions\n\nSeveral things happen after navigation starts in the router: route matching, loading lazy routes and components, executing guards and resolvers to name a few. Once these have completed successfully, the new routes are ready to be activated. This route activation is the DOM update that we want to perform as part of the view transition.\n\nWhen the view transition feature is enabled, navigation “pauses” and a call is made to the browser’s `startViewTransition` method. Once the `startViewTransition` callback executes (this happens asynchronously, as outlined in the spec here), navigation “resumes”. The remaining steps for the router navigation include updating the browser URL and activating or deactivating the matched routes (the DOM update).\n\nFinally, the callback passed to `startViewTransition` returns a Promise that resolves once Angular has finished rendering. As described above, this indicates to the browser that the new DOM state should be captured and the transition should begin.\n\nView transitions are a [progressive enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement). If the browser does not support the API, the Router will perform the DOM updates without calling `startViewTransition` and the navigation will not be animated.\n\n## Enabling View Transitions in the Router\n\nTo enable this feature, simply add `withViewTransitions` to the `provideRouter` or set `enableViewTransitions: true` in `RouterModule.forRoot`:\n\n```ts\n// Standalone bootstrap\nbootstrapApplication(MyApp, {providers: [\n  provideRouter(ROUTES, withViewTransitions()),\n]});\n\n// NgModule bootstrap\n@NgModule({\n  imports: [RouterModule.forRoot(routes, {enableViewTransitions: true})]\n})\nexport class AppRouting {}\n```\n\n[Try the “count” example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-2dnvtm?file=src%2Fmain.ts)\n\nThis example uses the counter application from the Chrome explainer and replaces the direct call to startViewTransition when the counter increments with a router navigation.\n\n## Using CSS to customize transitions\n\nView transitions can be customized with CSS. We can also instruct the browser to create separate elements for the transition by setting a view-transition-name. We can expand the first example by adding view-transition-name: count to the .count style in the Counter component. Then, in the global styles, we can define a custom animation for this view transition:\n\n```css\n/* Custom transition */\n@keyframes rotate-out {\n to {\n   transform: rotate(90deg);\n }\n}\n@keyframes rotate-in {\n from {\n   transform: rotate(-90deg);\n }\n}\n::view-transition-old(count),\n::view-transition-new(count) {\n animation-duration: 200ms;\n animation-name: -ua-view-transition-fade-in, rotate-in;\n}\n::view-transition-old(count) {\n animation-name: -ua-view-transition-fade-out, rotate-out;\n}\n```\n\nIt is important that the view transition animations are defined in a global style file. They cannot be defined in the component styles because the default view encapsulation will scope the styles to the component.\n\n[Try the updated “count” example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-fwn4i7?file=src%2Fmain.ts)\n\n## Controlling transitions with onViewTransitionCreated\n\nThe `withViewTransitions` router feature can also be called with an options object that includes an `onViewTransitionCreated` callback. This callback is run in an [injection context](/guide/di/dependency-injection-context#run-within-an-injection-context) and receives a [ViewTransitionInfo](/api/router/ViewTransitionInfo) object that includes the `ViewTransition` returned from `startViewTransition`, as well as the `ActivatedRouteSnapshot` that the navigation is transitioning from and the new one that it is transitioning to.\n\nThis callback can be used for any number of customizations. For example, you might want to skip transitions under certain conditions. We use this on the new angular.dev docs site:\n\n```ts\nwithViewTransitions({\n onViewTransitionCreated: ({transition}) => {\n   const router = inject(Router);\n   const targetUrl = router.getCurrentNavigation()!.finalUrl!;\n   // Skip the transition if the only thing \n   // changing is the fragment and queryParams\n   const config = { \n     paths: 'exact', \n     matrixParams: 'exact',\n     fragment: 'ignored',\n     queryParams: 'ignored',\n   };\n\n   if (router.isActive(targetUrl, config)) {\n     transition.skipTransition();\n   }\n },\n}),\n```\n\nIn this code snippet, we create a `UrlTree` from the `ActivatedRouteSnapshot` the navigation is going to. We then check with the Router to see if this `UrlTree` is already active, ignoring any differences in the fragment or query parameters. If it is already active, we call skipTransition which will skip the animation portion of the view transition. This is the case when clicking on an anchor link that will only scroll to another location in the same document.\n\n## Examples from the Chrome explainer adapted to Angular\n\nWe’ve recreated some of the great examples from the Chrome Team in Angular for you to explore.\n\n### Transitioning elements don’t need to be the same DOM element\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#transitioning_elements_dont_need_to_be_the_same_dom_element)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-dh8npr?file=src%2Fmain.ts)\n\n### Custom entry and exit animations\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#custom_entry_and_exit_transitions)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-8kly3o)\n\n### Async DOM updates and waiting for content\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#async_dom_updates_and_waiting_for_content)\n\n> During this time, the page is frozen, so delays here should be kept to a minimum…in some cases it’s better to avoid the delay altogether, and use the content you already have.\n\nThe view transition feature in the Angular router does not provide a way to delay the animation. For the moment, our stance is that it’s always better to use the content you have rather than making the page non-interactive for any additional amount of time.\n\n### Handle multiple view transition styles with view transition types\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#view-transition-types)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-vxzcam)\n\n### Handle multiple view transition styles with a class name on the view transition root (deprecated)\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#changing-on-navigation-type)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-nmnzzg?file=src%2Fmain.ts)\n\n### Transitioning without freezing other animations\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#transitioning-without-freezing)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-76kgww)\n\n### Animating with Javascript\n\n* [Chrome Explainer](https://developer.chrome.com/docs/web-platform/view-transitions/same-document#animating-with-javascript)\n* [Angular Example on StackBlitz](https://stackblitz.com/edit/stackblitz-starters-cklnkm)\n\n## Native View Transitions Alternative\n\nAnimating the transition between routes can also be done with the `@angular/animations` package. \nThe animation [triggers and transitions](/guide/animations/transition-and-triggers)\ncan be derived from the router state, such as the current URL or `ActivatedRoute`.\n\n\n\n================================================\n",
    "endLine": 2698
  },
  {
    "id": 11,
    "file": "transition-and-triggers",
    "fullFileName": "adev/src/content/guide/animations/transition-and-triggers.md",
    "startLine": 2702,
    "content": "# Animation transitions and triggers\n\nThis guide goes into depth on special transition states such as the `*` wildcard and `void`. It shows how these special states are used for elements entering and leaving a view.\nThis section also explores multiple animation triggers, animation callbacks, and sequence-based animation using keyframes.\n\n## Predefined states and wildcard matching\n\nIn Angular, transition states can be defined explicitly through the [`state()`](api/animations/state) function, or using the predefined `*` wildcard and `void` states.\n\n### Wildcard state\n\nAn asterisk `*` or *wildcard* matches any animation state.\nThis is useful for defining transitions that apply regardless of the HTML element's start or end state.\n\nFor example, a transition of `open => *` applies when the element's state changes from open to anything else.\n\n<img alt=\"wildcard state expressions\" src=\"assets/images/guide/animations/wildcard-state-500.png\">\n\nThe following is another code sample using the wildcard state together with the previous example using the `open` and `closed` states.\nInstead of defining each state-to-state transition pair, any transition to `closed` takes 1 second, and any transition to `open` takes 0.5 seconds.\n\nThis allows the addition of new states without having to include separate transitions for each one.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"trigger-wildcard1\"/>\n\nUse a double arrow syntax to specify state-to-state transitions in both directions.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"trigger-wildcard2\"/>\n\n### Use wildcard state with multiple transition states\n\nIn the two-state button example, the wildcard isn't that useful because there are only two possible states, `open` and `closed`.\nIn general, use wildcard states when an element has multiple potential states that it can change to.\nIf the button can change from `open` to either `closed` or something like `inProgress`, using a wildcard state could reduce the amount of coding needed.\n\n<img alt=\"wildcard state with 3 states\" src=\"assets/images/guide/animations/wildcard-3-states.png\">\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"trigger-transition\"/>\n\nThe `* => *` transition applies when any change between two states takes place.\n\nTransitions are matched in the order in which they are defined.\nThus, you can apply other transitions on top of the `* => *` transition.\nFor example, define style changes or animations that would apply just to `open => closed`, then use `* => *` as a fallback for state pairings that aren't otherwise called out.\n\nTo do this, list the more specific transitions *before* `* => *`.\n\n### Use wildcards with styles\n\nUse the wildcard `*` with a style to tell the animation to use whatever the current style value is, and animate with that.\nWildcard is a fallback value that's used if the state being animated isn't declared within the trigger.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"transition4\"/>\n\n### Void state\n\nUse the `void` state to configure transitions for an element that is entering or leaving a page.\nSee [Animating entering and leaving a view](guide/animations/transition-and-triggers#aliases-enter-and-leave).\n\n### Combine wildcard and void states\n\nCombine wildcard and void states in a transition to trigger animations that enter and leave the page:\n\n* A transition of `* => void` applies when the element leaves a view, regardless of what state it was in before it left\n* A transition of `void => *` applies when the element enters a view, regardless of what state it assumes when entering\n* The wildcard state `*` matches to *any* state, including `void`\n\n## Animate entering and leaving a view\n\nThis section shows how to animate elements entering or leaving a page.\n\nAdd a new behavior:\n\n* When you add a hero to the list of heroes, it appears to fly onto the page from the left\n* When you remove a hero from the list, it appears to fly out to the right\n\n<docs-code header=\"src/app/hero-list-enter-leave.component.ts\" path=\"adev/src/content/examples/animations/src/app/hero-list-enter-leave.component.ts\" visibleRegion=\"animationdef\"/>\n\nIn the preceding code, you applied the `void` state when the HTML element isn't attached to a view.\n\n## Aliases :enter and :leave\n\n`:enter` and `:leave` are aliases for the `void => *` and `* => void` transitions.\nThese aliases are used by several animation functions.\n\n<docs-code hideCopy language=\"typescript\">\n\ntransition ( ':enter', [ … ] );  // alias for void => *\ntransition ( ':leave', [ … ] );  // alias for * => void\n\n</docs-code>\n\nIt's harder to target an element that is entering a view because it isn't in the DOM yet.\nUse the aliases `:enter` and `:leave` to target HTML elements that are inserted or removed from a view.\n\n### Use `*ngIf` and `*ngFor` with :enter and :leave\n\nThe `:enter` transition runs when any `*ngIf` or `*ngFor` views are placed on the page, and `:leave` runs when those views are removed from the page.\n\nIMPORTANT: Entering/leaving behaviors can sometime be confusing.\nAs a rule of thumb consider that any element being added to the DOM by Angular passes via the `:enter` transition. Only elements being directly removed from the DOM by Angular pass via the `:leave` transition. For example, an element's view is removed from the DOM because its parent is being removed from the DOM.\n\nThis example has a special trigger for the enter and leave animation called `myInsertRemoveTrigger`.\nThe HTML template contains the following code.\n\n<docs-code header=\"src/app/insert-remove.component.html\" path=\"adev/src/content/examples/animations/src/app/insert-remove.component.html\" visibleRegion=\"insert-remove\"/>\n\nIn the component file, the `:enter` transition sets an initial opacity of 0. It then animates it to change that opacity to 1 as the element is inserted into the view.\n\n<docs-code header=\"src/app/insert-remove.component.ts\" path=\"adev/src/content/examples/animations/src/app/insert-remove.component.ts\" visibleRegion=\"enter-leave-trigger\"/>\n\nNote that this example doesn't need to use [`state()`](api/animations/state).\n\n## Transition :increment and :decrement\n\nThe `transition()` function takes other selector values, `:increment` and `:decrement`.\nUse these to kick off a transition when a numeric value has increased or decreased in value.\n\nHELPFUL: The following example uses `query()` and `stagger()` methods.\nFor more information on these methods, see the [complex sequences](guide/animations/complex-sequences) page.\n\n<docs-code header=\"src/app/hero-list-page.component.ts\" path=\"adev/src/content/examples/animations/src/app/hero-list-page.component.ts\" visibleRegion=\"increment\"/>\n\n## Boolean values in transitions\n\nIf a trigger contains a Boolean value as a binding value, then this value can be matched using a `transition()` expression that compares `true` and `false`, or `1` and `0`.\n\n<docs-code header=\"src/app/open-close.component.html\" path=\"adev/src/content/examples/animations/src/app/open-close.component.2.html\" visibleRegion=\"trigger-boolean\"/>\n\nIn the code snippet above, the HTML template binds a `<div>` element to a trigger named `openClose` with a status expression of `isOpen`, and with possible values of `true` and `false`.\nThis pattern is an alternative to the practice of creating two named states like `open` and `close`.\n\nInside the `@Component` metadata under the `animations:` property, when the state evaluates to `true`, the associated HTML element's height is a wildcard style or default.\nIn this case, the animation uses whatever height the element already had before the animation started.\nWhen the element is `closed`, the element gets animated to a height of 0, which makes it invisible.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.2.ts\" visibleRegion=\"trigger-boolean\"/>\n\n## Multiple animation triggers\n\nYou can define more than one animation trigger for a component.\nAttach animation triggers to different elements, and the parent-child relationships among the elements affect how and when the animations run.\n\n### Parent-child animations\n\nEach time an animation is triggered in Angular, the parent animation always gets priority and child animations are blocked.\nFor a child animation to run, the parent animation must query each of the elements containing child animations. It then lets the animations run using the [`animateChild()`](api/animations/animateChild) function.\n\n#### Disable an animation on an HTML element\n\nA special animation control binding called `@.disabled` can be placed on an HTML element to turn off animations on that element, as well as any nested elements.\nWhen true, the `@.disabled` binding prevents all animations from rendering.\n\nThe following code sample shows how to use this feature.\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/open-close.component.html\" path=\"adev/src/content/examples/animations/src/app/open-close.component.4.html\" visibleRegion=\"toggle-animation\"/>\n    <docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.4.ts\" visibleRegion=\"toggle-animation\" language=\"typescript\"/>\n</docs-code-multifile>\n\nWhen the `@.disabled` binding is true, the `@childAnimation` trigger doesn't kick off.\n\nWhen an element within an HTML template has animations turned off using the `@.disabled` host binding, animations are turned off on all inner elements as well.\nYou can't selectively turn off multiple animations on a single element.<!-- vale off -->\n\nA selective child animations can still be run on a disabled parent in one of the following ways:\n\n* A parent animation can use the [`query()`](api/animations/query) function to collect inner elements located in disabled areas of the HTML template.\n    Those elements can still animate.\n<!-- vale on -->\n\n* A child animation can be queried by a parent and then later animated with the `animateChild()` function\n\n#### Disable all animations\n\nTo turn off all animations for an Angular application, place the `@.disabled` host binding on the topmost Angular component.\n\n<docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/animations/src/app/app.component.ts\" visibleRegion=\"toggle-app-animations\"/>\n\nHELPFUL: Disabling animations application-wide is useful during end-to-end \\(E2E\\) testing.\n\n## Animation callbacks\n\nThe animation `trigger()` function emits *callbacks* when it starts and when it finishes.\nThe following example features a component that contains an `openClose` trigger.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"events1\"/>\n\nIn the HTML template, the animation event is passed back via `$event`, as `@triggerName.start` and `@triggerName.done`, where `triggerName` is the name of the trigger being used.\nIn this example, the trigger `openClose` appears as follows.\n\n<docs-code header=\"src/app/open-close.component.html\" path=\"adev/src/content/examples/animations/src/app/open-close.component.3.html\" visibleRegion=\"callbacks\"/>\n\nA potential use for animation callbacks could be to cover for a slow API call, such as a database lookup.\nFor example, an **InProgress** button can be set up to have its own looping animation while the backend system operation finishes.\n\nAnother animation can be called when the current animation finishes.\nFor example, the button goes from the `inProgress` state to the `closed` state when the API call is completed.\n\nAn animation can influence an end user to *perceive* the operation as faster, even when it is not.\n\nCallbacks can serve as a debugging tool, for example in conjunction with `console.warn()` to view the application's progress in a browser's Developer JavaScript Console.\nThe following code snippet creates console log output for the original example, a button with the two states of `open` and `closed`.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.ts\" visibleRegion=\"events\"/>\n\n## Keyframes\n\nTo create an animation with multiple steps run in sequence, use *keyframes*.\n\nAngular's `keyframe()` function allows several style changes within a single timing segment.\nFor example, the button, instead of fading, could change color several times over a single 2-second time span.\n\n<img alt=\"keyframes\" src=\"assets/images/guide/animations/keyframes-500.png\">\n\nThe code for this color change might look like this.\n\n<docs-code header=\"src/app/status-slider.component.ts\" path=\"adev/src/content/examples/animations/src/app/status-slider.component.ts\" visibleRegion=\"keyframes\"/>\n\n### Offset\n\nKeyframes include an `offset` that defines the point in the animation where each style change occurs.\nOffsets are relative measures from zero to one, marking the beginning and end of the animation. They should be applied to each of the keyframe steps if used at least once.\n\nDefining offsets for keyframes is optional.\nIf you omit them, evenly spaced offsets are automatically assigned.\nFor example, three keyframes without predefined offsets receive offsets of 0, 0.5, and 1.\nSpecifying an offset of 0.8 for the middle transition in the preceding example might look like this.\n\n<img alt=\"keyframes with offset\" src=\"assets/images/guide/animations/keyframes-offset-500.png\">\n\nThe code with offsets specified would be as follows.\n\n<docs-code header=\"src/app/status-slider.component.ts\" path=\"adev/src/content/examples/animations/src/app/status-slider.component.ts\" visibleRegion=\"keyframesWithOffsets\"/>\n\nYou can combine keyframes with `duration`, `delay`, and `easing` within a single animation.\n\n### Keyframes with a pulsation\n\nUse keyframes to create a pulse effect in your animations by defining styles at specific offset throughout the animation.\n\nHere's an example of using keyframes to create a pulse effect:\n\n* The original `open` and `closed` states, with the original changes in height, color, and opacity, occurring over a timeframe of 1 second\n* A keyframes sequence inserted in the middle that causes the button to appear to pulsate irregularly over the course of that same 1 second timeframe\n\n<img alt=\"keyframes with irregular pulsation\" src=\"assets/images/guide/animations/keyframes-pulsation.png\">\n\nThe code snippet for this animation might look like this.\n\n<docs-code header=\"src/app/open-close.component.ts\" path=\"adev/src/content/examples/animations/src/app/open-close.component.1.ts\" visibleRegion=\"trigger\"/>\n\n### Animatable properties and units\n\nAngular animations support builds on top of web animations, so you can animate any property that the browser considers animatable.\nThis includes positions, sizes, transforms, colors, borders, and more.\nThe W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1) page.\n\nFor properties with a numeric value, define a unit by providing the value as a string, in quotes, with the appropriate suffix:\n\n* 50 pixels:\n    `'50px'`\n\n* Relative font size:\n    `'3em'`\n\n* Percentage:\n    `'100%'`\n\nYou can also provide the value as a number. In such cases Angular assumes a default unit of pixels, or `px`.\nExpressing 50 pixels as `50` is the same as saying `'50px'`.\n\nHELPFUL: The string `\"50\"` would instead not be considered valid\\).\n\n### Automatic property calculation with wildcards\n\nSometimes, the value of a dimensional style property isn't known until runtime.\nFor example, elements often have widths and heights that depend on their content or the screen size.\nThese properties are often challenging to animate using CSS.\n\nIn these cases, you can use a special wildcard `*` property value under `style()`. The value of that particular style property is computed at runtime and then plugged into the animation.\n\nThe following example has a trigger called `shrinkOut`, used when an HTML element leaves the page.\nThe animation takes whatever height the element has before it leaves, and animates from that height to zero.\n\n<docs-code header=\"src/app/hero-list-auto.component.ts\" path=\"adev/src/content/examples/animations/src/app/hero-list-auto.component.ts\" visibleRegion=\"auto-calc\"/>\n\n### Keyframes summary\n\nThe `keyframes()` function in Angular allows you to specify multiple interim styles within a single transition. An optional `offset` can be used to define the point in the animation where each style change should occur.\n\n## More on Angular animations\n\nYou might also be interested in the following:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/animations\" title=\"Introduction to Angular animations\"/>\n  <docs-pill href=\"guide/animations/complex-sequences\" title=\"Complex animation sequences\"/>\n  <docs-pill href=\"guide/animations/reusable-animations\" title=\"Reusable animations\"/>\n  <docs-pill href=\"guide/animations/route-animations\" title=\"Route transition animations\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 3005
  },
  {
    "id": 12,
    "file": "advanced-configuration",
    "fullFileName": "adev/src/content/guide/components/advanced-configuration.md",
    "startLine": 3009,
    "content": "# Advanced component configuration\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\n## ChangeDetectionStrategy\n\nThe `@Component` decorator accepts a `changeDetection` option that controls the component's **change\ndetection mode**. There are two change detection mode options.\n\n**`ChangeDetectionStrategy.Default`** is, unsurprisingly, the default strategy. In this mode,\nAngular checks whether the component's DOM needs an update whenever any activity may have occurred\napplication-wide. Activities that trigger this checking include user interaction, network response,\ntimers, and more.\n\n**`ChangeDetectionStrategy.OnPush`** is an optional mode that reduces the amount of checking Angular\nneeds to perform. In this mode, the framework only checks if a component's DOM needs an update when:\n\n- A component input has changes as a result of a binding in a template, or\n- An event listener in this component runs\n- The component is explicitly marked for check, via `ChangeDetectorRef.markForCheck` or something which wraps it, like `AsyncPipe`.\n\nAdditionally, when an OnPush component is checked, Angular _also_ checks all of its ancestor\ncomponents, traversing upwards through the application tree.\n\n## PreserveWhitespaces\n\nBy default, Angular removes and collapses superfluous whitespace in templates, most commonly from\nnewlines and indentation. You can change this setting by explicitly setting `preserveWhitespaces` to\n`true` in a component's metadata.\n\n## Custom element schemas\n\nBy default, Angular throws an error when it encounters an unknown HTML element. You can\ndisable this behavior for a component by including `CUSTOM_ELEMENTS_SCHEMA` in the `schemas`\nproperty in your component metadata.\n\n```angular-ts\nimport {Component, CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';\n\n@Component({\n  ...,\n  schemas: [CUSTOM_ELEMENTS_SCHEMA],\n  template: '<some-unknown-component></some-unknown-component>'\n})\nexport class ComponentWithCustomElements { }\n```\n\nAngular does not support any other schemas at this time.\n\n\n\n================================================\n",
    "endLine": 3059
  },
  {
    "id": 13,
    "file": "anatomy-of-components",
    "fullFileName": "adev/src/content/guide/components/anatomy-of-components.md",
    "startLine": 3063,
    "content": "<docs-decorative-header title=\"Anatomy of a component\" imgSrc=\"adev/src/assets/images/components.svg\"> <!-- markdownlint-disable-line -->\n</docs-decorative-header>\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nEvery component must have:\n\n* A TypeScript class with _behaviors_ such as handling user input and fetching data from a server\n* An HTML template that controls what renders into the DOM\n* A [CSS selector](https://developer.mozilla.org/docs/Learn/CSS/Building_blocks/Selectors) that defines how the component is used in HTML\n\nYou provide Angular-specific information for a component by adding a `@Component` [decorator](https://www.typescriptlang.org/docs/handbook/decorators.html) on top of the TypeScript class:\n\n<docs-code language=\"angular-ts\" highlight=\"[1, 2, 3, 4]\">\n@Component({\n  selector: 'profile-photo',\n  template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`,\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nFor full details on writing Angular templates, including data binding, event handling, and control flow, see the [Templates guide](guide/templates).\n\nThe object passed to the `@Component` decorator is called the component's **metadata**. This includes the `selector`, `template`, and other properties described throughout this guide.\n\nComponents can optionally include a list of CSS styles that apply to that component's DOM:\n\n<docs-code language=\"angular-ts\" highlight=\"[4]\">\n@Component({\n  selector: 'profile-photo',\n  template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`,\n  styles: `img { border-radius: 50%; }`,\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nBy default, a component's styles only affect elements defined in that component's template. See [Styling Components](guide/components/styling) for details on Angular's approach to styling.\n\nYou can alternatively choose to write your template and styles in separate files:\n\n<docs-code language=\"angular-ts\" highlight=\"[3, 4]\">\n@Component({\n  selector: 'profile-photo',\n  templateUrl: 'profile-photo.html',\n  styleUrl: 'profile-photo.css',\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nThis can help separate the concerns of _presentation_ from _behavior_ in your project. You can choose one approach for your entire project, or you decide which to use for each component.\n\nBoth `templateUrl` and `styleUrl` are relative to the directory in which the component resides.\n\n## Using components\n\n### Imports in the `@Component` decorator\n\nTo use a component, [directive](guide/directives), or [pipe](guide/templates/pipes), you must add\nit to the `imports` array in the `@Component` decorator:\n\n```angular-ts\nimport {ProfilePhoto} from './profile-photo';\n\n@Component({\n  // Import the `ProfilePhoto` component in\n  // order to use it in this component's template.\n  imports: [ProfilePhoto],\n  /* ... */\n})\nexport class UserProfile { }\n```\n\nBy default, Angular components are *standalone*, meaning that you can directly add them to the `imports` array of other components. Components created with an earlier version of Angular may instead specify `standalone: false` in their `@Component` decorator. For these components, you instead import the `NgModule` in which the component is defined. See the full [`NgModule` guide](guide/ngmodules) for details.\n\nImportant: In Angular versions before 19.0.0, the `standalone` option defaults to `false`.\n\n### Showing components in a template\n\nEvery component defines a [CSS selector](https://developer.mozilla.org/docs/Learn/CSS/Building_blocks/Selectors):\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: 'profile-photo',\n  ...\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nSee [Component Selectors](guide/components/selectors) for details about which types of selectors Angular supports and guidance on choosing a selector.\n\nYou show a component by creating a matching HTML element in the template of _other_ components:\n\n<docs-code language=\"angular-ts\" highlight=\"[8]\">\n@Component({\n  selector: 'profile-photo',\n})\nexport class ProfilePhoto { }\n\n@Component({\n  imports: [ProfilePhoto],\n  template: `<profile-photo />`\n})\nexport class UserProfile { }\n</docs-code>\n\nAngular creates an instance of the component for every matching HTML element it encounters. The DOM element that matches a component's selector is referred to as that component's **host element**. The contents of a component's template are rendered inside its host element.\n\nThe DOM rendered by a component, corresponding to that component's template, is called that\ncomponent's **view**.\n\nIn composing components in this way, **you can think of your Angular application as a tree of components**.\n\n```mermaid\nflowchart TD\n    A[AccountSettings]-->B\n    A-->C\n    B[UserProfile]-->D\n    B-->E\n    C[PaymentInfo]\n    D[ProfilePic]\n    E[UserBio]\n```\n\n\nThis tree structure is important to understanding several other Angular concepts, including [dependency injection](guide/di) and [child queries](guide/components/queries).\n\n\n\n================================================\nFILE: adev/src/content/guide/components/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"components\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:components.svg\",\n    ],\n    mermaid_blocks = True,\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 3209
  },
  {
    "id": 14,
    "file": "content-projection",
    "fullFileName": "adev/src/content/guide/components/content-projection.md",
    "startLine": 3213,
    "content": "# Content projection with ng-content\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nYou often need to create components that act as containers for different types of content. For\nexample, you may want to create a custom card component:\n\n```angular-ts\n@Component({\n  selector: 'custom-card',\n  template: '<div class=\"card-shadow\"> <!-- card content goes here --> </div>',\n})\nexport class CustomCard {/* ... */}\n```\n\n**You can use the `<ng-content>` element as a placeholder to mark where content should go**:\n\n```angular-ts\n@Component({\n  selector: 'custom-card',\n  template: '<div class=\"card-shadow\"> <ng-content></ng-content> </div>',\n})\nexport class CustomCard {/* ... */}\n```\n\nTIP: `<ng-content>` works similarly\nto [the native `<slot>` element](https://developer.mozilla.org/docs/Web/HTML/Element/slot),\nbut with some Angular-specific functionality.\n\nWhen you use a component with `<ng-content>`, any children of the component host element are\nrendered, or **projected**, at the location of that `<ng-content>`:\n\n```angular-ts\n// Component source\n@Component({\n  selector: 'custom-card',\n  template: `\n    <div class=\"card-shadow\">\n      <ng-content />\n    </div>\n  `,\n})\nexport class CustomCard {/* ... */}\n```\n\n```angular-html\n<!-- Using the component -->\n<custom-card>\n  <p>This is the projected content</p>\n</custom-card>\n```\n\n```angular-html\n<!-- The rendered DOM -->\n<custom-card>\n  <div class=\"card-shadow\">\n    <p>This is the projected content</p>\n  </div>\n</custom-card>\n```\n\nAngular refers to any children of a component passed this way as that component's **content**. This\nis distinct from the component's **view**, which refers to the elements defined in the component's\ntemplate.\n\n**The `<ng-content>` element is neither a component nor DOM element**. Instead, it is a special\nplaceholder that tells Angular where to render content. Angular's compiler processes\nall `<ng-content>` elements at build-time. You cannot insert, remove, or modify `<ng-content>` at\nrun time. You cannot add directives, styles, or arbitrary attributes to `<ng-content>`.\n\nYou should not conditionally include `<ng-content>` with `@if`, `@for`, or `@switch`. Angular always\ninstantiates and creates DOM nodes for content rendered to a `<ng-content>` placeholder, even if\nthat `<ng-content>` placeholder is hidden. For conditional rendering of component content,\nsee [Template fragments](api/core/ng-template).\n\n## Multiple content placeholders\n\nAngular supports projecting multiple different elements into different `<ng-content>` placeholders\nbased on CSS selector. Expanding the card example from above, you could create two placeholders for\na card title and a card body by using the `select` attribute:\n\n```angular-html\n<!-- Component template -->\n<div class=\"card-shadow\">\n  <ng-content select=\"card-title\"></ng-content>\n  <div class=\"card-divider\"></div>\n  <ng-content select=\"card-body\"></ng-content>\n</div>\n```\n\n```angular-html\n<!-- Using the component -->\n<custom-card>\n  <card-title>Hello</card-title>\n  <card-body>Welcome to the example</card-body>\n</custom-card>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<custom-card>\n  <div class=\"card-shadow\">\n    <card-title>Hello</card-title>\n    <div class=\"card-divider\"></div>\n    <card-body>Welcome to the example</card-body>\n  </div>\n</custom-card>\n```\n\nThe `<ng-content>` placeholder supports the same CSS selectors\nas [component selectors](guide/components/selectors).\n\nIf you include one or more `<ng-content>` placeholders with a `select` attribute and\none `<ng-content>` placeholder without a `select` attribute, the latter captures all elements that\ndid not match a `select` attribute:\n\n```angular-html\n<!-- Component template -->\n<div class=\"card-shadow\">\n  <ng-content select=\"card-title\"></ng-content>\n  <div class=\"card-divider\"></div>\n  <!-- capture anything except \"card-title\" -->\n  <ng-content></ng-content>\n</div>\n```\n\n```angular-html\n<!-- Using the component -->\n<custom-card>\n  <card-title>Hello</card-title>\n  <img src=\"...\" />\n  <p>Welcome to the example</p>\n</custom-card>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<custom-card>\n  <div class=\"card-shadow\">\n    <card-title>Hello</card-title>\n    <div class=\"card-divider\"></div>\n    <img src=\"...\" />\n    <p>Welcome to the example</p>\n  </div>\n</custom-card>\n```\n\nIf a component does not include an `<ng-content>` placeholder without a `select` attribute, any\nelements that don't match one of the component's placeholders do not render into the DOM.\n\n## Fallback content\n\nAngular can show *fallback content* for a component's `<ng-content>` placeholder if that component doesn't have any matching child content. You can specify fallback content by adding child content to the `<ng-content>` element itself.\n\n```angular-html\n<!-- Component template -->\n<div class=\"card-shadow\">\n  <ng-content select=\"card-title\">Default Title</ng-content>\n  <div class=\"card-divider\"></div>\n  <ng-content select=\"card-body\">Default Body</ng-content>\n</div>\n```\n\n```angular-html\n<!-- Using the component -->\n<custom-card>\n  <card-title>Hello</card-title>\n  <!-- No card-body provided -->\n</custom-card>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<custom-card>\n  <div class=\"card-shadow\">\n    Hello\n    <div class=\"card-divider\"></div>\n    Default Body\n  </div>\n</custom-card>\n```\n\n## Aliasing content for projection\n\nAngular supports a special attribute, `ngProjectAs`, that allows you to specify a CSS selector on\nany element. Whenever an element with `ngProjectAs` is checked against an `<ng-content>`\nplaceholder, Angular compares against the `ngProjectAs` value instead of the element's identity:\n\n```angular-html\n<!-- Component template -->\n<div class=\"card-shadow\">\n  <ng-content select=\"card-title\"></ng-content>\n  <div class=\"card-divider\"></div>\n  <ng-content></ng-content>\n</div>\n```\n\n```angular-html\n<!-- Using the component -->\n<custom-card>\n  <h3 ngProjectAs=\"card-title\">Hello</h3>\n\n  <p>Welcome to the example</p>\n</custom-card>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<custom-card>\n  <div class=\"card-shadow\">\n    <h3>Hello</h3>\n    <div class=\"card-divider\"></div>\n    <p>Welcome to the example</p>\n  </div>\n</custom-card>\n```\n\n`ngProjectAs` supports only static values and cannot be bound to dynamic expressions.\n\n\n\n================================================\n",
    "endLine": 3433
  },
  {
    "id": 15,
    "file": "dom-apis",
    "fullFileName": "adev/src/content/guide/components/dom-apis.md",
    "startLine": 3437,
    "content": "# Using DOM APIs\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nAngular handles most DOM creation, updates, and removals for you. However, you might rarely need to\ndirectly interact with a component's DOM. Components can inject ElementRef to get a reference to the\ncomponent's host element:\n\n```ts\n@Component({...})\nexport class ProfilePhoto {\n  constructor() {\n    const elementRef = inject(ElementRef);\n    console.log(elementRef.nativeElement);\n  }\n}\n```\n\nThe `nativeElement` property references the\nhost [Element](https://developer.mozilla.org/docs/Web/API/Element) instance.\n\nYou can use Angular's `afterRender` and `afterNextRender` functions to register a **render\ncallback** that runs when Angular has finished rendering the page.\n\n```ts\n@Component({...})\nexport class ProfilePhoto {\n  constructor() {\n    const elementRef = inject(ElementRef);\n    afterRender(() => {\n      // Focus the first input element in this component.\n      elementRef.nativeElement.querySelector('input')?.focus();\n    });\n  }\n}\n```\n\n`afterRender` and `afterNextRender` must be called in an _injection context_, typically a\ncomponent's constructor.\n\n**Avoid direct DOM manipulation whenever possible.** Always prefer expressing your DOM's structure\nin component templates and updating that DOM with bindings.\n\n**Render callbacks never run during server-side rendering or build-time pre-rendering.**\n\n**Never directly manipulate the DOM inside of other Angular lifecycle hooks**. Angular does not\nguarantee that a component's DOM is fully rendered at any point other than in render callbacks.\nFurther, reading or modifying the DOM during other lifecycle hooks can negatively impact page\nperformance by\ncausing [layout thrashing](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing).\n\n## Using a component's renderer\n\nComponents can inject an instance of `Renderer2` to perform certain DOM manipulations that are tied\nto other Angular features.\n\nAny DOM elements created by a component's `Renderer2` participate in that\ncomponent's [style encapsulation](guide/components/styling#style-scoping).\n\nCertain `Renderer2` APIs also tie into Angular's animation system. You can use the `setProperty`\nmethod to update synthetic animation properties and the `listen` method to add event listeners for\nsynthetic animation events. See the [Animations](guide/animations) guide for details.\n\nAside from these two narrow use-cases, there is no difference between using `Renderer2` and native\nDOM APIs. `Renderer2` APIs do not support DOM manipulation in server-side rendering or build-time\npre-rendering contexts.\n\n## When to use DOM APIs\n\nWhile Angular handles most rendering concerns, some behaviors may still require using DOM APIs. Some\ncommon use cases include:\n\n- Managing element focus\n- Measuring element geometry, such as with `getBoundingClientRect`\n- Reading an element's text content\n- Setting up native observers such\n  as [`MutationObserver`](https://developer.mozilla.org/docs/Web/API/MutationObserver),\n  [`ResizeObserver`](https://developer.mozilla.org/docs/Web/API/ResizeObserver), or\n  [`IntersectionObserver`](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API).\n\nAvoid inserting, removing, and modifying DOM elements. In particular, **never directly set an\nelement's `innerHTML` property**, which can make your application vulnerable\nto [cross-site scripting (XSS) exploits](https://developer.mozilla.org/docs/Glossary/Cross-site_scripting).\nAngular's template bindings, including bindings for `innerHTML`, include safeguards that help\nprotect against XSS attacks. See the [Security guide](best-practices/security) for details.\n\n\n\n================================================\n",
    "endLine": 3524
  },
  {
    "id": 16,
    "file": "host-elements",
    "fullFileName": "adev/src/content/guide/components/host-elements.md",
    "startLine": 3528,
    "content": "# Component host elements\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nAngular creates an instance of a component for every HTML element that matches the component's\nselector. The DOM element that matches a component's selector is that component's **host element**.\nThe contents of a component's template are rendered inside its host element.\n\n```angular-ts\n// Component source\n@Component({\n  selector: 'profile-photo',\n  template: `\n    <img src=\"profile-photo.jpg\" alt=\"Your profile photo\" />\n  `,\n})\nexport class ProfilePhoto {}\n```\n\n```angular-html\n<!-- Using the component -->\n<h3>Your profile photo</h3>\n<profile-photo />\n<button>Upload a new profile photo</button>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<h3>Your profile photo</h3>\n<profile-photo>\n  <img src=\"profile-photo.jpg\" alt=\"Your profile photo\" />\n</profile-photo>\n<button>Upload a new profile photo</button>\n```\n\nIn the above example, `<profile-photo>` is the host element of the `ProfilePhoto` component.\n\n## Binding to the host element\n\nA component can bind properties, attributes, and events to its host element. This behaves\nidentically to bindings on elements inside the component's template, but instead defined with\nthe `host` property in the `@Component` decorator:\n\n```angular-ts\n@Component({\n  ...,\n  host: {\n    'role': 'slider',\n    '[attr.aria-valuenow]': 'value',\n    '[class.active]': 'isActive()',\n    '[tabIndex]': 'disabled ? -1 : 0',\n    '(keydown)': 'updateValue($event)',\n  },\n})\nexport class CustomSlider {\n  value: number = 0;\n  disabled: boolean = false;\n  isActive = signal(false);\n  updateValue(event: KeyboardEvent) { /* ... */ }\n\n  /* ... */\n}\n```\n\n## The `@HostBinding` and `@HostListener` decorators\n\nYou can alternatively bind to the host element by applying the `@HostBinding` and `@HostListener`\ndecorator to class members.\n\n`@HostBinding` lets you bind host properties and attributes to properties and methods:\n\n```angular-ts\n@Component({\n  /* ... */\n})\nexport class CustomSlider {\n  @HostBinding('attr.aria-valuenow')\n  value: number = 0;\n\n  @HostBinding('tabIndex')\n  getTabIndex() {\n    return this.disabled ? -1 : 0;\n  }\n\n  /* ... */\n}\n```\n\n`@HostListener` lets you bind event listeners to the host element. The decorator accepts an event\nname and an optional array of arguments:\n\n```ts\nexport class CustomSlider {\n  @HostListener('keydown', ['$event'])\n  updateValue(event: KeyboardEvent) {\n    /* ... */\n  }\n}\n```\n\n**Always prefer using the `host` property over `@HostBinding` and `@HostListener`.** These\ndecorators exist exclusively for backwards compatibility.\n\n## Binding collisions\n\nWhen you use a component in a template, you can add bindings to that component instance's element.\nThe component may _also_ define host bindings for the same properties or attributes.\n\n```angular-ts\n@Component({\n  ...,\n  host: {\n    'role': 'presentation',\n    '[id]': 'id',\n  }\n})\nexport class ProfilePhoto { /* ... */ }\n```\n\n```angular-html\n<profile-photo role=\"group\" [id]=\"otherId\" />\n```\n\nIn cases like this, the following rules determine which value wins:\n\n- If both values are static, the instance binding wins.\n- If one value is static and the other dynamic, the dynamic value wins.\n- If both values are dynamic, the component's host binding wins.\n\n\n\n================================================\n",
    "endLine": 3658
  },
  {
    "id": 17,
    "file": "inheritance",
    "fullFileName": "adev/src/content/guide/components/inheritance.md",
    "startLine": 3662,
    "content": "# Inheritance\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nAngular components are TypeScript classes and participate in standard JavaScript inheritance\nsemantics.\n\nA component can extend any base class:\n\n```ts\nexport class ListboxBase {\n  value: string;\n}\n\n@Component({ ... })\nexport class CustomListbox extends ListboxBase {\n  // CustomListbox inherits the `value` property.\n}\n```\n\n## Extending other components and directives\n\nWhen a component extends another component or a directive, it inherits some of the metadata defined in\nthe base class's decorator and the base class's decorated members. This includes\nhost bindings, inputs, outputs, lifecycle methods.\n\n```angular-ts\n@Component({\n  selector: 'base-listbox',\n  template: `\n    ...\n  `,\n  host: {\n    '(keydown)': 'handleKey($event)',\n  },\n})\nexport class ListboxBase {\n  @Input() value: string;\n  handleKey(event: KeyboardEvent) {\n    /* ... */\n  }\n}\n\n@Component({\n  selector: 'custom-listbox',\n  template: `\n    ...\n  `,\n  host: {\n    '(click)': 'focusActiveOption()',\n  },\n})\nexport class CustomListbox extends ListboxBase {\n  @Input() disabled = false;\n  focusActiveOption() {\n    /* ... */\n  }\n}\n```\n\nIn the example above, `CustomListbox` inherits all the information associated with `ListboxBase`,\noverriding the selector and template with its own values. `CustomListbox` has two inputs (`value`\nand `disabled`) and two event listeners (`keydown` and `click`).\n\nChild classes end up with the _union_ of all of their ancestors' inputs, outputs, and host bindings\nand their own.\n\n### Forwarding injected dependencies\n\nIf a base class injects dependencies as constructor parameters, the child class must explicitly class these dependencies to `super`.\n\n```ts\n@Component({ ... })\nexport class ListboxBase {\n  constructor(private element: ElementRef) { }\n}\n\n@Component({ ... })\nexport class CustomListbox extends ListboxBase {\n  constructor(element: ElementRef) {\n    super(element);\n  }\n}\n```\n\n### Overriding lifecycle methods\n\nIf a base class defines a lifecycle method, such as `ngOnInit`, a child class that also\nimplements `ngOnInit` _overrides_ the base class's implementation. If you want to preserve the base\nclass's lifecycle method, explicitly call the method with `super`:\n\n```ts\n@Component({ ... })\nexport class ListboxBase {\n  protected isInitialized = false;\n  ngOnInit() {\n    this.isInitialized = true;\n  }\n}\n\n@Component({ ... })\nexport class CustomListbox extends ListboxBase {\n  override ngOnInit() {\n    super.ngOnInit();\n    /* ... */\n  }\n}\n```\n\n\n\n================================================\n",
    "endLine": 3772
  },
  {
    "id": 18,
    "file": "inputs",
    "fullFileName": "adev/src/content/guide/components/inputs.md",
    "startLine": 3776,
    "content": "# Accepting data with input properties\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nTIP: If you're familiar with other web frameworks, input properties are similar to _props_.\n\nWhen you use a component, you commonly want to pass some data to it. A component specifies the data that it accepts by declaring\n**inputs**:\n\n<docs-code language=\"ts\" highlight=\"[7]\">\nimport {Component, input} from '@angular/core';\n\n@Component({/*...*/})\nexport class CustomSlider {\n  // Declare an input named 'value' with a default value of zero.\n  value = input(0);\n}\n</docs-code>\n\nThis lets you bind to the property in a template:\n\n```angular-html\n<custom-slider [value]=\"50\" />\n```\n\nIf an input has a default value, TypeScript infers the type from the default value:\n\n```typescript\n@Component({/*...*/})\nexport class CustomSlider {\n  // TypeScript infers that this input is a number, returning InputSignal<number>.\n  value = input(0);\n}\n```\n\nYou can explicitly declare a type for the input by specifying a generic parameter to the function.\n\nIf an input without a default value is not set, its value is `undefined`:\n\n```typescript\n@Component({/*...*/})\nexport class CustomSlider {\n  // Produces an InputSignal<number | undefined> because `value` may not be set.\n  value = input<number>();\n}\n```\n\n**Angular records inputs statically at compile-time**. Inputs cannot be added or removed at run-time.\n\nThe `input` function has special meaning to the Angular compiler. **You can exclusively call `input` in component and directive property initializers.**\n\nWhen extending a component class, **inputs are inherited by the child class.**\n\n**Input names are case-sensitive.**\n\n## Reading inputs\n\nThe `input` function returns an `InputSignal`. You can read the value by calling the signal:\n\n<docs-code language=\"ts\" highlight=\"[5]\">\nimport {Component, input} from '@angular/core';\n\n@Component({/*...*/})\nexport class CustomSlider {\n  // Declare an input named 'value' with a default value of zero. \n  value = input(0);\n\n  // Create a computed expression that reads the value input\n  label = computed(() => `The slider's value is ${this.value()}`); \n}\n</docs-code>\n\nSignals created by the `input` function are read-only.\n\n## Required inputs\n\nYou can declare that an input is `required` by calling `input.required` instead of `input`:\n\n<docs-code language=\"ts\" highlight=\"[3]\">\n@Component({/*...*/})\nexport class CustomSlider {\n  // Declare a required input named value. Returns an `InputSignal<number>`.\n  value = input.required<number>();\n}\n</docs-code>\n\nAngular enforces that required inputs _must_ be set when the component is used in a template. If you try to use a component without specifying all of its required inputs, Angular reports an error at build-time.\n\nRequired inputs do not automatically include `undefined` in the generic parameter of the returned `InputSignal`.\n\n## Configuring inputs\n\nThe `input` function accepts a config object as a second parameter that lets you change the way that input works.\n\n### Input transforms\n\nYou can specify a `transform` function to change the value of an input when it's set by Angular.\n\n<docs-code language=\"ts\" highlight=\"[6]\">\n@Component({\n  selector: 'custom-slider',\n  /*...*/\n})\nexport class CustomSlider {\n  label = input('', {transform: trimString});\n}\n\nfunction trimString(value: string | undefined): string {\n  return value?.trim() ?? '';\n}\n</docs-code>\n\n```angular-html\n<custom-slider [label]=\"systemVolume\" />\n```\n\nIn the example above, whenever the value of `systemVolume` changes, Angular runs `trimString` and sets `label` to the result.\n\nThe most common use-case for input transforms is to accept a wider range of value types in templates, often including `null` and `undefined`.\n\n**Input transform function must be statically analyzable at build-time.** You cannot set transform functions conditionally or as the result of an expression evaluation.\n\n**Input transform functions should always be [pure functions](https://en.wikipedia.org/wiki/Pure_function).** Relying on state outside the transform function can lead to unpredictable behavior.\n\n#### Type checking\n\nWhen you specify an input transform, the type of the transform function's parameter determines the types of values that can be set to the input in a template.\n\n<docs-code language=\"ts\">\n@Component({/*...*/})\nexport class CustomSlider {\n  widthPx = input('', {transform: appendPx});\n}\n\nfunction appendPx(value: number): string {\n  return `${value}px`;\n}\n</docs-code>\n\nIn the example above, the `widthPx` input accepts a `number` while the `InputSignal` property returns a `string`.\n\n#### Built-in transformations\n\nAngular includes two built-in transform functions for the two most common scenarios: coercing values to boolean and numbers.\n\n<docs-code language=\"ts\">\nimport {Component, input, booleanAttribute, numberAttribute} from '@angular/core';\n\n@Component({/*...*/})\nexport class CustomSlider {\n  disabled = input(false, {transform: booleanAttribute}); \n  value = input(0, {transform: numberAttribute}); \n}\n</docs-code>\n\n`booleanAttribute` imitates the behavior of standard HTML [boolean attributes](https://developer.mozilla.org/docs/Glossary/Boolean/HTML), where the\n_presence_ of the attribute indicates a \"true\" value. However, Angular's `booleanAttribute` treats the literal string `\"false\"` as the boolean `false`.\n\n`numberAttribute` attempts to parse the given value to a number, producing `NaN` if parsing fails.\n\n### Input aliases\n\nYou can specify the `alias` option to change the name of an input in templates.\n\n<docs-code language=\"ts\" highlight=\"[3]\">\n@Component({/*...*/})\nexport class CustomSlider {\n  value = input(0, {alias: 'sliderValue'});\n}\n</docs-code>\n\n```angular-html\n<custom-slider [sliderValue]=\"50\" />\n```\n\nThis alias does not affect usage of the property in TypeScript code.\n\nWhile you should generally avoid aliasing inputs for components, this feature can be useful for renaming properties while preserving an alias for the original name or for avoiding collisions with the name of native DOM element properties.\n\n## Model inputs\n\n**Model inputs** are a special type of input that enable a component to propagate new values back to its parent component.\n\nWhen creating a component, you can define a model input similarly to how you create a standard input.\n\nBoth types of input allow someone to bind a value into the property. However, **model inputs allow the component author to write values into the property**. If the property is bound with a two-way binding, the new value propagates to that binding.\n\n```typescript\n@Component({ /* ... */})\nexport class CustomSlider {\n  // Define a model input named \"value\".\n  value = model(0);\n\n  increment() {\n    // Update the model input with a new value, propagating the value to any bindings. \n    this.value.update(oldValue => oldValue + 10);\n  }\n}\n\n@Component({\n  /* ... */\n  // Using the two-way binding syntax means that any changes to the slider's\n  // value automatically propagate back to the `volume` signal.\n  // Note that this binding uses the signal *instance*, not the signal value.\n  template: `<custom-slider [(value)]=\"volume\" />`,\n})\nexport class MediaControls {\n  // Create a writable signal for the `volume` local state. \n  volume = signal(0);\n}\n```\n\nIn the above example, the `CustomSlider` can write values into its `value` model input, which then propagates those values back to the `volume` signal in `MediaControls`. This binding keeps the values of `value` and `volume` in sync. Notice that the binding passes the `volume` signal instance, not the _value_ of the signal.\n\nIn other respects, model inputs work similarly to standard inputs. You can read the value by calling the signal function, including in reactive contexts like `computed` and `effect`.\n\nSee [Two-way binding](guide/templates/two-way-binding) for more details on two-way binding in templates.\n\n### Two-way binding with plain properties\n\nYou can bind a plain JavaScript property to a model input.\n\n```angular-ts\n@Component({\n  /* ... */\n  // `value` is a model input.\n  // The parenthesis-inside-square-brackets syntax (aka \"banana-in-a-box\") creates a two-way binding\n  template: '<custom-slider [(value)]=\"volume\" />',\n})\nexport class MediaControls {\n  protected volume = 0;\n}\n```\n\nIn the example above, the `CustomSlider` can write values into its `value` model input, which then propagates those values back to the `volume` property in `MediaControls`. This binding keeps the values of `value` and `volume` in sync.\n\n### Implicit `change` events\n\nWhen you declare a model input in a component or directive, Angular automatically creates a corresponding [output](guide/components/outputs) for that model. The output's name is the model input's name suffixed with \"Change\".\n\n```angular-ts\n@Directive({ /* ... */ })\nexport class CustomCheckbox {\n  // This automatically creates an output named \"checkedChange\".\n  // Can be subscribed to using `(checkedChange)=\"handler()\"` in the template.\n  checked = model(false);\n}\n```\n\nAngular emits this change event whenever you write a new value into the model input by calling its `set` or `update` methods.\n\nSee [Custom events with outputs](guide/components/outputs) for more details on outputs.\n\n### Customizing model inputs\n\nYou can mark a model input as required or provide an alias in the same way as a [standard input](guide/signals/inputs).\n\nModel inputs do not support input transforms.\n\n### When to use model inputs\n\nUse model inputs when you want a component to support two-way binding. This is typically appropriate when a component exists to modify a value based on user interaction. Most commonly, custom form controls, such as a date picker or combobox, should use model inputs for their primary value.\n\n## Choosing input names\n\nAvoid choosing input names that collide with properties on DOM elements like HTMLElement. Name collisions introduce confusion about whether the bound property belongs to the component or the DOM element.\n\nAvoid adding prefixes for component inputs like you would with component selectors. Since a given element can only host one component, any custom properties can be assumed to belong to the component.\n\n## Declaring inputs with the `@Input` decorator\n\nTIP: While the Angular team recommends using the signal-based `input` function for new projects, the original decorator-based `@Input` API remains fully supported.\n\nYou can alternatively declare component inputs by adding the `@Input` decorator to a property:\n\n<docs-code language=\"ts\" highlight=\"[3]\">\n@Component({...})\nexport class CustomSlider {\n  @Input() value = 0;\n}\n</docs-code>\n\nBinding to an input is the same in both signal-based and decorator-based inputs:\n\n```angular-html\n<custom-slider [value]=\"50\" />\n```\n\n### Customizing decorator-based inputs\n\nThe `@Input` decorator accepts a config object that lets you change the way that input works.\n\n#### Required inputs\n\nYou can specify the `required` option to enforce that a given input must always have a value.\n\n<docs-code language=\"ts\" highlight=\"[3]\">\n@Component({...})\nexport class CustomSlider {\n  @Input({required: true}) value = 0;\n}\n</docs-code>\n\nIf you try to use a component without specifying all of its required inputs, Angular reports an error at build-time.\n\n#### Input transforms\n\nYou can specify a `transform` function to change the value of an input when it's set by Angular. This transform function works identically to transform functions for signal-based inputs described above.\n\n<docs-code language=\"ts\" highlight=\"[6]\">\n@Component({\n  selector: 'custom-slider',\n  ...\n})\nexport class CustomSlider {\n  @Input({transform: trimString}) label = '';\n}\n\nfunction trimString(value: string | undefined) { return value?.trim() ?? ''; }\n</docs-code>\n\n#### Input aliases\n\nYou can specify the `alias` option to change the name of an input in templates.\n\n<docs-code language=\"ts\" highlight=\"[3]\">\n@Component({...})\nexport class CustomSlider {\n  @Input({alias: 'sliderValue'}) value = 0;\n}\n</docs-code>\n\n```angular-html\n<custom-slider [sliderValue]=\"50\" />\n```\n\nThe `@Input` decorator also accepts the alias as its first parameter in place of the config object.\n\nInput aliases work the same way as for signal-based inputs described above.\n\n### Inputs with getters and setters\n\nWhen using decorator-based inputs, a property implemented with a getter and setter can be an input:\n\n<docs-code language=\"ts\">\nexport class CustomSlider {\n  @Input()\n  get value(): number {\n    return this.internalValue;\n  }\n\nset value(newValue: number) { this.internalValue = newValue; }\n\nprivate internalValue = 0; }\n</docs-code>\n\nYou can even create a _write-only_ input by only defining a public setter:\n\n<docs-code language=\"ts\">\nexport class CustomSlider {\n  @Input()\n  set value(newValue: number) {\n    this.internalValue = newValue;\n  }\n\nprivate internalValue = 0; }\n</docs-code>\n\n**Prefer using input transforms instead of getters and setters** if possible.\n\nAvoid complex or costly getters and setters. Angular may invoke an input's setter multiple times, which may negatively impact application performance if the setter performs any costly behaviors, such as DOM manipulation.\n\n## Specify inputs in the `@Component` decorator\n\nIn addition to the `@Input` decorator, you can also specify a component's inputs with the `inputs` property in the `@Component` decorator. This can be useful when a component inherits a property from a base class:\n\n<docs-code language=\"ts\" highlight=\"[4]\">\n// `CustomSlider` inherits the `disabled` property from `BaseSlider`.\n@Component({\n  ...,\n  inputs: ['disabled'],\n})\nexport class CustomSlider extends BaseSlider { }\n</docs-code>\n\nYou can additionally specify an input alias in the `inputs` list by putting the alias after a colon in the string:\n\n<docs-code language=\"ts\" highlight=\"[4]\">\n// `CustomSlider` inherits the `disabled` property from `BaseSlider`.\n@Component({\n  ...,\n  inputs: ['disabled: sliderDisabled'],\n})\nexport class CustomSlider extends BaseSlider { }\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 4173
  },
  {
    "id": 19,
    "file": "lifecycle",
    "fullFileName": "adev/src/content/guide/components/lifecycle.md",
    "startLine": 4177,
    "content": "# Component Lifecycle\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nA component's **lifecycle** is the sequence of steps that happen between the component's creation\nand its destruction. Each step represents a different part of Angular's process for rendering\ncomponents and checking them for updates over time.\n\nIn your components, you can implement **lifecycle hooks** to run code during these steps.\nLifecycle hooks that relate to a specific component instance are implemented as methods on your\ncomponent class. Lifecycle hooks that relate the Angular application as a whole are implemented\nas functions that accept a callback.\n\nA component's lifecycle is tightly connected to how Angular checks your components for changes over\ntime. For the purposes of understanding this lifecycle, you only need to know that Angular walks\nyour application tree from top to bottom, checking template bindings for changes. The lifecycle\nhooks described below run while Angular is doing this traversal. This traversal visits each\ncomponent exactly once, so you should always avoid making further state changes in the middle of the\nprocess.\n\n## Summary\n\n<div class=\"docs-table docs-scroll-track-transparent\">\n  <table>\n    <tr>\n      <td><strong>Phase</strong></td>\n      <td><strong>Method</strong></td>\n      <td><strong>Summary</strong></td>\n    </tr>\n    <tr>\n      <td>Creation</td>\n      <td><code>constructor</code></td>\n      <td>\n        <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Classes/constructor\" target=\"_blank\">\n          Standard JavaScript class constructor\n        </a>. Runs when Angular instantiates the component.\n      </td>\n    </tr>\n    <tr>\n      <td rowspan=\"7\">Change<p>Detection</td>\n      <td><code>ngOnInit</code>\n      </td>\n      <td>Runs once after Angular has initialized all the component's inputs.</td>\n    </tr>\n    <tr>\n      <td><code>ngOnChanges</code></td>\n      <td>Runs every time the component's inputs have changed.</td>\n    </tr>\n    <tr>\n      <td><code>ngDoCheck</code></td>\n      <td>Runs every time this component is checked for changes.</td>\n    </tr>\n    <tr>\n      <td><code>ngAfterContentInit</code></td>\n      <td>Runs once after the component's <em>content</em> has been initialized.</td>\n    </tr>\n    <tr>\n      <td><code>ngAfterContentChecked</code></td>\n      <td>Runs every time this component content has been checked for changes.</td>\n    </tr>\n    <tr>\n      <td><code>ngAfterViewInit</code></td>\n      <td>Runs once after the component's <em>view</em> has been initialized.</td>\n    </tr>\n    <tr>\n      <td><code>ngAfterViewChecked</code></td>\n      <td>Runs every time the component's view has been checked for changes.</td>\n    </tr>\n    <tr>\n      <td rowspan=\"2\">Rendering</td>\n      <td><code>afterNextRender</code></td>\n      <td>Runs once the next time that <strong>all</strong> components have been rendered to the DOM.</td>\n    </tr>\n    <tr>\n      <td><code>afterRender</code></td>\n      <td>Runs every time <strong>all</strong> components have been rendered to the DOM.</td>\n    </tr>\n    <tr>\n      <td>Destruction</td>\n      <td><code>ngOnDestroy</code></td>\n      <td>Runs once before the component is destroyed.</td>\n    </tr>\n  </table>\n</div>\n\n### ngOnInit\n\nThe `ngOnInit` method runs after Angular has initialized all the components inputs with their\ninitial values. A component's `ngOnInit` runs exactly once.\n\nThis step happens _before_ the component's own template is initialized. This means that you can\nupdate the component's state based on its initial input values.\n\n### ngOnChanges\n\nThe `ngOnChanges` method runs after any component inputs have changed.\n\nThis step happens _before_ the component's own template is checked. This means that you can update\nthe component's state based on its initial input values.\n\nDuring initialization, the first `ngOnChanges` runs before `ngOnInit`.\n\n#### Inspecting changes\n\nThe `ngOnChanges` method accepts one `SimpleChanges` argument. This object is\na [`Record`](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)\nmapping each component input name to a `SimpleChange` object. Each `SimpleChange` contains the\ninput's previous value, its current value, and a flag for whether this is the first time the input\nhas changed.\n\n```ts\n@Component({\n  /* ... */\n})\nexport class UserProfile {\n  @Input() name: string = '';\n\n  ngOnChanges(changes: SimpleChanges) {\n    for (const inputName in changes) {\n      const inputValues = changes[inputName];\n      console.log(`Previous ${inputName} == ${inputValues.previousValue}`);\n      console.log(`Current ${inputName} == ${inputValues.currentValue}`);\n      console.log(`Is first ${inputName} change == ${inputValues.firstChange}`);\n    }\n  }\n}\n```\n\nIf you provide an `alias` for any input properties, the `SimpleChanges` Record still uses the\nTypeScript property name as a key, rather than the alias.\n\n### ngOnDestroy\n\nThe `ngOnDestroy` method runs once just before a component is destroyed. Angular destroys a\ncomponent when it is no longer shown on the page, such as being hidden by `@if` or upon navigating\nto another page.\n\n#### DestroyRef\n\nAs an alternative to the `ngOnDestroy` method, you can inject an instance of `DestroyRef`. You can\nregister a callback to be invoked upon the component's destruction by calling the `onDestroy` method\nof `DestroyRef`.\n\n```ts\n@Component({\n  /* ... */\n})\nexport class UserProfile {\n  constructor() {\n    inject(DestroyRef).onDestroy(() => {\n      console.log('UserProfile destruction');\n    });\n  }\n}\n```\n\nYou can pass the `DestroyRef` instance to functions or classes outside your component. Use this\npattern if you have other code that should run some cleanup behavior when the component is\ndestroyed.\n\nYou can also use `DestroyRef` to keep setup code close to cleanup code, rather than putting\nall cleanup code in the `ngOnDestroy` method.\n\n### ngDoCheck\n\nThe `ngDoCheck` method runs before every time Angular checks a component's template for changes.\n\nYou can use this lifecycle hook to manually check for state changes outside of Angular's normal\nchange detection, manually updating the component's state.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nDuring initialization, the first `ngDoCheck` runs after `ngOnInit`.\n\n### ngAfterContentInit\n\nThe `ngAfterContentInit` method runs once after all the children nested inside the component (its\n_content_) have been initialized.\n\nYou can use this lifecycle hook to read the results of\n[content queries](guide/components/queries#content-queries). While you can access the initialized\nstate of these queries, attempting to change any state in this method results in an\n[ExpressionChangedAfterItHasBeenCheckedError](errors/NG0100)\n\n### ngAfterContentChecked\n\nThe `ngAfterContentChecked` method runs every time the children nested inside the component (its\n_content_) have been checked for changes.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nWhile you can access the updated state\nof [content queries](guide/components/queries#content-queries) here, attempting to\nchange any state in this method results in\nan [ExpressionChangedAfterItHasBeenCheckedError](errors/NG0100).\n\n### ngAfterViewInit\n\nThe `ngAfterViewInit` method runs once after all the children in the component's template (its\n_view_) have been initialized.\n\nYou can use this lifecycle hook to read the results of\n[view queries](guide/components/queries#view-queries). While you can access the initialized state of\nthese queries, attempting to change any state in this method results in an\n[ExpressionChangedAfterItHasBeenCheckedError](errors/NG0100)\n\n### ngAfterViewChecked\n\nThe `ngAfterViewChecked` method runs every time the children in the component's template (its\n_view_) have been checked for changes.\n\nThis method runs very frequently and can significantly impact your page's performance. Avoid\ndefining this hook whenever possible, only using it when you have no alternative.\n\nWhile you can access the updated state of [view queries](guide/components/queries#view-queries)\nhere, attempting to\nchange any state in this method results in\nan [ExpressionChangedAfterItHasBeenCheckedError](errors/NG0100).\n\n### afterRender and afterNextRender\n\nThe `afterRender` and `afterNextRender` functions let you register a **render callback** to be\ninvoked after Angular has finished rendering _all components_ on the page into the DOM.\n\nThese functions are different from the other lifecycle hooks described in this guide. Rather than a\nclass method, they are standalone functions that accept a callback. The execution of render\ncallbacks are not tied to any specific component instance, but instead an application-wide hook.\n\n`afterRender` and `afterNextRender` must be called in\nan [injection context](guide/di/dependency-injection-context), typically a\ncomponent's constructor.\n\nYou can use render callbacks to perform manual DOM operations.\nSee [Using DOM APIs](guide/components/dom-apis) for guidance on working with the DOM in Angular.\n\nRender callbacks do not run during server-side rendering or during build-time pre-rendering.\n\n#### afterRender phases\n\nWhen using `afterRender` or `afterNextRender`, you can optionally split the work into phases. The\nphase gives you control over the sequencing of DOM operations, letting you sequence _write_\noperations before _read_ operations in order to minimize\n[layout thrashing](https://web.dev/avoid-large-complex-layouts-and-layout-thrashing). In order to\ncommunicate across phases, a phase function may return a result value that can be accessed in the\nnext phase.\n\n```ts\nimport {Component, ElementRef, afterNextRender} from '@angular/core';\n\n@Component({...})\nexport class UserProfile {\n  private prevPadding = 0;\n  private elementHeight = 0;\n\n  constructor() {\n    private elementRef = inject(ElementRef);\n    const nativeElement = elementRef.nativeElement;\n\n    afterNextRender({\n      // Use the `Write` phase to write to a geometric property.\n      write: () => {\n        const padding = computePadding();\n        const changed = padding !== this.prevPadding;\n        if (changed) {\n          nativeElement.style.padding = padding;\n        }\n        return changed; // Communicate whether anything changed to the read phase.\n      },\n\n      // Use the `Read` phase to read geometric properties after all writes have occurred.\n      read: (didWrite) => {\n        if (didWrite) {\n          this.elementHeight = nativeElement.getBoundingClientRect().height;\n        }\n      }\n    });\n  }\n}\n```\n\nThere are four phases, run in the following order:\n\n| Phase            | Description                                                                                                                                                                                           |\n| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `earlyRead`      | Use this phase to read any layout-affecting DOM properties and styles that are strictly necessary for subsequent calculation. Avoid this phase if possible, preferring the `write` and `read` phases. |\n| `mixedReadWrite` | Default phase. Use for any operations need to both read and write layout-affecting properties and styles. Avoid this phase if possible, preferring the explicit `write` and `read` phases.            |\n| `write`          | Use this phase to write layout-affecting DOM properties and styles.                                                                                                                                   |\n| `read`           | Use this phase to read any layout-affecting DOM properties.                                                                                                                                           |\n\n## Lifecycle interfaces\n\nAngular provides a TypeScript interface for each lifecycle method. You can optionally import\nand `implement` these interfaces to ensure that your implementation does not have any typos or\nmisspellings.\n\nEach interface has the same name as the corresponding method without the `ng` prefix. For example,\nthe interface for `ngOnInit` is `OnInit`.\n\n```ts\n@Component({\n  /* ... */\n})\nexport class UserProfile implements OnInit {\n  ngOnInit() {\n    /* ... */\n  }\n}\n```\n\n## Execution order\n\nThe following diagrams show the execution order of Angular's lifecycle hooks.\n\n### During initialization\n\n```mermaid\ngraph TD;\nid[constructor]-->CHANGE;\nsubgraph CHANGE [Change detection]\ndirection TB\nngOnChanges-->ngOnInit;\nngOnInit-->ngDoCheck;\nngDoCheck-->ngAfterContentInit;\nngDoCheck-->ngAfterViewInit\nngAfterContentInit-->ngAfterContentChecked\nngAfterViewInit-->ngAfterViewChecked\nend\nCHANGE--Rendering-->afterRender\n```\n\n### Subsequent updates\n\n```mermaid\ngraph TD;\nsubgraph CHANGE [Change detection]\ndirection TB\nngOnChanges-->ngDoCheck\nngDoCheck-->ngAfterContentChecked;\nngDoCheck-->ngAfterViewChecked\nend\nCHANGE--Rendering-->afterRender\n```\n\n### Ordering with directives\n\nWhen you put one or more directives on the same element as a component, either in a template or with\nthe `hostDirectives` property, the framework does not guarantee any ordering of a given lifecycle\nhook between the component and the directives on a single element. Never depend on an observed\nordering, as this may change in later versions of Angular.\n\n\n\n================================================\n",
    "endLine": 4530
  },
  {
    "id": 20,
    "file": "outputs",
    "fullFileName": "adev/src/content/guide/components/outputs.md",
    "startLine": 4534,
    "content": "# Custom events with outputs\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nAngular components can define custom events by assigning a property to the `output` function:\n\n<docs-code language=\"ts\" highlight=\"3\">\n@Component({/*...*/})\nexport class ExpandablePanel {\n  panelClosed = output<void>();\n}\n</docs-code>\n\n```angular-html\n<expandable-panel (panelClosed)=\"savePanelState()\" />\n```\n\nThe `output` function returns an `OutputEmitterRef`. You can emit an event by calling the `emit` method on the `OutputEmitterRef`:\n\n<docs-code language=\"ts\" highlight=\"\">\n  this.panelClosed.emit();\n</docs-code>\n\nAngular refers to properties initialized with the `output` function as **outputs**. You can use outputs to raise custom events, similar to native browser events like `click`.\n\n**Angular custom events do not bubble up the DOM**.\n\n**Output names are case-sensitive.**\n\nWhen extending a component class, **outputs are inherited by the child class.**\n\nThe `output` function has special meaning to the Angular compiler. **You can exclusively call `output` in component and directive property initializers.**\n\n## Emitting event data\n\nYou can pass event data when calling `emit`:\n\n<docs-code language=\"ts\" highlight=\"\">\n// You can emit primitive values.\nthis.valueChanged.emit(7);\n\n// You can emit custom event objects\nthis.thumbDropped.emit({\n  pointerX: 123,\n  pointerY: 456,\n})\n</docs-code>\n\nWhen defining an event listener in a template, you can access the event data from the `$event` variable:\n\n```angular-html\n<custom-slider (valueChanged)=\"logValue($event)\" />\n```\n\n## Customizing output names\n\nThe `output` function accepts a parameter that lets you specify a different name for the event in a template:\n\n<docs-code language=\"ts\" highlight=\"\">\n@Component({/*...*/})\nexport class CustomSlider {\n  changed = output({alias: 'valueChanged'});\n}\n</docs-code>\n\n```angular-html\n<custom-slider (valueChanged)=\"saveVolume()\" />\n```\n\nThis alias does not affect usage of the property in TypeScript code.\n\nWhile you should generally avoid aliasing outputs for components, this feature can be useful for renaming properties while preserving an alias for the original name or for avoiding collisions with the name of native DOM events.\n\n## Subscribing to outputs programmatically\n\nWhen creating a component dynamically, you can programmatically subscribe to output events\nfrom the component instance. The `OutputRef` type includes a `subscribe` method:\n\n```ts\nconst someComponentRef: ComponentRef<SomeComponent> = viewContainerRef.createComponent(/*...*/);\n\nsomeComponentRef.instance.someEventProperty.subscribe(eventData => {\n  console.log(eventData);\n});\n```\n\nAngular automatically cleans up event subscriptions when it destroys components with subscribers. Alternatively, you can manually unsubscribe from an event. The `subscribe` function returns an `OutputRefSubscription` with an `unsubscribe` method:\n\n```typescript\nconst eventSubscription = someComponent.someEventProperty.subscribe(eventData => {\n  console.log(eventData);\n});\n\n// ...\n\neventSubscription.unsubscribe();\n```\n\n## Choosing event names\n\nAvoid choosing output names that collide with events on DOM elements like HTMLElement. Name collisions introduce confusion about whether the bound property belongs to the component or the DOM element.\n\nAvoid adding prefixes for component outputs like you would with component selectors. Since a given element can only host one component, any custom properties can be assumed to belong to the component.\n\nAlways use [camelCase](https://en.wikipedia.org/wiki/Camel_case) output names. Avoid prefixing output names with \"on\".\n\n## Using outputs with RxJS\n\nSee [RxJS interop with component and directive outputs](ecosystem/rxjs-interop/output-interop) for details on interoperability between outputs and RxJS.\n\n## Declaring outputs with the `@Output` decorator\n\nTIP: While the Angular team recommends using the `output` function for new projects, the\noriginal decorator-based `@Output` API remains fully supported.\n\nYou can alternatively define custom events by assigning a property to a new `EventEmitter` and adding the `@Output` decorator:\n\n<docs-code language=\"ts\" highlight=\"\">\n@Component({/*...*/})\nexport class ExpandablePanel {\n  @Output() panelClosed = new EventEmitter<void>();\n}\n</docs-code>\n\nYou can emit an event by calling the `emit` method on the `EventEmitter`.\n\n### Aliases with the `@Output` decorator\n\nThe `@Output` decorator accepts a parameter that lets you specify a different name for the event in a template:\n\n<docs-code language=\"ts\" highlight=\"\">\n@Component({/*...*/})\nexport class CustomSlider {\n  @Output('valueChanged') changed = new EventEmitter<number>();\n}\n</docs-code>\n\n```angular-html\n<custom-slider (valueChanged)=\"saveVolume()\" />\n```\n\nThis alias does not affect usage of the property in TypeScript code.\n\n## Specify outputs in the `@Component` decorator\n\nIn addition to the `@Output` decorator, you can also specify a component's outputs with the `outputs` property in the `@Component` decorator. This can be useful when a component inherits a property from a base class:\n\n<docs-code language=\"ts\" highlight=\"\">\n// `CustomSlider` inherits the `valueChanged` property from `BaseSlider`.\n@Component({\n  /*...*/\n  outputs: ['valueChanged'],\n})\nexport class CustomSlider extends BaseSlider {}\n</docs-code>\n\nYou can additionally specify an output alias in the `outputs` list by putting the alias after a colon in the string:\n\n<docs-code language=\"ts\" highlight=\"\">\n// `CustomSlider` inherits the `valueChanged` property from `BaseSlider`.\n@Component({\n  /*...*/\n  outputs: ['valueChanged: volumeChanged'],\n})\nexport class CustomSlider extends BaseSlider {}\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 4702
  },
  {
    "id": 21,
    "file": "programmatic-rendering",
    "fullFileName": "adev/src/content/guide/components/programmatic-rendering.md",
    "startLine": 4706,
    "content": "# Programmatically rendering components\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nIn addition to using a component directly in a template, you can also dynamically render components.\nThere are two main ways to dynamically render a component: in a template with `NgComponentOutlet`,\nor in your TypeScript code with `ViewContainerRef`.\n\n## Using NgComponentOutlet\n\n`NgComponentOutlet` is a structural directive that dynamically renders a given component in a\ntemplate.\n\n```angular-ts\n@Component({ ... })\nexport class AdminBio { /* ... */ }\n\n@Component({ ... })\nexport class StandardBio { /* ... */ }\n\n@Component({\n  ...,\n  template: `\n    <p>Profile for {{user.name}}</p>\n    <ng-container *ngComponentOutlet=\"getBioComponent()\" /> `\n})\nexport class CustomDialog {\n  @Input() user: User;\n\n  getBioComponent() {\n    return this.user.isAdmin ? AdminBio : StandardBio;\n  }\n}\n```\n\nSee the [NgComponentOutlet API reference](api/common/NgComponentOutlet) for more information on the\ndirective's capabilities.\n\n## Using ViewContainerRef\n\nA **view container** is a node in Angular's component tree that can contain content. Any component\nor directive can inject `ViewContainerRef` to get a reference to a view container corresponding to\nthat component or directive's location in the DOM.\n\nYou can use the `createComponent`method on `ViewContainerRef` to dynamically create and render a\ncomponent. When you create a new component with a `ViewContainerRef`, Angular appends it into the\nDOM as the next sibling of the component or directive that injected the `ViewContainerRef`.\n\n```angular-ts\n@Component({\n  selector: 'leaf-content',\n  template: `\n    This is the leaf content\n  `,\n})\nexport class LeafContent {}\n\n@Component({\n  selector: 'outer-container',\n  template: `\n    <p>This is the start of the outer container</p>\n    <inner-item />\n    <p>This is the end of the outer container</p>\n  `,\n})\nexport class OuterContainer {}\n\n@Component({\n  selector: 'inner-item',\n  template: `\n    <button (click)=\"loadContent()\">Load content</button>\n  `,\n})\nexport class InnerItem {\n  private viewContainer = inject(ViewContainerRef);\n\n  loadContent() {\n    this.viewContainer.createComponent(LeafContent);\n  }\n}\n```\n\nIn the example above, clicking the \"Load content\" button results in the following DOM structure\n\n```angular-html\n<outer-container>\n  <p>This is the start of the outer container</p>\n  <inner-item>\n    <button>Load content</button>\n  </inner-item>\n  <leaf-content>This is the leaf content</leaf-content>\n  <p>This is the end of the outer container</p>\n</outer-container>\n```\n\n## Lazy-loading components\n\nYou can use both of the approaches described above, `NgComponentOutlet` and `ViewContainerRef`, to\nrender components that are lazy-loaded with a standard\nJavaScript [dynamic import](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/import).\n\n```angular-ts\n@Component({\n  ...,\n  template: `\n    <section>\n      <h2>Basic settings</h2>\n      <basic-settings />\n    </section>\n    <section>\n      <h2>Advanced settings</h2>\n      <button (click)=\"loadAdvanced()\" *ngIf=\"!advancedSettings\">\n        Load advanced settings\n      </button>\n      <ng-container *ngComponentOutlet=\"advancedSettings\" />\n    </section>\n  `\n})\nexport class AdminSettings {\n  advancedSettings: {new(): AdvancedSettings} | undefined;\n\n  async loadAdvanced() {\n    const { AdvancedSettings } = await import('path/to/advanced_settings.js');\n    this.advancedSettings = AdvancedSettings;\n  }\n}\n```\n\nThe example above loads and displays the `AdvancedSettings` upon receiving a button click.\n\n\n\n================================================\n",
    "endLine": 4837
  },
  {
    "id": 22,
    "file": "queries",
    "fullFileName": "adev/src/content/guide/components/queries.md",
    "startLine": 4841,
    "content": "# Referencing component children with queries\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nA component can define **queries** that find child elements and read values from their injectors.\n\nDevelopers most commonly use queries to retrieve references to child components, directives, DOM elements, and more.\n\nAll query functions return signals that reflect the most up-to-date results. You can read the\nresult by calling the signal function, including in reactive contexts like `computed` and `effect`.\n\nThere are two categories of query: **view queries** and **content queries.**\n\n## View queries\n\nView queries retrieve results from the elements in the component's _view_ — the elements defined in the component's own template. You can query for a single result with the `viewChild` function.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 15]\">\n@Component({\n  selector: 'custom-card-header',\n  /*...*/\n})\nexport class CustomCardHeader {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-card',\n  template: '<custom-card-header>Visit sunny California!</custom-card-header>',\n})\nexport class CustomCard {\n  header = viewChild(CustomCardHeader);\n  headerText = computed(() => this.header()?.text);\n}\n</docs-code>\n\nIn this example, the `CustomCard` component queries for a child `CustomCardHeader` and uses the result in a `computed`.\n\nIf the query does not find a result, its value is `undefined`. This may occur if the target element is hidden by `@if`. Angular keeps the result of `viewChild` up to date as your application state changes.\n\nYou can also query for multiple results with the `viewChildren` function.\n\n<docs-code language=\"angular-ts\" highlight=\"[17, 19, 20, 21, 22, 23]\">\n@Component({\n  selector: 'custom-card-action',\n  /*...*/\n})\nexport class CustomCardAction {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-card',\n  template: `\n    <custom-card-action>Save</custom-card-action>\n    <custom-card-action>Cancel</custom-card-action>\n  `,\n})\nexport class CustomCard {\n  actions = viewChildren(CustomCardAction);\n  actionsTexts = computed(() => this.actions().map(action => action.text);\n}\n</docs-code>\n\n`viewChildren` creates a signal with an `Array` of the query results.\n\n**Queries never pierce through component boundaries.** View queries can only retrieve results from the component's template.\n\n## Content queries\n\nContent queries retrieve results from the elements in the component's _content_— the elements nested inside the component in the template where it's used. You can query for a single result with the `contentChild` function.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 15]\">\n@Component({\n  selector: 'custom-toggle',\n  /*...*/\n})\nexport class CustomToggle {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-expando',\n  /*...*/\n})\nexport class CustomExpando {\n  toggle = contentChild(CustomToggle);\n  toggleText = computed(() => this.toggle()?.text);\n}\n\n@Component({ \n  /* ... */\n  // CustomToggle is used inside CustomExpando as content.  \n  template: `\n    <custom-expando>\n      <custom-toggle>Show</custom-toggle>\n    </custom-expando>\n  `\n})\nexport class UserProfile { }\n</docs-code>\n\nIn this example, the `CustomExpando` component queries for a child `CustomToggle` and accesses the result in a `computed`.\n\nIf the query does not find a result, its value is `undefined`. This may occur if the target element is absent or hidden by `@if`. Angular keeps the result of `contentChild` up to date as your application state changes.\n\nBy default, content queries find only _direct_ children of the component and do not traverse into descendants.\n\nYou can also query for multiple results with the `contentChildren` function.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 16, 17, 18, 19, 20]\">\n@Component({\n  selector: 'custom-menu-item',\n  /*...*/\n})\nexport class CustomMenuItem {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-menu',\n  /*...*/\n})\nexport class CustomMenu {\n  items = contentChildren(CustomMenuItem);\n  itemTexts = computed(() => this.items().map(item => item.text));\n}\n\n@Component({\n  selector: 'user-profile',\n  template: `\n    <custom-menu>\n      <custom-menu-item>Cheese</custom-menu-item>\n      <custom-menu-item>Tomato</custom-menu-item>\n    </custom-menu>\n  `\n})\nexport class UserProfile { }\n</docs-code>\n\n`contentChildren` creates a signal with an `Array` of the query results.\n\n**Queries never pierce through component boundaries.** Content queries can only retrieve results from the same template as the component itself.\n\n## Required queries\n\nIf a child query (`viewChild` or `contentChild`) does not find a result, its value is `undefined`. This may occur if the target element is hidden by a control flow statement like `@if` or `@for`. Because of this, the child queries return a signal that include `undefined` in their value type.\n\nIn some cases, especially with `viewChild`, you know with certainty that a specific child is always available. In other cases, you may want to strictly enforce that a specific child is present. For these cases, you can use a *required query*.\n\n```angular-ts\n@Component({/* ... */})\nexport class CustomCard {\n  header = viewChild.required(CustomCardHeader);\n  body = contentChild.required(CustomCardBody);\n}\n```\n\nIf a required query does not find a matching result, Angular reports an error. Because this guarantees that a result is available, required queries do not automatically include `undefined` in the signal's value type.\n\n## Query locators\n\nThis first parameter for each query decorator is its **locator**.\n\nMost of the time, you want to use a component or directive as your locator.\n\nYou can alternatively specify a string locator corresponding to\na [template reference variable](guide/templates/variables#template-reference-variables).\n\n```angular-ts\n@Component({\n  /*...*/\n  template: `\n    <button #save>Save</button>\n    <button #cancel>Cancel</button>\n  `\n})\nexport class ActionBar {\n  saveButton = viewChild<ElementRef<HTMLButtonElement>>('save');\n}\n```\n\nIf more than one element defines the same template reference variable, the query retrieves the first matching element.\n\nAngular does not support CSS selectors as query locators.\n\n### Queries and the injector tree\n\nTIP: See [Dependency Injection](guide/di) for background on providers and Angular's injection tree.\n\nFor more advanced cases, you can use any `ProviderToken` as a locator. This lets you locate elements based on component and directive providers.\n\n```angular-ts\nconst SUB_ITEM = new InjectionToken<string>('sub-item');\n\n@Component({\n  /*...*/\n  providers: [{provide: SUB_ITEM, useValue: 'special-item'}],\n})\nexport class SpecialItem { }\n\n@Component({/*...*/})\nexport class CustomList {\n  subItemType = contentChild(SUB_ITEM);\n}\n```\n\nThe above example uses an `InjectionToken` as a locator, but you can use any `ProviderToken` to locate specific elements.\n\n## Query options\n\nAll query functions accept an options object as a second parameter. These options control how the query finds its results.\n\n### Reading specific values from an element's injector\n\nBy default, the query locator indicates both the element you're searching for and the value retrieved. You can alternatively specify the `read` option to retrieve a different value from the element matched by the locator.\n\n```ts\n@Component({/*...*/})\nexport class CustomExpando {\n  toggle = contentChild(ExpandoContent, {read: TemplateRef});\n}\n```\n\nThe above example, locates an element with the directive `ExpandoContent` and retrieves\nthe `TemplateRef` associated with that element.\n\nDevelopers most commonly use `read` to retrieve `ElementRef` and `TemplateRef`.\n\n### Content descendants\n\nBy default, content queries find only _direct_ children of the component and do not traverse into descendants.\n\n<docs-code language=\"angular-ts\" highlight=\"[13, 14, 15, 16]\">\n@Component({\n  selector: 'custom-expando',\n  /*...*/\n})\nexport class CustomExpando {\n  toggle = contentChild(CustomToggle);\n}\n\n@Component({\n  selector: 'user-profile',\n  template: `\n    <custom-expando>\n      <some-other-component>\n        <!-- custom-toggle will not be found! -->\n        <custom-toggle>Show</custom-toggle>\n      </some-other-component>\n    </custom-expando>\n  `\n})\nexport class UserProfile { }\n</docs-code>\n\nIn the example above, `CustomExpando` cannot find `<custom-toggle>` because it is not a direct child of `<custom-expando>`. By setting `descendants: true`, you configure the query to traverse all descendants in the same template. Queries, however, _never_ pierce into components to traverse elements in other templates.\n\nView queries do not have this option because they _always_ traverse into descendants.\n\n## Decorator-based queries\nTIP: While the Angular team recommends using the signal-based query function for new projects, the\noriginal decorator-based query APIs remain fully supported.\n\nYou can alternatively declare queries by adding the corresponding decorator to a property. Decorator-based queries behave the same way as signal-based queries except as described below.\n\n### View queries\n\nYou can query for a single result with the `@ViewChild` decorator.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 16, 17, 18]\">\n@Component({\n  selector: 'custom-card-header',\n  /*...*/\n})\nexport class CustomCardHeader {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-card',\n  template: '<custom-card-header>Visit sunny California!</custom-card-header>',\n})\nexport class CustomCard {\n  @ViewChild(CustomCardHeader) header: CustomCardHeader;\n\n  ngAfterViewInit() {\n    console.log(this.header.text);\n  }\n}\n</docs-code>\n\nIn this example, the `CustomCard` component queries for a child `CustomCardHeader` and accesses the result in `ngAfterViewInit`.\n\nAngular keeps the result of `@ViewChild` up to date as your application state changes.\n\n**View query results become available in the `ngAfterViewInit` lifecycle method**. Before this point, the value is `undefined`. See the [Lifecycle](guide/components/lifecycle) section for details on the component lifecycle.\n\nYou can also query for multiple results with the `@ViewChildren` decorator.\n\n<docs-code language=\"angular-ts\" highlight=\"[17, 19, 20, 21, 22, 23]\">\n@Component({\n  selector: 'custom-card-action',\n  /*...*/\n})\nexport class CustomCardAction {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-card',\n  template: `\n    <custom-card-action>Save</custom-card-action>\n    <custom-card-action>Cancel</custom-card-action>\n  `,\n})\nexport class CustomCard {\n  @ViewChildren(CustomCardAction) actions: QueryList<CustomCardAction>;\n\n  ngAfterViewInit() {\n    this.actions.forEach(action => {\n      console.log(action.text);\n    });\n  }\n}\n</docs-code>\n\n`@ViewChildren` creates a `QueryList` object that contains the query results. You can subscribe to changes to the query results over time via the `changes` property.\n\n### Content queries\n\nYou can query for a single result with the `@ContentChild` decorator.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 16, 17, 18, 25]\">\n@Component({\n  selector: 'custom-toggle',\n  /*...*/\n})\nexport class CustomToggle {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-expando',\n  /*...*/\n})\nexport class CustomExpando {\n  @ContentChild(CustomToggle) toggle: CustomToggle;\n\n  ngAfterContentInit() {\n    console.log(this.toggle.text);\n  }\n}\n\n@Component({\n  selector: 'user-profile',\n  template: `\n    <custom-expando>\n      <custom-toggle>Show</custom-toggle>\n    </custom-expando>\n  `\n})\nexport class UserProfile { }\n</docs-code>\n\nIn this example, the `CustomExpando` component queries for a child `CustomToggle` and accesses the result in `ngAfterContentInit`.\n\nAngular keeps the result of `@ContentChild` up to date as your application state changes.\n\n**Content query results become available in the `ngAfterContentInit` lifecycle method**. Before this point, the value is `undefined`. See the [Lifecycle](guide/components/lifecycle) section for details on the component lifecycle.\n\nYou can also query for multiple results with the `@ContentChildren` decorator.\n\n<docs-code language=\"angular-ts\" highlight=\"[14, 16, 17, 18, 19, 20]\">\n@Component({\n  selector: 'custom-menu-item',\n  /*...*/\n})\nexport class CustomMenuItem {\n  text: string;\n}\n\n@Component({\n  selector: 'custom-menu',\n  /*...*/\n})\nexport class CustomMenu {\n  @ContentChildren(CustomMenuItem) items: QueryList<CustomMenuItem>;\n\n  ngAfterContentInit() {\n    this.items.forEach(item => {\n      console.log(item.text);\n    });\n  }\n}\n\n@Component({\n  selector: 'user-profile',\n  template: `\n    <custom-menu>\n      <custom-menu-item>Cheese</custom-menu-item>\n      <custom-menu-item>Tomato</custom-menu-item>\n    </custom-menu>\n  `\n})\nexport class UserProfile { }\n</docs-code>\n\n`@ContentChildren` creates a `QueryList` object that contains the query results. You can subscribe to changes to the query results over time via the `changes` property.\n\n### Decorator-based query options\n\nAll query decorators accept an options object as a second parameter. These options work the same way as signal-based queries except where described below.\n\n### Static queries\n\n`@ViewChild` and `@ContentChild` decorators accept the `static` option.\n\n```angular-ts\n@Component({\n  selector: 'custom-card',\n  template: '<custom-card-header>Visit sunny California!</custom-card-header>',\n})\nexport class CustomCard {\n  @ViewChild(CustomCardHeader, {static: true}) header: CustomCardHeader;\n\n  ngOnInit() {\n    console.log(this.header.text);\n  }\n}\n```\n\nBy setting `static: true`, you guarantee to Angular that the target of this query is _always_ present and is not conditionally rendered. This makes the result available earlier, in the `ngOnInit` lifecycle method.\n\nStatic query results do not update after initialization.\n\nThe `static` option is not available for `@ViewChildren` and `@ContentChildren` queries.\n\n### Using QueryList\n\n`@ViewChildren` and `@ContentChildren` both provide a `QueryList` object that contains a list of results.\n\n`QueryList` offers a number of convenience APIs for working with results in an array-like manner, such as `map`, `reduce`, and `forEach`. You can get an array of the current results by calling `toArray`.\n\nYou can subscribe to the `changes` property to do something any time the results change.\n\n## Common query pitfalls\n\nWhen using queries, common pitfalls can make your code harder to understand and maintain.\n\nAlways maintain a single source of truth for state shared between multiple components. This avoids scenarios where repeated state in different components becomes out of sync.\n\nAvoid directly writing state to child components. This pattern can lead to brittle code that is hard to understand and is prone to [ExpressionChangedAfterItHasBeenChecked](errors/NG0100) errors.\n\nNever directly write state to parent or ancestor components. This pattern can lead to brittle code that is hard to understand and is prone to [ExpressionChangedAfterItHasBeenChecked](errors/NG0100) errors.\n\n\n\n================================================\n",
    "endLine": 5298
  },
  {
    "id": 23,
    "file": "selectors",
    "fullFileName": "adev/src/content/guide/components/selectors.md",
    "startLine": 5302,
    "content": "# Component selectors\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nEvery component defines\na [CSS selector](https://developer.mozilla.org/docs/Web/CSS/CSS_selectors) that determines how\nthe component is used:\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: 'profile-photo',\n  ...\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nYou use a component by creating a matching HTML element in the templates of _other_ components:\n\n<docs-code language=\"angular-ts\" highlight=\"[3]\">\n@Component({\n  template: `\n    <profile-photo />\n    <button>Upload a new profile photo</button>`,\n  ...,\n})\nexport class UserProfile { }\n</docs-code>\n\n**Angular matches selectors statically at compile-time**. Changing the DOM at run-time, either via\nAngular bindings or with DOM APIs, does not affect the components rendered.\n\n**An element can match exactly one component selector.** If multiple component selectors match a\nsingle element, Angular reports an error.\n\n**Component selectors are case-sensitive.**\n\n## Types of selectors\n\nAngular supports a limited subset\nof [basic CSS selector types](https://developer.mozilla.org/docs/Web/CSS/CSS_Selectors) in\ncomponent selectors:\n\n| **Selector type**  | **Description**                                                                                                 | **Examples**                  |\n| ------------------ | --------------------------------------------------------------------------------------------------------------- | ----------------------------- |\n| Type selector      | Matches elements based on their HTML tag name, or node name.                                                    | `profile-photo`               |\n| Attribute selector | Matches elements based on the presence of an HTML attribute and, optionally, an exact value for that attribute. | `[dropzone]` `[type=\"reset\"]` |\n| Class selector     | Matches elements based on the presence of a CSS class.                                                          | `.menu-item`                  |\n\nFor attribute values, Angular supports matching an exact attribute value with the equals (`=`)\noperator. Angular does not support other attribute value operators.\n\nAngular component selectors do not support combinators, including\nthe [descendant combinator](https://developer.mozilla.org/docs/Web/CSS/Descendant_combinator)\nor [child combinator](https://developer.mozilla.org/docs/Web/CSS/Child_combinator).\n\nAngular component selectors do not support\nspecifying [namespaces](https://developer.mozilla.org/docs/Web/SVG/Namespaces_Crash_Course).\n\n### The `:not` pseudo-class\n\nAngular supports [the `:not` pseudo-class](https://developer.mozilla.org/docs/Web/CSS/:not).\nYou can append this pseudo-class to any other selector to narrow which elements a component's\nselector matches. For example, you could define a `[dropzone]` attribute selector and prevent\nmatching `textarea` elements:\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: '[dropzone]:not(textarea)',\n  ...\n})\nexport class DropZone { }\n</docs-code>\n\nAngular does not support any other pseudo-classes or pseudo-elements in component selectors.\n\n### Combining selectors\n\nYou can combine multiple selectors by concatenating them. For example, you can match `<button>`\nelements that specify `type=\"reset\"`:\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: 'button[type=\"reset\"]',\n  ...\n})\nexport class ResetButton { }\n</docs-code>\n\nYou can also define multiple selectors with a comma-separated list:\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: 'drop-zone, [dropzone]',\n  ...\n})\nexport class DropZone { }\n</docs-code>\n\nAngular creates a component for each element that matches _any_ of the selectors in the list.\n\n## Choosing a selector\n\nThe vast majority of components should use a custom element name as their selector. All custom\nelement names should include a hyphen as described\nby [the HTML specification](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name).\nBy default, Angular reports an error if it encounters a custom tag name that does not match any\navailable components, preventing bugs due to mistyped component names.\n\nSee [Advanced component configuration](guide/components/advanced-configuration) for details on\nusing [native custom elements](https://developer.mozilla.org/docs/Web/Web_Components) in\nAngular templates.\n\n### Selector prefixes\n\nThe Angular team recommends using a short, consistent prefix for all the custom components\ndefined inside your project. For example, if you were to build YouTube with Angular, you might\nprefix your components with `yt-`, with components like `yt-menu`, `yt-player`, etc. Namespacing\nyour selectors like this makes it immediately clear where a particular component comes from. By\ndefault, the Angular CLI uses `app-`.\n\nAngular uses the `ng` selector prefix for its own framework APIs. Never use `ng` as a selector\nprefix for your own custom components.\n\n### When to use an attribute selector\n\nYou should consider an attribute selector when you want to create a component on a standard native\nelement. For example, if you want to create a custom button component, you can take advantage of the\nstandard `<button>` element by using an attribute selector:\n\n<docs-code language=\"angular-ts\" highlight=\"[2]\">\n@Component({\n  selector: 'button[yt-upload]',\n   ...\n})\nexport class YouTubeUploadButton { }\n</docs-code>\n\nThis approach allows consumers of the component to directly use all the element's standard APIs\nwithout extra work. This is especially valuable for ARIA attributes such as `aria-label`.\n\nAngular does not report errors when it encounters custom attributes that don't match an available\ncomponent. When using components with attribute selectors, consumers may forget to import the\ncomponent or its NgModule, resulting in the component not rendering.\nSee [Importing and using components](guide/components/importing) for more information.\n\nComponents that define attribute selectors should use lowercase, dash-case attributes. You can\nfollow the same prefixing recommendation described above.\n\n\n\n================================================\n",
    "endLine": 5451
  },
  {
    "id": 24,
    "file": "styling",
    "fullFileName": "adev/src/content/guide/components/styling.md",
    "startLine": 5455,
    "content": "# Styling components\n\nTIP: This guide assumes you've already read the [Essentials Guide](essentials). Read that first if you're new to Angular.\n\nComponents can optionally include CSS styles that apply to that component's DOM:\n\n<docs-code language=\"angular-ts\" highlight=\"[4]\">\n@Component({\n  selector: 'profile-photo',\n  template: `<img src=\"profile-photo.jpg\" alt=\"Your profile photo\">`,\n  styles: ` img { border-radius: 50%; } `,\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nYou can also choose to write your styles in separate files:\n\n<docs-code language=\"angular-ts\" highlight=\"[4]\">\n@Component({\n  selector: 'profile-photo',\n  templateUrl: 'profile-photo.html',\n  styleUrl: 'profile-photo.css',\n})\nexport class ProfilePhoto { }\n</docs-code>\n\nWhen Angular compiles your component, these styles are emitted with your component's JavaScript\noutput. This means that component styles participate in the JavaScript module system. When you\nrender an Angular component, the framework automatically includes its associated styles, even when\nlazy-loading a component.\n\nAngular works with any tool that outputs CSS,\nincluding [Sass](https://sass-lang.com), [less](https://lesscss.org),\nand [stylus](https://stylus-lang.com).\n\n## Style scoping\n\nEvery component has a **view encapsulation** setting that determines how the framework scopes a\ncomponent's styles. There are three view encapsulation modes: `Emulated`, `ShadowDom`, and `None`.\nYou can specify the mode in the `@Component` decorator:\n\n<docs-code language=\"angular-ts\" highlight=\"[3]\">\n@Component({\n  ...,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class ProfilePhoto { }\n</docs-code>\n\n### ViewEncapsulation.Emulated\n\nBy default, Angular uses emulated encapsulation so that a component's styles only apply to elements\ndefined in that component's template. In this mode, the framework generates a unique HTML attribute\nfor each component instance, adds that attribute to elements in the component's template, and\ninserts that attribute into the CSS selectors defined in your component's styles.\n\nThis mode ensures that a component's styles do not leak out and affect other components. However,\nglobal styles defined outside of a component may still affect elements inside a component with\nemulated encapsulation.\n\nIn emulated mode, Angular supports\nthe [`:host`](https://developer.mozilla.org/docs/Web/CSS/:host)\nand [`:host-context()`](https://developer.mozilla.org/docs/Web/CSS/:host-context) pseudo\nclasses without\nusing [Shadow DOM](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM).\nDuring compilation, the framework transforms these pseudo classes into attributes so it doesn't\ncomply with these native pseudo classes' rules at runtime (e.g. browser compatibility, specificity). Angular's\nemulated encapsulation mode does not support any other pseudo classes related to Shadow DOM, such\nas `::shadow` or `::part`.\n\n#### `::ng-deep`\n\nAngular's emulated encapsulation mode supports a custom pseudo class, `::ng-deep`. Applying this\npseudo class to a CSS rule disables encapsulation for that rule, effectively turning it into a\nglobal style. **The Angular team strongly discourages new use of `::ng-deep`**. These APIs remain\nexclusively for backwards compatibility.\n\n### ViewEncapsulation.ShadowDom\n\nThis mode scopes styles within a component by\nusing [the web standard Shadow DOM API](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM).\nWhen enabling this mode, Angular attaches a shadow root to the component's host element and renders\nthe component's template and styles into the corresponding shadow tree.\n\nThis mode strictly guarantees that _only_ that component's styles apply to elements in the\ncomponent's template. Global styles cannot affect elements in a shadow tree and styles inside the\nshadow tree cannot affect elements outside of that shadow tree.\n\nEnabling `ShadowDom` encapsulation, however, impacts more than style scoping. Rendering the\ncomponent in a shadow tree affects event propagation, interaction\nwith [the `<slot>` API](https://developer.mozilla.org/docs/Web/Web_Components/Using_templates_and_slots),\nand how browser developer tools show elements. Always understand the full implications of using\nShadow DOM in your application before enabling this option.\n\n### ViewEncapsulation.None\n\nThis mode disables all style encapsulation for the component. Any styles associated with the\ncomponent behave as global styles.\n\nNOTE: In `Emulated` and `ShadowDom` modes, Angular doesn't 100% guarantee that your component's styles will always override styles coming from outside it.\nIt is assumed that these styles have the same specificity as your component's styles in case of collision.\n\n## Defining styles in templates\n\nYou can use the `<style>` element in a component's template to define additional styles. The\ncomponent's view encapsulation mode applies to styles defined this way.\n\nAngular does not support bindings inside of style elements.\n\n## Referencing external style files\n\nComponent templates can\nuse [the `<link>` element](https://developer.mozilla.org/docs/Web/HTML/Element/link) to\nreference CSS files. Additionally, your CSS may\nuse [the `@import`at-rule](https://developer.mozilla.org/docs/Web/CSS/@import) to reference\nCSS files. Angular treats these references as _external_ styles. External styles are not affected by\nemulated view encapsulation.\n\n\n\n================================================\nFILE: adev/src/content/guide/di/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"di\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:dependency_injection.svg\",\n        \"//adev/src/content/examples\",\n    ],\n    mermaid_blocks = True,\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 5594
  },
  {
    "id": 25,
    "file": "creating-injectable-service",
    "fullFileName": "adev/src/content/guide/di/creating-injectable-service.md",
    "startLine": 5598,
    "content": "# Creating an injectable service\n\nService is a broad category encompassing any value, function, or feature that an application needs.\nA service is typically a class with a narrow, well-defined purpose.\nA component is one type of class that can use DI.\n\nAngular distinguishes components from services to increase modularity and reusability.\nBy separating a component's view-related features from other kinds of processing, you can make your component classes lean and efficient.\n\nIdeally, a component's job is to enable the user experience and nothing more.\nA component should present properties and methods for data binding, to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model).\n\nA component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console.\nBy defining such processing tasks in an injectable service class, you make those tasks available to any component.\nYou can also make your application more adaptable by configuring different providers of the same kind of service, as appropriate in different circumstances.\n\nAngular does not enforce these principles.\nAngular helps you follow these principles by making it easy to factor your application logic into services and make those services available to components through DI.\n\n## Service examples\n\nHere's an example of a service class that logs to the browser console:\n\n<docs-code header=\"src/app/logger.service.ts (class)\" language=\"typescript\">\nexport class Logger {\n  log(msg: unknown) { console.log(msg); }\n  error(msg: unknown) { console.error(msg); }\n  warn(msg: unknown) { console.warn(msg); }\n}\n</docs-code>\n\nServices can depend on other services.\nFor example, here's a `HeroService` that depends on the `Logger` service, and also uses `BackendService` to get heroes.\nThat service in turn might depend on the `HttpClient` service to fetch heroes asynchronously from a server:\n\n<docs-code header=\"src/app/hero.service.ts\" language=\"typescript\"\n           highlight=\"[7,8,12,13]\">\nimport { inject } from \"@angular/core\";\n\nexport class HeroService {\n  private heroes: Hero[] = [];\n\n  private backend = inject(BackendService);\n  private logger = inject(Logger);\n\n  async getHeroes() {\n    // Fetch\n    this.heroes = await this.backend.getAll(Hero);\n    // Log\n    this.logger.log(`Fetched ${this.heroes.length} heroes.`);\n    return this.heroes;\n  }\n}\n</docs-code>\n\n## Creating an injectable service\n\nThe Angular CLI provides a command to create a new service. In the following example, you add a new service to an existing application.\n\nTo generate a new `HeroService` class in the `src/app/heroes` folder, follow these steps:\n\n1. Run this [Angular CLI](/tools/cli) command:\n\n<docs-code language=\"sh\">\nng generate service heroes/hero\n</docs-code>\n\nThis command creates the following default `HeroService`:\n\n<docs-code header=\"src/app/heroes/hero.service.ts (CLI-generated)\" language=\"typescript\">\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {}\n</docs-code>\n\nThe `@Injectable()` decorator specifies that Angular can use this class in the DI system.\nThe metadata, `providedIn: 'root'`, means that the `HeroService` is provided throughout the application.\n\nAdd a `getHeroes()` method that returns the heroes from `mock.heroes.ts` to get the hero mock data:\n\n<docs-code header=\"src/app/heroes/hero.service.ts\" language=\"typescript\">\nimport { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@Injectable({\n  // declares that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() {\n    return HEROES;\n  }\n}\n</docs-code>\n\nFor clarity and maintainability, it is recommended that you define components and services in separate files.\n\n## Injecting services\n\nTo inject a service as a dependency into a component, you can declare a class field representing the dependency and use Angular's `inject` function to initialize it.\n\nThe following example specifies the `HeroService` in the `HeroListComponent`.\nThe type of `heroService` is `HeroService`.\n\n<docs-code header=\"src/app/heroes/hero-list.component.ts\" language=\"typescript\">\nimport { inject } from \"@angular/core\";\n\nexport class HeroListComponent {\n  private heroService = inject(HeroService);\n}\n</docs-code>\n\nIt is also possible to inject a service into a component using the component's constructor:\n\n<docs-code header=\"src/app/heroes/hero-list.component.ts (constructor signature)\" language=\"typescript\">\n  constructor(private heroService: HeroService)\n</docs-code>\n\nThe `inject` method can be used in both classes and functions, while the constructor method can naturally only be used in a class constructor. However, in either case a dependency may only be injected in a valid [injection context](guide/di/dependency-injection-context), usually in the construction or initialization of a component.\n\n## Injecting services in other services\n\nWhen a service depends on another service, follow the same pattern as injecting into a component.\nIn the following example, `HeroService` depends on a `Logger` service to report its activities:\n\n<docs-code header=\"src/app/heroes/hero.service.ts\" language=\"typescript\"\n           highlight=\"[3,9,12]\">\nimport { inject, Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n  private logger = inject(Logger);\n\n  getHeroes() {\n    this.logger.log('Getting heroes.');\n    return HEROES;\n  }\n}\n</docs-code>\n\nIn this example, the `getHeroes()` method uses the `Logger` service by logging a message when fetching heroes.\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"/guide/di/dependency-injection-providers\" title=\"Configuring dependency providers\"/>\n  <docs-pill href=\"/guide/di/dependency-injection-providers#using-an-injectiontoken-object\" title=\"`InjectionTokens`\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 5756
  },
  {
    "id": 26,
    "file": "dependency-injection-context",
    "fullFileName": "adev/src/content/guide/di/dependency-injection-context.md",
    "startLine": 5760,
    "content": "# Injection context\n\nThe dependency injection (DI) system relies internally on a runtime context where the current injector is available.\nThis means that injectors can only work when code is executed in such a context.\n\nThe injection context is available in these situations:\n\n* During construction (via the `constructor`) of a class being instantiated by the DI system, such as an `@Injectable` or `@Component`.\n* In the initializer for fields of such classes.\n* In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n* In the `factory` function specified for an `InjectionToken`.\n* Within a stack frame that runs in an injection context.\n\nKnowing when you are in an injection context will allow you to use the [`inject`](api/core/inject) function to inject instances.\n\n## Class constructors\n\nEvery time the DI system instantiates a class, it does so in an injection context. This is handled by the framework itself. The constructor of the class is executed in that runtime context, which also allows injection of a token using the [`inject`](api/core/inject) function.\n\n<docs-code language=\"typescript\" highlight=\"[[3],[6]]\">\nclass MyComponent  {\n  private service1: Service1;\n  private service2: Service2 = inject(Service2); // In context\n\n  constructor() {\n    this.service1 = inject(Service1) // In context\n  }\n}\n</docs-code>\n\n## Stack frame in context\n\nSome APIs are designed to be run in an injection context. This is the case, for example, with router guards. This allows the use of [`inject`](api/core/inject) within the guard function to access a service.\n\nHere is an example for `CanActivateFn`\n\n<docs-code language=\"typescript\" highlight=\"[3]\">\nconst canActivateTeam: CanActivateFn =\n    (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n      return inject(PermissionsService).canActivate(inject(UserToken), route.params.id);\n    };\n</docs-code>\n\n## Run within an injection context\n\nWhen you want to run a given function in an injection context without already being in one, you can do so with `runInInjectionContext`.\nThis requires access to a given injector, like the `EnvironmentInjector`, for example:\n\n<docs-code header=\"src/app/heroes/hero.service.ts\" language=\"typescript\"\n           highlight=\"[9]\">\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n  private environmentInjector = inject(EnvironmentInjector);\n\n  someMethod() {\n    runInInjectionContext(this.environmentInjector, () => {\n      inject(SomeService); // Do what you need with the injected service\n    });\n  }\n}\n</docs-code>\n\nNote that `inject` will return an instance only if the injector can resolve the required token.\n\n## Asserts the context\n\nAngular provides the `assertInInjectionContext` helper function to assert that the current context is an injection context.\n\n## Using DI outside of a context\n\nCalling [`inject`](api/core/inject) or calling `assertInInjectionContext` outside of an injection context will throw [error NG0203](/errors/NG0203).\n\n\n\n================================================\n",
    "endLine": 5835
  },
  {
    "id": 27,
    "file": "dependency-injection-providers",
    "fullFileName": "adev/src/content/guide/di/dependency-injection-providers.md",
    "startLine": 5839,
    "content": "# Configuring dependency providers\n\nThe previous sections described how to use class instances as dependencies.\nAside from classes, you can also use values such as `boolean`, `string`, `Date`, and objects as dependencies.\nAngular provides the necessary APIs to make the dependency configuration flexible, so you can make those values available in DI.\n\n## Specifying a provider token\n\nIf you specify the service class as the provider token, the default behavior is for the injector to instantiate that class using the `new` operator.\n\nIn the following example, the app component provides a `Logger` instance:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\nproviders: [Logger],\n</docs-code>\n\nYou can, however, configure DI to associate the `Logger` provider token with a different class or any other value.\nSo when the `Logger` is injected, the configured value is used instead.\n\nIn fact, the class provider syntax is a shorthand expression that expands into a provider configuration, defined by the `Provider` interface.\nAngular expands the `providers` value in this case into a full provider object as follows:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\n[{ provide: Logger, useClass: Logger }]\n</docs-code>\n\nThe expanded provider configuration is an object literal with two properties:\n\n- The `provide` property holds the token that serves as the key for consuming the dependency value.\n- The second property is a provider definition object, which tells the injector **how** to create the dependency value. The provider-definition can be one of the following:\n  - `useClass` - this option tells Angular DI to instantiate a provided class when a dependency is injected\n  - `useExisting` - allows you to alias a token and reference any existing one.\n  - `useFactory` - allows you to define a function that constructs a dependency.\n  - `useValue` - provides a static value that should be used as a dependency.\n\nThe sections below describe how to use the different provider definitions.\n\n### Class providers: useClass\n\nThe `useClass` provider key lets you create and return a new instance of the specified class.\n\nYou can use this type of provider to substitute an alternative implementation for a common or default class.\nThe alternative implementation can, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case.\n\nIn the following example, `BetterLogger` would be instantiated when the `Logger` dependency is requested in a component or any other class:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\n[{ provide: Logger, useClass: BetterLogger }]\n</docs-code>\n\nIf the alternative class providers have their own dependencies, specify both providers in the providers metadata property of the parent module or component:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\n[\n  UserService, // dependency needed in `EvenBetterLogger`.\n  { provide: Logger, useClass: EvenBetterLogger },\n]\n</docs-code>\n\nIn this example, `EvenBetterLogger` displays the user name in the log message. This logger gets the user from an injected `UserService` instance:\n\n<docs-code header=\"src/app/even-better-logger.component.ts\" language=\"typescript\"\n           highlight=\"[[3],[6]]\">\n@Injectable()\nexport class EvenBetterLogger extends Logger {\n  private userService = inject(UserService);\n\n  override log(message: string) {\n    const name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n</docs-code>\n\nAngular DI knows how to construct the `UserService` dependency, since it has been configured above and is available in the injector.\n\n### Alias providers: useExisting\n\nThe `useExisting` provider key lets you map one token to another.\nIn effect, the first token is an alias for the service associated with the second token, creating two ways to access the same service object.\n\nIn the following example, the injector injects the singleton instance of `NewLogger` when the component asks for either the new or the old logger:\nIn this way, `OldLogger` is an alias for `NewLogger`.\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\" highlight=\"[4]\">\n[\n  NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger},\n]\n</docs-code>\n\nNOTE: Ensure you do not alias `OldLogger` to `NewLogger` with `useClass`, as this creates two different `NewLogger` instances.\n\n### Factory providers: useFactory\n\nThe `useFactory` provider key lets you create a dependency object by calling a factory function.\nWith this approach, you can create a dynamic value based on information available in the DI and elsewhere in the app.\n\nIn the following example, only authorized users should see secret heroes in the `HeroService`.\nAuthorization can change during the course of a single application session, as when a different user logs in .\n\nTo keep security-sensitive information in `UserService` and out of `HeroService`, give the `HeroService` constructor a boolean flag to control display of secret heroes:\n\n<docs-code header=\"src/app/heroes/hero.service.ts\" language=\"typescript\"\n           highlight=\"[[4],[7]]\">\nclass HeroService {\n  constructor(\n    private logger: Logger,\n    private isAuthorized: boolean) { }\n\n  getHeroes() {\n    const auth = this.isAuthorized ? 'authorized' : 'unauthorized';\n    this.logger.log(`Getting heroes for ${auth} user.`);\n    return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n  }\n}\n</docs-code>\n\nTo implement the `isAuthorized` flag, use a factory provider to create a new logger instance for `HeroService`.\nThis is necessary as we need to manually pass `Logger` when constructing the hero service:\n\n<docs-code header=\"src/app/heroes/hero.service.provider.ts\" language=\"typescript\">\nconst heroServiceFactory = (logger: Logger, userService: UserService) =>\n  new HeroService(logger, userService.user.isAuthorized);\n</docs-code>\n\nThe factory function has access to `UserService`.\nYou inject both `Logger` and `UserService` into the factory provider so the injector can pass them along to the factory function:\n\n<docs-code header=\"src/app/heroes/hero.service.provider.ts\" language=\"typescript\"\n           highlight=\"[3,4]\">\nexport const heroServiceProvider = {\n  provide: HeroService,\n  useFactory: heroServiceFactory,\n  deps: [Logger, UserService]\n};\n</docs-code>\n\n- The `useFactory` field specifies that the provider is a factory function whose implementation is `heroServiceFactory`.\n- The `deps` property is an array of provider tokens.\nThe `Logger` and `UserService` classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching `heroServiceFactory` factory function parameters, based on the order specified.\n\nCapturing the factory provider in the exported variable, `heroServiceProvider`, makes the factory provider reusable.\n\n### Value providers: useValue\n\nThe `useValue` key lets you associate a static value with a DI token.\n\nUse this technique to provide runtime configuration constants such as website base addresses and feature flags.\nYou can also use a value provider in a unit test to provide mock data in place of a production data service.\n\nThe next section provides more information about the `useValue` key.\n\n## Using an `InjectionToken` object\n\nUse an `InjectionToken` object as provider token for non-class dependencies.\nThe following example defines a token, `APP_CONFIG`. of the type `InjectionToken`:\n\n<docs-code header=\"src/app/app.config.ts\" language=\"typescript\" highlight=\"[3]\">\nimport { InjectionToken } from '@angular/core';\n\nexport interface AppConfig {\n  title: string;\n}\n\nexport const APP_CONFIG = new InjectionToken<AppConfig>('app.config description');\n</docs-code>\n\nThe optional type parameter, `<AppConfig>`, and the token description, `app.config description`, specify the token's purpose.\n\nNext, register the dependency provider in the component using the `InjectionToken` object of `APP_CONFIG`:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\nconst MY_APP_CONFIG_VARIABLE: AppConfig = {\n  title: 'Hello',\n};\n\nproviders: [{ provide: APP_CONFIG, useValue: MY_APP_CONFIG_VARIABLE }]\n</docs-code>\n\nNow, inject the configuration object in the constructor body with the `inject` function:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\" highlight=\"[2]\">\nexport class AppComponent {\n  constructor() {\n    const config = inject(APP_CONFIG);\n    this.title = config.title;\n  }\n}\n</docs-code>\n\n### Interfaces and DI\n\nThough the TypeScript `AppConfig` interface supports typing within the class, the `AppConfig` interface plays no role in DI.\nIn TypeScript, an interface is a design-time artifact, and does not have a runtime representation, or token, that the DI framework can use.\n\nWhen the TypeScript transpiles to JavaScript, the interface disappears because JavaScript doesn't have interfaces.\nBecause there is no interface for Angular to find at runtime, the interface cannot be a token, nor can you inject it:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\n// Can't use interface as provider token\n[{ provide: AppConfig, useValue: MY_APP_CONFIG_VARIABLE })]\n</docs-code>\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\" highlight=\"[3]\">\nexport class AppComponent {\n  // Can't inject using the interface as the parameter type\n  private config = inject(AppConfig);\n}\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 6053
  },
  {
    "id": 28,
    "file": "dependency-injection",
    "fullFileName": "adev/src/content/guide/di/dependency-injection.md",
    "startLine": 6057,
    "content": "# Understanding dependency injection\n\nDependency injection, or DI, is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need.\n\nTwo main roles exist in the DI system: dependency consumer and dependency provider.\n\nAngular facilitates the interaction between dependency consumers and dependency providers using an abstraction called `Injector`. When a dependency is requested, the injector checks its registry to see if there is an instance already available there. If not, a new instance is created and stored in the registry. Angular creates an application-wide injector (also known as the \"root\" injector) during the application bootstrap process. In most cases you don't need to manually create injectors, but you should know that there is a layer that connects providers and consumers.\n\nThis topic covers basic scenarios of how a class can act as a dependency. Angular also allows you to use functions, objects, primitive types such as string or Boolean, or any other types as dependencies. For more information, see [Dependency providers](guide/di/dependency-injection-providers).\n\n## Providing a dependency\n\nConsider a class called `HeroService` that needs to act as a dependency in a component.\n\nThe first step is to add the `@Injectable` decorator to show that the class can be injected.\n\n<docs-code language=\"typescript\" highlight=\"[1]\">\n@Injectable()\nclass HeroService {}\n</docs-code>\n\nThe next step is to make it available in the DI by providing it.\nA dependency can be provided in multiple places:\n\n- [Understanding dependency injection](#understanding-dependency-injection)\n  - [Providing a dependency](#providing-a-dependency)\n    - [**Preferred**: At the application root level using `providedIn`](#preferred-at-the-application-root-level-using-providedin)\n    - [At the Component level](#at-the-component-level)\n    - [At the application root level using `ApplicationConfig`](#at-the-application-root-level-using-applicationconfig)\n    - [`NgModule` based applications](#ngmodule-based-applications)\n  - [Injecting/consuming a dependency](#injectingconsuming-a-dependency)\n  - [What's next](#whats-next)\n\n### **Preferred**: At the application root level using `providedIn`\n\nProviding a service at the application root level using `providedIn` allows injecting the service into all other classes.\nUsing `providedIn` enables Angular and JavaScript code optimizers to effectively remove services that are unused (known as tree-shaking).\n\nYou can provide a service by using `providedIn: 'root'` in the `@Injectable` decorator:\n\n<docs-code language=\"typescript\" highlight=\"[2]\">\n@Injectable({\n  providedIn: 'root'\n})\nclass HeroService {}\n</docs-code>\n\nWhen you provide the service at the root level, Angular creates a single, shared instance of the `HeroService` and injects it into any class that asks for it.\n\n### At the Component level\n\nYou can provide services at `@Component` level by using the `providers` field of the `@Component` decorator.\nIn this case the `HeroService` becomes available to all instances of this component and other components and directives used in the template.\n\nFor example:\n\n<docs-code language=\"typescript\" highlight=\"[4]\">\n@Component({\n  selector: 'hero-list',\n  template: '...',\n  providers: [HeroService]\n})\nclass HeroListComponent {}\n</docs-code>\n\nWhen you register a provider at the component level, you get a new instance of the service with each new instance of that component.\n\nNOTE: Declaring a service like this causes `HeroService` to always be included in your application— even if the service is unused.\n\n### At the application root level using `ApplicationConfig`\n\nYou can use the `providers` field of the `ApplicationConfig` (passed to the `bootstrapApplication` function) to provide a service or other `Injectable` at the application level.\n\nIn the example below, the `HeroService` is available to all components, directives, and pipes:\n\n<docs-code language=\"typescript\" highlight=\"[3]\">\nexport const appConfig: ApplicationConfig = {\n    providers: [\n      { provide: HeroService },\n    ]\n};\n</docs-code>\n\nThen, in `main.ts`:\n\n<docs-code language=\"typescript\">\nbootstrapApplication(AppComponent, appConfig)\n</docs-code>\n\nNOTE: Declaring a service like this causes `HeroService` to always be included in your application— even if the service is unused.\n\n### `NgModule` based applications\n\n`@NgModule`-based applications use the `providers` field of the `@NgModule` decorator to provide a service or other `Injectable` available at the application level.\n\nA service provided in a module is available to all declarations of the module, or to any other modules which share the same `ModuleInjector`.\nTo understand all edge-cases, see [Hierarchical injectors](guide/di/hierarchical-dependency-injection).\n\nNOTE: Declaring a service using `providers` causes the service to be included in your application— even if the service is unused.\n\n## Injecting/consuming a dependency\n\nUse Angular's `inject` function to retrieve dependencies.\n\n```ts\nimport {inject, Component} from 'angular/core';\n\n@Component({/* ... */})\nexport class UserProfile {\n  // You can use the `inject` function in property initializers.\n  private userClient = inject(UserClient);\n\n  constructor() {\n    // You can also use the `inject` function in a constructor.\n    const logger = inject(Logger);\n  }\n}\n```\n\nYou can use the `inject` function in any [injection context](guide/di/dependency-injection-context). Most of the time, this is in a class property initializer or a class constructor for components, directives, services, and pipes.\n\nWhen Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector creates one using the registered provider, and adds it to the injector before returning the service to Angular.\n\nWhen all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments.\n\n```mermaid\ngraph TD;\nsubgraph Injector\nserviceA[Service A]\nheroService[HeroService]\nserviceC[Service C]\nserviceD[Service D]\nend\ndirection TB\ncomponentProperty[\"Component <br> heroService = inject(HeroService)\"]\nheroService-->componentProperty\nstyle componentProperty text-align: left\n```\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"/guide/di/creating-injectable-service\" title=\"Creating an injectable service\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 6203
  },
  {
    "id": 29,
    "file": "di-in-action",
    "fullFileName": "adev/src/content/guide/di/di-in-action.md",
    "startLine": 6207,
    "content": "# DI in action\n\nThis guide explores additional features of dependency injection in Angular.\n\n## Custom providers with `@Inject`\n\nUsing a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs.\nThe following example uses an `InjectionToken` to provide the [localStorage](https://developer.mozilla.org/docs/Web/API/Window/localStorage) browser API as a dependency in the `BrowserStorageService`:\n\n<docs-code header=\"src/app/storage.service.ts\" language=\"typescript\"\n           highlight=\"[[3,6],[12]]\">\nimport { Inject, Injectable, InjectionToken } from '@angular/core';\n\nexport const BROWSER_STORAGE = new InjectionToken<Storage>('Browser Storage', {\n  providedIn: 'root',\n  factory: () => localStorage\n});\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class BrowserStorageService {\n  public storage = inject(BROWSER_STORAGE);\n\n  get(key: string) {\n    return this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n}\n</docs-code>\n\nThe `factory` function returns the `localStorage` property that is attached to the browser's window object.\nThe `inject` function initializes the `storage` property with an instance of the token.\n\nThis custom provider can now be overridden during testing with a mock API of `localStorage` instead of interacting with real browser APIs.\n\n## Inject the component's DOM element\n\nAlthough developers strive to avoid it, some visual effects and third-party tools require direct DOM access.\nAs a result, you might need to access a component's DOM element.\n\nAngular exposes the underlying element of a `@Component` or `@Directive` via injection using the `ElementRef` injection token:\n\n<docs-code language=\"typescript\" highlight=\"[7]\">\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  private element = inject(ElementRef)\n\n  update() {\n    this.element.nativeElement.style.color = 'red';\n  }\n}\n</docs-code>\n\n## Resolve circular dependencies with a forward reference\n\nThe order of class declaration matters in TypeScript.\nYou can't refer directly to a class until it's been defined.\n\nThis isn't usually a problem, especially if you adhere to the recommended *one class per file* rule.\nBut sometimes circular references are unavoidable.\nFor example, when class 'A' refers to class 'B' and 'B' refers to 'A', one of them has to be defined first.\n\nThe Angular `forwardRef()` function creates an *indirect* reference that Angular can resolve later.\n\nYou face a similar problem when a class makes *a reference to itself*.\nFor example, in its `providers` array.\nThe `providers` array is a property of the `@Component()` decorator function, which must appear before the class definition.\nYou can break such circular references by using `forwardRef`.\n\n<docs-code header=\"app.component.ts\" language=\"typescript\" highlight=\"[4]\">\nproviders: [\n  {\n    provide: PARENT_MENU_ITEM,\n    useExisting: forwardRef(() => MenuItem),\n  },\n],\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 6294
  },
  {
    "id": 30,
    "file": "hierarchical-dependency-injection",
    "fullFileName": "adev/src/content/guide/di/hierarchical-dependency-injection.md",
    "startLine": 6298,
    "content": "# Hierarchical injectors\n\nInjectors in Angular have rules that you can leverage to achieve the desired visibility of injectables in your applications.\nBy understanding these rules, you can determine whether to declare a provider at the application level, in a Component, or in a Directive.\n\nThe applications you build with Angular can become quite large, and one way to manage this complexity is to split up the application into a well-defined tree of components.\n\nThere can be sections of your page that work in a completely independent way than the rest of the application, with its own local copies of the services and other dependencies that it needs.\nSome of the services that these sections of the application use might be shared with other parts of the application, or with parent components that are further up in the component tree, while other dependencies are meant to be private.\n\nWith hierarchical dependency injection, you can isolate sections of the application and give them their own private dependencies not shared with the rest of the application, or have parent components share certain dependencies with its child components only but not with the rest of the component tree, and so on. Hierarchical dependency injection enables you to share dependencies between different parts of the application only when and if you need to.\n\n## Types of injector hierarchies\n\nAngular has two injector hierarchies:\n\n| Injector hierarchies        | Details |\n|:---                         |:---     |\n| `EnvironmentInjector` hierarchy | Configure an `EnvironmentInjector` in this hierarchy using `@Injectable()` or `providers` array in `ApplicationConfig`. |\n| `ElementInjector` hierarchy | Created implicitly at each DOM element. An `ElementInjector` is empty by default unless you configure it in the `providers` property on `@Directive()` or `@Component()`. |\n\n<docs-callout title=\"NgModule Based Applications\">\nFor `NgModule` based applications, you can provide dependencies with the `ModuleInjector` hierarchy using an `@NgModule()` or `@Injectable()` annotation.\n</docs-callout>\n\n### `EnvironmentInjector`\n\nThe `EnvironmentInjector` can be configured in one of two ways by using:\n\n* The `@Injectable()` `providedIn` property to refer to `root` or `platform`\n* The `ApplicationConfig` `providers` array\n\n<docs-callout title=\"Tree-shaking and @Injectable()\">\n\nUsing the `@Injectable()` `providedIn` property is preferable to using the `ApplicationConfig` `providers` array. With `@Injectable()` `providedIn`, optimization tools can perform tree-shaking, which removes services that your application isn't using. This results in smaller bundle sizes.\n\nTree-shaking is especially useful for a library because the application which uses the library may not have a need to inject it.\n\n</docs-callout>\n\n`EnvironmentInjector` is configured by the `ApplicationConfig.providers`.\n\nProvide services using `providedIn` of `@Injectable()` as follows:\n\n<docs-code language=\"typescript\" highlight=\"[4]\">\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'  // <--provides this service in the root EnvironmentInjector\n})\nexport class ItemService {\n  name = 'telephone';\n}\n\n</docs-code>\n\nThe `@Injectable()` decorator identifies a service class.\nThe `providedIn` property configures a specific `EnvironmentInjector`, here `root`, which makes the service available in the `root` `EnvironmentInjector`.\n\n### ModuleInjector\n\nIn the case of `NgModule` based applications, the ModuleInjector can be configured in one of two ways by using:\n\n* The `@Injectable()` `providedIn` property to refer to `root` or `platform`\n* The `@NgModule()` `providers` array\n\n`ModuleInjector` is configured by the `@NgModule.providers` and `NgModule.imports` property. `ModuleInjector` is a flattening of all the providers arrays that can be reached by following the `NgModule.imports` recursively.\n\nChild `ModuleInjector` hierarchies are created when lazy loading other `@NgModules`.\n\n### Platform injector\n\nThere are two more injectors above `root`, an additional `EnvironmentInjector` and `NullInjector()`.\n\nConsider how Angular bootstraps the application with the following in `main.ts`:\n\n<docs-code language=\"javascript\">\nbootstrapApplication(AppComponent, appConfig);\n</docs-code>\n\nThe `bootstrapApplication()` method creates a child injector of the platform injector which is configured by the `ApplicationConfig` instance.\nThis is the `root` `EnvironmentInjector`.\n\nThe `platformBrowserDynamic()` method creates an injector configured by a `PlatformModule`, which contains platform-specific dependencies.\nThis allows multiple applications to share a platform configuration.\nFor example, a browser has only one URL bar, no matter how many applications you have running.\nYou can configure additional platform-specific providers at the platform level by supplying `extraProviders` using the `platformBrowser()` function.\n\nThe next parent injector in the hierarchy is the `NullInjector()`, which is the top of the tree.\nIf you've gone so far up the tree that you are looking for a service in the `NullInjector()`, you'll get an error unless you've used `@Optional()` because ultimately, everything ends at the `NullInjector()` and it returns an error or, in the case of `@Optional()`, `null`.\nFor more information on `@Optional()`, see the [`@Optional()` section](#optional) of this guide.\n\nThe following diagram represents the relationship between the `root` `ModuleInjector` and its parent injectors as the previous paragraphs describe.\n\n```mermaid\nstateDiagram-v2\n    elementInjector: EnvironmentInjector<br>(configured by Angular)<br>has special things like DomSanitizer => providedIn 'platform'\n    rootInjector: root EnvironmentInjector<br>(configured by AppConfig)<br>has things for your app => bootstrapApplication(..., AppConfig)\n    nullInjector: NullInjector<br>always throws an error unless<br>you use @Optional()\n\n    direction BT\n    rootInjector --> elementInjector\n    elementInjector --> nullInjector\n```\n\nWhile the name `root` is a special alias, other `EnvironmentInjector` hierarchies don't have aliases.\nYou have the option to create `EnvironmentInjector` hierarchies whenever a dynamically loaded component is created, such as with the Router, which will create child `EnvironmentInjector` hierarchies.\n\nAll requests forward up to the root injector, whether you configured it with the `ApplicationConfig` instance passed to the `bootstrapApplication()` method, or registered all providers with `root` in their own services.\n\n<docs-callout title=\"@Injectable() vs. ApplicationConfig\">\n\nIf you configure an app-wide provider in the `ApplicationConfig` of `bootstrapApplication`, it overrides one configured for `root` in the `@Injectable()` metadata.\nYou can do this to configure a non-default provider of a service that is shared with multiple applications.\n\nHere is an example of the case where the component router configuration includes a non-default [location strategy](guide/routing#location-strategy) by listing its provider in the `providers` list of the `ApplicationConfig`.\n\n```ts\nproviders: [\n  { provide: LocationStrategy, useClass: HashLocationStrategy }\n]\n```\n\nFor `NgModule` based applications, configure app-wide providers in the `AppModule` `providers`.\n\n</docs-callout>\n\n### `ElementInjector`\n\nAngular creates `ElementInjector` hierarchies implicitly for each DOM element.\n\nProviding a service in the `@Component()` decorator using its `providers` or `viewProviders` property configures an `ElementInjector`.\nFor example, the following `TestComponent` configures the `ElementInjector` by providing the service as follows:\n\n<docs-code language=\"typescript\" highlight=\"[3]\">\n@Component({\n  …\n  providers: [{ provide: ItemService, useValue: { name: 'lamp' } }]\n})\nexport class TestComponent\n</docs-code>\n\nHELPFUL: See the [resolution rules](#resolution-rules) section to understand the relationship between the `EnvironmentInjector` tree, the `ModuleInjector` and the `ElementInjector` tree.\n\nWhen you provide services in a component, that service is available by way of the `ElementInjector` at that component instance.\nIt may also be visible at child component/directives based on visibility rules described in the [resolution rules](#resolution-rules) section.\n\nWhen the component instance is destroyed, so is that service instance.\n\n#### `@Directive()` and `@Component()`\n\nA component is a special type of directive, which means that just as `@Directive()` has a `providers` property, `@Component()` does too.\nThis means that directives as well as components can configure providers, using the `providers` property.\nWhen you configure a provider for a component or directive using the `providers` property, that provider belongs to the `ElementInjector` of that component or directive.\nComponents and directives on the same element share an injector.\n\n## Resolution rules\n\nWhen resolving a token for a component/directive, Angular resolves it in two phases:\n\n1. Against its parents in the `ElementInjector` hierarchy.\n2. Against its parents in the `EnvironmentInjector` hierarchy.\n\nWhen a component declares a dependency, Angular tries to satisfy that dependency with its own `ElementInjector`.\nIf the component's injector lacks the provider, it passes the request up to its parent component's `ElementInjector`.\n\nThe requests keep forwarding up until Angular finds an injector that can handle the request or runs out of ancestor `ElementInjector` hierarchies.\n\nIf Angular doesn't find the provider in any `ElementInjector` hierarchies, it goes back to the element where the request originated and looks in the `EnvironmentInjector` hierarchy.\nIf Angular still doesn't find the provider, it throws an error.\n\nIf you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to resolve the dependency.\nIf, for example, a provider is registered locally in the component that needs a service,\nAngular doesn't look for another provider of the same service.\n\nHELPFUL: For `NgModule` based applications, Angular will search the `ModuleInjector` hierarchy if it cannot find a provider in the `ElementInjector` hierarchies.\n\n## Resolution modifiers\n\nAngular's resolution behavior can be modified with `optional`, `self`, `skipSelf` and `host`.\nImport each of them from `@angular/core` and use each in the `inject` configuration when you inject your service.\n\n### Types of modifiers\n\nResolution modifiers fall into three categories:\n\n* What to do if Angular doesn't find what you're looking for, that is `optional`\n* Where to start looking, that is `skipSelf`\n* Where to stop looking, `host` and `self`\n\nBy default, Angular always starts at the current `Injector` and keeps searching all the way up.\nModifiers allow you to change the starting, or _self_, location and the ending location.\n\nAdditionally, you can combine all of the modifiers except:\n\n* `host` and `self`\n* `skipSelf` and `self`.\n\n### `optional`\n\n`optional` allows Angular to consider a service you inject to be optional.\nThis way, if it can't be resolved at runtime, Angular resolves the service as `null`, rather than throwing an error.\nIn the following example, the service, `OptionalService`, isn't provided in the service, `ApplicationConfig`, `@NgModule()`, or component class, so it isn't available anywhere in the app.\n\n<docs-code header=\"src/app/optional/optional.component.ts\" language=\"typescript\">\nexport class OptionalComponent {\n  public optional? = inject(OptionalService, {optional: true});\n}\n</docs-code>\n\n### `self`\n\nUse `self` so that Angular will only look at the `ElementInjector` for the current component or directive.\n\nA good use case for `self` is to inject a service but only if it is available on the current host element.\nTo avoid errors in this situation, combine `self` with `optional`.\n\nFor example, in the following `SelfNoDataComponent`, notice the injected `LeafService` as a property.\n\n<docs-code header=\"src/app/self-no-data/self-no-data.component.ts\" language=\"typescript\"\n           highlight=\"[7]\">\n@Component({\n  selector: 'app-self-no-data',\n  templateUrl: './self-no-data.component.html',\n  styleUrls: ['./self-no-data.component.css']\n})\nexport class SelfNoDataComponent {\n  public leaf = inject(LeafService, {optional: true, self: true});\n}\n</docs-code>\n\nIn this example, there is a parent provider and injecting the service will return the value, however, injecting the service with `self` and `optional` will return `null` because `self` tells the injector to stop searching in the current host element.\n\nAnother example shows the component class with a provider for `FlowerService`.\nIn this case, the injector looks no further than the current `ElementInjector` because it finds the `FlowerService` and returns the tulip <code>&#x1F337;</code>.\n\n<docs-code header=\"src/app/self/self.component.ts\" path=\"adev/src/content/examples/resolution-modifiers/src/app/self/self.component.ts\" visibleRegion=\"self-component\"/>\n\n### `skipSelf`\n\n`skipSelf` is the opposite of `self`.\nWith `skipSelf`, Angular starts its search for a service in the parent `ElementInjector`, rather than in the current one.\nSo if the parent `ElementInjector` were using the fern <code>&#x1F33F;</code> value for `emoji`, but you had maple leaf <code>&#x1F341;</code> in the component's `providers` array, Angular would ignore maple leaf <code>&#x1F341;</code> and use fern <code>&#x1F33F;</code>.\n\nTo see this in code, assume that the following value for `emoji` is what the parent component were using, as in this service:\n\n<docs-code header=\"src/app/leaf.service.ts\" language=\"typescript\">\nexport class LeafService {\n  emoji = '🌿';\n}\n</docs-code>\n\nImagine that in the child component, you had a different value, maple leaf <code>&#x1F341;</code> but you wanted to use the parent's value instead.\nThis is when you'd use `skipSelf`:\n\n<docs-code header=\"src/app/skipself/skipself.component.ts\" language=\"typescript\"\n           highlight=\"[[6],[10]]\">\n@Component({\n  selector: 'app-skipself',\n  templateUrl: './skipself.component.html',\n  styleUrls: ['./skipself.component.css'],\n  // Angular would ignore this LeafService instance\n  providers: [{ provide: LeafService, useValue: { emoji: '🍁' } }]\n})\nexport class SkipselfComponent {\n  // Use skipSelf as inject option\n  public leaf = inject(LeafService, {skipSelf: true});\n}\n</docs-code>\n\nIn this case, the value you'd get for `emoji` would be fern <code>&#x1F33F;</code>, not maple leaf <code>&#x1F341;</code>.\n\n#### `skipSelf` option with `optional`\n\nUse the `skipSelf` option with `optional` to prevent an error if the value is `null`.\n\nIn the following example, the `Person` service is injected during property initialization.\n`skipSelf` tells Angular to skip the current injector and `optional` will prevent an error should the `Person` service be `null`.\n\n<docs-code language=\"typescript\">\nclass Person {\n  parent = inject(Person, {optional: true, skipSelf: true})\n}\n</docs-code>\n\n### `host`\n\n<!-- TODO: Remove ambiguity between host and self. -->\n\n`host` lets you designate a component as the last stop in the injector tree when searching for providers.\n\nEven if there is a service instance further up the tree, Angular won't continue looking.\nUse `host` as follows:\n\n<docs-code header=\"src/app/host/host.component.ts\" language=\"typescript\"\n           highlight=\"[[6],[10]]\">\n@Component({\n  selector: 'app-host',\n  templateUrl: './host.component.html',\n  styleUrls: ['./host.component.css'],\n  //  provide the service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌷' } }]\n})\nexport class HostComponent {\n  // use host when injecting the service\n  flower = inject(FlowerService, {host: true, optional: true});\n}\n</docs-code>\n\nSince `HostComponent` has the `host` option , no matter what the parent of `HostComponent` might have as a `flower.emoji` value, the `HostComponent` will use tulip <code>&#x1F337;</code>.\n\n### Modifiers with constructor injection  \n\nSimilarly as presented before, the behavior of constructor injection can be modified with `@Optional()`, `@Self()`, `@SkipSelf()` and `@Host()`.\n\nImport each of them from `@angular/core` and use each in the component class constructor when you inject your service.\n\n<docs-code header=\"src/app/self-no-data/self-no-data.component.ts\" language=\"typescript\" highlight=\"[3]\">\nexport class SelfNoDataComponent {\n  constructor(@Self() @Optional() public leaf?: LeafService) { }\n}\n</docs-code>\n\n## Logical structure of the template\n\nWhen you provide services in the component class, services are visible within the `ElementInjector` tree relative to where and how you provide those services.\n\nUnderstanding the underlying logical structure of the Angular template will give you a foundation for configuring services and in turn control their visibility.\n\nComponents are used in your templates, as in the following example:\n\n<docs-code language=\"html\">\n<app-root>\n  <app-child></app-child>;\n</app-root>\n</docs-code>\n\nHELPFUL: Usually, you declare the components and their templates in separate files.\nFor the purposes of understanding how the injection system works, it is useful to look at them from the point of view of a combined logical tree.\nThe term _logical_ distinguishes it from the render tree, which is your application's DOM tree.\nTo mark the locations of where the component templates are located, this guide uses the `<#VIEW>` pseudo-element, which doesn't actually exist in the render tree and is present for mental model purposes only.\n\nThe following is an example of how the `<app-root>` and `<app-child>` view trees are combined into a single logical tree:\n\n<docs-code language=\"html\">\n<app-root>\n  <#VIEW>\n    <app-child>\n     <#VIEW>\n       …content goes here…\n     </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n</docs-code>\n\nUnderstanding the idea of the `<#VIEW>` demarcation is especially significant when you configure services in the component class.\n\n## Example: Providing services in `@Component()`\n\nHow you provide services using a `@Component()` (or `@Directive()`) decorator determines their visibility.\nThe following sections demonstrate `providers` and `viewProviders` along with ways to modify service visibility with `skipSelf` and `host`.\n\nA component class can provide services in two ways:\n\n| Arrays                       | Details |\n|:---                          |:---     |\n| With a `providers` array     | `@Component({ providers: [SomeService] })`     |\n| With a `viewProviders` array | `@Component({ viewProviders: [SomeService] })` |\n\nIn the examples below, you will see the logical tree of an Angular application.\nTo illustrate how the injector works in the context of templates, the logical tree will represent the HTML structure of the application.\nFor example, the logical tree will show that `<child-component>` is a direct children of `<parent-component>`.\n\nIn the logical tree, you will see special attributes: `@Provide`, `@Inject`, and `@ApplicationConfig`.\nThese aren't real attributes but are here to demonstrate what is going on under the hood.\n\n| Angular service attribute                                                                                          | Details |\n|:---                                                                                                                |:---     |\n| `@Inject(Token)=>Value`     | If `Token` is injected at this location in the logical tree, its value would be `Value`.     |\n| `@Provide(Token=Value)`     | Indicates that `Token` is provided with `Value` at this location in the logical tree.        |\n| `@ApplicationConfig` | Demonstrates that a fallback `EnvironmentInjector` should be used at this location.          |\n\n### Example app structure\n\nThe example application has a `FlowerService` provided in `root` with an `emoji` value of red hibiscus <code>&#x1F33A;</code>.\n\n<docs-code header=\"src/app/flower.service.ts\" language=\"typescript\">\n@Injectable({\n  providedIn: 'root'\n})\nexport class FlowerService {\n  emoji = '🌺';\n}\n</docs-code>\n\nConsider an application with only an `AppComponent` and a `ChildComponent`.\nThe most basic rendered view would look like nested HTML elements such as the following:\n\n<docs-code language=\"html\">\n\n<app-root> <!-- AppComponent selector -->\n  <app-child> <!-- ChildComponent selector -->\n  </app-child>\n</app-root>\n\n</docs-code>\n\nHowever, behind the scenes, Angular uses a logical view representation as follows when resolving injection requests:\n\n<docs-code language=\"html\">\n<app-root> <!-- AppComponent selector -->\n  <#VIEW>\n    <app-child> <!-- ChildComponent selector -->\n      <#VIEW>\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n</docs-code>\n\nThe `<#VIEW>` here represents an instance of a template.\nNotice that each component has its own `<#VIEW>`.\n\nKnowledge of this structure can inform how you provide and inject your services, and give you complete control of service visibility.\n\nNow, consider that `<app-root>` injects the `FlowerService`:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\">\nexport class AppComponent  {\n  flower = inject(FlowerService);\n}\n</docs-code>\n\nAdd a binding to the `<app-root>` template to visualize the result:\n\n<docs-code header=\"src/app/app.component.html\" language=\"html\">\n<p>Emoji from FlowerService: {{flower.emoji}}</p>\n</docs-code>\n\nThe output in the view would be:\n\n<docs-code language=\"shell\">\nEmoji from FlowerService: &#x1F33A;\n</docs-code>\n\nIn the logical tree, this would be represented as follows:\n\n<docs-code language=\"html\" highlight=\"[[1],[2],[4]]\">\n<app-root @ApplicationConfig\n        @Inject(FlowerService) flower=>\"&#x1F33A;\">\n  <#VIEW>\n    <p>Emoji from FlowerService: {{flower.emoji}} (&#x1F33A;)</p>\n    <app-child>\n      <#VIEW>\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nWhen `<app-root>` requests the `FlowerService`, it is the injector's job to resolve the `FlowerService` token.\nThe resolution of the token happens in two phases:\n\n1. The injector determines the starting location in the logical tree and an ending location of the search.\n    The injector begins with the starting location and looks for the token at each view level in the logical tree.\n    If the token is found it is returned.\n\n1. If the token is not found, the injector looks for the closest parent `EnvironmentInjector` to delegate the request to.\n\nIn the example case, the constraints are:\n\n1. Start with `<#VIEW>` belonging to `<app-root>` and end with `<app-root>`.\n\n    * Normally the starting point for search is at the point of injection.\n        However, in this case `<app-root>` is a component. `@Component`s are special in that they also include their own `viewProviders`, which is why the search starts at `<#VIEW>` belonging to `<app-root>`.\n        This would not be the case for a directive matched at the same location.\n    * The ending location happens to be the same as the component itself, because it is the topmost component in this application.\n\n1. The `EnvironmentInjector` provided by the `ApplicationConfig` acts as the fallback injector when the injection token can't be found in the `ElementInjector` hierarchies.\n\n### Using the `providers` array\n\nNow, in the `ChildComponent` class, add a provider for `FlowerService` to demonstrate more complex resolution rules in the upcoming sections:\n\n<docs-code header=\"src/app/child.component.ts\" language=\"typescript\"\n           highlight=\"[[5,6],[10]]\">\n@Component({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // use the providers array to provide a service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }]\n})\nexport class ChildComponent {\n  // inject the service\n  flower = inject(FlowerService);\n}\n</docs-code>\n\nNow that the `FlowerService` is provided in the `@Component()` decorator, when the `<app-child>` requests the service, the injector has only to look as far as the `ElementInjector` in the `<app-child>`.\nIt won't have to continue the search any further through the injector tree.\n\nThe next step is to add a binding to the `ChildComponent` template.\n\n<docs-code header=\"src/app/child.component.html\" language=\"html\">\n<p>Emoji from FlowerService: {{flower.emoji}}</p>\n</docs-code>\n\nTo render the new values, add `<app-child>` to the bottom of the `AppComponent` template so the view also displays the sunflower:\n\n<docs-code language=\"shell\">\nChild Component\nEmoji from FlowerService: &#x1F33B;\n</docs-code>\n\nIn the logical tree, this is represented as follows:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n        @Inject(FlowerService) flower=>\"&#x1F33A;\">\n  <#VIEW>\n    <p>Emoji from FlowerService: {{flower.emoji}} (&#x1F33A;)</p>\n    <app-child @Provide(FlowerService=\"&#x1F33B;\")\n               @Inject(FlowerService)=>\"&#x1F33B;\"> <!-- search ends here -->\n      <#VIEW> <!-- search starts here -->\n        <h2>Child Component</h2>\n        <p>Emoji from FlowerService: {{flower.emoji}} (&#x1F33B;)</p>\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nWhen `<app-child>` requests the `FlowerService`, the injector begins its search at the `<#VIEW>` belonging to `<app-child>` \\(`<#VIEW>` is included because it is injected from `@Component()`\\) and ends with `<app-child>`.\nIn this case, the `FlowerService` is resolved in the `providers` array with sunflower <code>&#x1F33B;</code> of the `<app-child>`.\nThe injector doesn't have to look any further in the injector tree.\nIt stops as soon as it finds the `FlowerService` and never sees the red hibiscus <code>&#x1F33A;</code>.\n\n### Using the `viewProviders` array\n\nUse the `viewProviders` array as another way to provide services in the `@Component()` decorator.\nUsing `viewProviders` makes services visible in the `<#VIEW>`.\n\nHELPFUL: The steps are the same as using the `providers` array, with the exception of using the `viewProviders` array instead.\n\nFor step-by-step instructions, continue with this section.\nIf you can set it up on your own, skip ahead to [Modifying service availability](#visibility-of-provided-tokens).\n\nFor demonstration, we are building an `AnimalService` to demonstrate `viewProviders`.\nFirst, create an `AnimalService` with an `emoji` property of whale <code>&#x1F433;</code>:\n\n<docs-code header=\"src/app/animal.service.ts\" language=\"typescript\">\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnimalService {\n  emoji = '🐳';\n}\n</docs-code>\n\nFollowing the same pattern as with the `FlowerService`, inject the `AnimalService` in the `AppComponent` class:\n\n<docs-code header=\"src/app/app.component.ts\" language=\"typescript\" highlight=\"[4]\">\nexport class AppComponent {\n    public flower = inject(FlowerService);\n    public animal = inject(AnimalService);\n}\n</docs-code>\n\nHELPFUL: You can leave all the `FlowerService` related code in place as it will allow a comparison with the `AnimalService`.\n\nAdd a `viewProviders` array and inject the `AnimalService` in the `<app-child>` class, too, but give `emoji` a different value.\nHere, it has a value of dog <code>&#x1F436;</code>.\n\n<docs-code header=\"src/app/child.component.ts\" language=\"typescript\"\n           highlight=\"[[7],[11]]\">\n@Component({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // provide services\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }],\n  viewProviders: [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n})\nexport class ChildComponent {\n  // inject services\n  flower = inject(FlowerService); \n  animal = inject(AnimalService)\n...\n}\n</docs-code>\n\nAdd bindings to the `ChildComponent` and the `AppComponent` templates.\nIn the `ChildComponent` template, add the following binding:\n\n<docs-code header=\"src/app/child.component.html\" language=\"html\">\n<p>Emoji from AnimalService: {{animal.emoji}}</p>\n</docs-code>\n\nAdditionally, add the same to the `AppComponent` template:\n\n<docs-code header=\"src/app/app.component.html\" language=\"html\">\n<p>Emoji from AnimalService: {{animal.emoji}}</p>s\n</docs-code>\n\nNow you should see both values in the browser:\n\n<docs-code hideCopy language=\"shell\">\n\nAppComponent\nEmoji from AnimalService: &#x1F433;\n\nChild Component\nEmoji from AnimalService: &#x1F436;\n\n</docs-code>\n\nThe logic tree for this example of `viewProviders` is as follows:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n         @Inject(AnimalService) animal=>\"&#x1F433;\">\n  <#VIEW>\n    <app-child>\n      <#VIEW @Provide(AnimalService=\"&#x1F436;\")\n            @Inject(AnimalService=>\"&#x1F436;\")>\n       <!-- ^^using viewProviders means AnimalService is available in <#VIEW>-->\n       <p>Emoji from AnimalService: {{animal.emoji}} (&#x1F436;)</p>\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nJust as with the `FlowerService` example, the `AnimalService` is provided in the `<app-child>` `@Component()` decorator.\nThis means that since the injector first looks in the `ElementInjector` of the component, it finds the `AnimalService` value of dog <code>&#x1F436;</code>.\nIt doesn't need to continue searching the `ElementInjector` tree, nor does it need to search the `ModuleInjector`.\n\n### `providers` vs. `viewProviders`\n\nThe `viewProviders` field is conceptually similar to `providers`, but there is one notable difference.\nConfigured providers in `viewProviders` are not visible to projected content that ends up as a logical children of the component.\n\nTo see the difference between using `providers` and `viewProviders`, add another component to the example and call it `InspectorComponent`.\n`InspectorComponent` will be a child of the `ChildComponent`.\nIn `inspector.component.ts`, inject the `FlowerService` and `AnimalService` during property initialization:\n\n<docs-code header=\"src/app/inspector/inspector.component.ts\" language=\"typescript\">\nexport class InspectorComponent {\n  flower = inject(FlowerService);\n  animal = inject(AnimalService);\n}\n</docs-code>\n\nYou do not need a `providers` or `viewProviders` array.\nNext, in `inspector.component.html`, add the same markup from previous components:\n\n<docs-code header=\"src/app/inspector/inspector.component.html\" language=\"html\">\n<p>Emoji from FlowerService: {{flower.emoji}}</p>\n<p>Emoji from AnimalService: {{animal.emoji}}</p>\n</docs-code>\n\nRemember to add the `InspectorComponent` to the `ChildComponent` `imports` array.\n\n<docs-code header=\"src/app/child/child.component.ts\" language=\"typescript\"\n           highlight=\"[3]\">\n@Component({\n  ...\n  imports: [InspectorComponent]\n})\n\n</docs-code>\n\nNext, add the following to `child.component.html`:\n\n<docs-code header=\"src/app/child/child.component.html\" language=\"html\"\n           highlight=\"[3,9]\">\n...\n\n<div class=\"container\">\n  <h3>Content projection</h3>\n  <ng-content></ng-content>\n</div>\n<h3>Inside the view</h3>\n\n<app-inspector></app-inspector>\n</docs-code>\n\n`<ng-content>` allows you to project content, and `<app-inspector>` inside the `ChildComponent` template makes the `InspectorComponent` a child component of `ChildComponent`.\n\nNext, add the following to `app.component.html` to take advantage of content projection.\n\n<docs-code header=\"src/app/app.component.html\" language=\"html\" highlight=\"[2]\">\n<app-child>\n  <app-inspector></app-inspector>\n</app-child>\n</docs-code>\n\nThe browser now renders the following, omitting the previous examples for brevity:\n\n<docs-code hideCopy language=\"shell\">\n...\nContent projection\n\nEmoji from FlowerService: &#x1F33B;\nEmoji from AnimalService: &#x1F433;\n\nEmoji from FlowerService: &#x1F33B;\nEmoji from AnimalService: &#x1F436;\n\n</docs-code>\n\nThese four bindings demonstrate the difference between `providers` and `viewProviders`.\nRemember that the dog emoji <code>&#x1F436;</code> is declared inside the `<#VIEW>` of `ChildComponent` and isn't visible to the projected content.\nInstead, the projected content sees the whale <code>&#x1F433;</code>.\n\nHowever, in the next output section though, the `InspectorComponent` is an actual child component of `ChildComponent`, `InspectorComponent` is inside the `<#VIEW>`, so when it asks for the `AnimalService`, it sees the dog <code>&#x1F436;</code>.\n\nThe `AnimalService` in the logical tree would look like this:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n         @Inject(AnimalService) animal=>\"&#x1F433;\">\n  <#VIEW>\n    <app-child>\n      <#VIEW @Provide(AnimalService=\"&#x1F436;\")\n            @Inject(AnimalService=>\"&#x1F436;\")>\n        <!-- ^^using viewProviders means AnimalService is available in <#VIEW>-->\n        <p>Emoji from AnimalService: {{animal.emoji}} (&#x1F436;)</p>\n\n        <div class=\"container\">\n          <h3>Content projection</h3>\n          <app-inspector @Inject(AnimalService) animal=>\"&#x1F433;\">\n            <p>Emoji from AnimalService: {{animal.emoji}} (&#x1F433;)</p>\n          </app-inspector>\n        </div>\n\n        <app-inspector>\n          <#VIEW @Inject(AnimalService) animal=>\"&#x1F436;\">\n            <p>Emoji from AnimalService: {{animal.emoji}} (&#x1F436;)</p>\n          </#VIEW>\n        </app-inspector>\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nThe projected content of `<app-inspector>` sees the whale <code>&#x1F433;</code>, not the dog <code>&#x1F436;</code>, because the dog <code>&#x1F436;</code> is inside the `<app-child>` `<#VIEW>`.\nThe `<app-inspector>` can only see the dog <code>&#x1F436;</code> if it is also within the `<#VIEW>`.\n\n### Visibility of provided tokens\n\nVisibility decorators influence where the search for the injection token begins and ends in the logic tree.\nTo do this, place visibility configuration at the point of injection, that is, when invoking `inject()`, rather than at a point of declaration.\n\nTo alter where the injector starts looking for `FlowerService`, add `skipSelf` to the `<app-child>` `inject()` invocation where `FlowerService` is injected.\nThis invocation is a property initializer the `<app-child>` as shown in `child.component.ts`:\n\n<docs-code language=\"typescript\">\nflower = inject(FlowerService, { skipSelf: true })\n</docs-code>\n\nWith `skipSelf`, the `<app-child>` injector doesn't look to itself for the `FlowerService`.\nInstead, the injector starts looking for the `FlowerService` at the `ElementInjector` of the `<app-root>`, where it finds nothing.\nThen, it goes back to the `<app-child>` `ModuleInjector` and finds the red hibiscus <code>&#x1F33A;</code> value, which is available because `<app-child>` and `<app-root>` share the same `ModuleInjector`.\nThe UI renders the following:\n\n<docs-code hideCopy language=\"shell\">\n\nEmoji from FlowerService: &#x1F33A;\n\n</docs-code>\n\nIn a logical tree, this same idea might look like this:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n        @Inject(FlowerService) flower=>\"&#x1F33A;\">\n  <#VIEW>\n    <app-child @Provide(FlowerService=\"&#x1F33B;\")>\n      <#VIEW @Inject(FlowerService, SkipSelf)=>\"&#x1F33A;\">\n        <!-- With SkipSelf, the injector looks to the next injector up the tree (app-root) -->\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nThough `<app-child>` provides the sunflower <code>&#x1F33B;</code>, the application renders the red hibiscus <code>&#x1F33A;</code> because `skipSelf` causes the current injector (`app-child`) to skip itself and look to its parent.\n\nIf you now add `host` (in addition to the `skipSelf`), the result will be `null`.\nThis is because `host` limits the upper bound of the search to the `app-child` `<#VIEW>`.\nHere's the idea in the logical tree:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n        @Inject(FlowerService) flower=>\"&#x1F33A;\">\n  <#VIEW> <!-- end search here with null-->\n    <app-child @Provide(FlowerService=\"&#x1F33B;\")> <!-- start search here -->\n      <#VIEW inject(FlowerService, {skipSelf: true, host: true, optional:true})=>null>\n      </#VIEW>\n      </app-parent>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nHere, the services and their values are the same, but `host` stops the injector from looking any further than the `<#VIEW>` for `FlowerService`, so it doesn't find it and returns `null`.\n\n### `skipSelf` and `viewProviders`\n\nRemember, `<app-child>` provides the `AnimalService` in the `viewProviders` array with the value of dog <code>&#x1F436;</code>.\nBecause the injector has only to look at the `ElementInjector` of the `<app-child>` for the `AnimalService`, it never sees the whale <code>&#x1F433;</code>.\n\nAs in the `FlowerService` example, if you add `skipSelf` to the `inject()` of `AnimalService`, the injector won't look in the  `ElementInjector` of the current `<app-child>` for the `AnimalService`.\nInstead, the injector will begin at the `<app-root>` `ElementInjector`.\n\n<docs-code language=\"typescript\" highlight=\"[5]\">\n@Component({\n  selector: 'app-child',\n  …\n  viewProviders: [\n    { provide: AnimalService, useValue: { emoji: '&#x1F436;' } },\n  ],\n})\n</docs-code>\n\nThe logical tree looks like this with `skipSelf` in `<app-child>`:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n          @Inject(AnimalService=>\"&#x1F433;\")>\n  <#VIEW><!-- search begins here -->\n    <app-child>\n      <#VIEW @Provide(AnimalService=\"&#x1F436;\")\n             @Inject(AnimalService, SkipSelf=>\"&#x1F433;\")>\n        <!--Add skipSelf -->\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nWith `skipSelf` in the `<app-child>`, the injector begins its search for the `AnimalService` in the `<app-root>` `ElementInjector` and finds whale <code>&#x1F433;</code>.\n\n### `host` and `viewProviders`\n\nIf you just use `host` for the injection of `AnimalService`, the result is dog <code>&#x1F436;</code> because the injector finds the `AnimalService` in the `<app-child>` `<#VIEW>` itself.\nThe `ChildComponent` configures the `viewProviders` so that the dog emoji is provided as `AnimalService` value.\nYou can also see `host` the `inject()`:\n\n<docs-code language=\"typescript\" highlight=\"[[5],[9]]\">\n@Component({\n  selector: 'app-child',\n  …\n  viewProviders: [\n    { provide: AnimalService, useValue: { emoji: '&#x1F436;' } },\n  ]\n})\nexport class ChildComponent {\n  animal = inject(AnimalService, { host: true })\n}\n</docs-code>\n\n`host: true` causes the injector to look until it encounters the edge of the `<#VIEW>`.\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n          @Inject(AnimalService=>\"&#x1F433;\")>\n  <#VIEW>\n    <app-child>\n      <#VIEW @Provide(AnimalService=\"&#x1F436;\")\n             inject(AnimalService, {host: true}=>\"&#x1F436;\")> <!-- host stops search here -->\n      </#VIEW>\n    </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\nAdd a `viewProviders` array with a third animal, hedgehog <code>&#x1F994;</code>, to the `app.component.ts` `@Component()` metadata:\n\n<docs-code language=\"typescript\" highlight=\"[6]\">\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.css' ],\n  viewProviders: [\n    { provide: AnimalService, useValue: { emoji: '&#x1F994;' } },\n  ],\n})\n\n</docs-code>\n\nNext, add `skipSelf` along with `host` to the `inject()` for the `AnimalService` injection in `child.component.ts`.\nHere are `host` and `skipSelf` in the `animal` property initialization:\n\n<docs-code language=\"typescript\" highlight=\"[4]\">\nexport class ChildComponent {\n  animal = inject(AnimalService, { host: true, skipSelf: true });\n}\n\n</docs-code>\n\n<!-- TODO: This requires a rework. It seems not well explained what `viewProviders`/`injectors` is here\n  and how `host` works.\n -->\n\nWhen `host` and `skipSelf` were applied to the `FlowerService`, which is in the `providers` array, the result was `null` because `skipSelf` starts its search in the `<app-child>` injector, but `host` stops searching at `<#VIEW>` —where there is no `FlowerService`\nIn the logical tree, you can see that the `FlowerService` is visible in `<app-child>`, not its `<#VIEW>`.\n\nHowever, the `AnimalService`, which is provided in the `AppComponent` `viewProviders` array, is visible.\n\nThe logical tree representation shows why this is:\n\n<docs-code language=\"html\">\n\n<app-root @ApplicationConfig\n        @Inject(AnimalService=>\"&#x1F433;\")>\n  <#VIEW @Provide(AnimalService=\"&#x1F994;\")\n         @Inject(AnimalService, @Optional)=>\"&#x1F994;\">\n    <!-- ^^skipSelf starts here,  host stops here^^ -->\n    <app-child>\n      <#VIEW @Provide(AnimalService=\"&#x1F436;\")\n             inject(AnimalService, {skipSelf:true, host: true, optional: true})=>\"&#x1F994;\">\n               <!-- Add skipSelf ^^-->\n      </#VIEW>\n      </app-child>\n  </#VIEW>\n</app-root>\n\n</docs-code>\n\n`skipSelf`, causes the injector to start its search for the `AnimalService` at the `<app-root>`, not the `<app-child>`, where the request originates, and `host` stops the search at the `<app-root>` `<#VIEW>`.\nSince `AnimalService` is provided by way of the `viewProviders` array, the injector finds hedgehog <code>&#x1F994;</code> in the `<#VIEW>`.\n\n## Example: `ElementInjector` use cases\n\nThe ability to configure one or more providers at different levels opens up useful possibilities.\n\n### Scenario: service isolation\n\nArchitectural reasons may lead you to restrict access to a service to the application domain where it belongs.\nFor example, consider we build a `VillainsListComponent` that displays a list of villains.\nIt gets those villains from a `VillainsService`.\n\nIf you provide `VillainsService` in the root `AppModule`, it will make `VillainsService` visible everywhere in the application.\nIf you later modify the `VillainsService`, you could break something in other components that started depending this service by accident.\n\nInstead, you should provide the `VillainsService` in the `providers` metadata of the `VillainsListComponent` like this:\n\n<docs-code header=\"src/app/villains-list.component.ts (metadata)\" language=\"typescript\"\n           highlight=\"[4]\">\n@Component({\n  selector: 'app-villains-list',\n  templateUrl: './villains-list.component.html',\n  providers: [VillainsService]\n})\nexport class VillainsListComponent {}\n</docs-code>\n\nBy providing `VillainsService` in the `VillainsListComponent` metadata and nowhere else, the service becomes available only in the `VillainsListComponent` and its subcomponent tree.\n\n`VillainService` is a singleton with respect to `VillainsListComponent` because that is where it is declared.\nAs long as `VillainsListComponent` does not get destroyed it will be the same instance of `VillainService` but if there are multiple instances of `VillainsListComponent`, then each instance of `VillainsListComponent` will have its own instance of `VillainService`.\n\n### Scenario: multiple edit sessions\n\nMany applications allow users to work on several open tasks at the same time.\nFor example, in a tax preparation application, the preparer could be working on several tax returns, switching from one to the other throughout the day.\n\nTo demonstrate that scenario, imagine a `HeroListComponent` that displays a list of super heroes.\n\nTo open a hero's tax return, the preparer clicks on a hero name, which opens a component for editing that return.\nEach selected hero tax return opens in its own component and multiple returns can be open at the same time.\n\nEach tax return component has the following characteristics:\n\n* Is its own tax return editing session\n* Can change a tax return without affecting a return in another component\n* Has the ability to save the changes to its tax return or cancel them\n\nSuppose that the `HeroTaxReturnComponent` had logic to manage and restore changes.\nThat would be a straightforward task for a hero tax return.\nIn the real world, with a rich tax return data model, the change management would be tricky.\nYou could delegate that management to a helper service, as this example does.\n\nThe `HeroTaxReturnService` caches a single `HeroTaxReturn`, tracks changes to that return, and can save or restore it.\nIt also delegates to the application-wide singleton `HeroService`, which it gets by injection.\n\n<docs-code header=\"src/app/hero-tax-return.service.ts\" language=\"typescript\">\nimport { Injectable } from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroesService } from './heroes.service';\n\n@Injectable()\nexport class HeroTaxReturnService {\n  private currentTaxReturn!: HeroTaxReturn;\n  private originalTaxReturn!: HeroTaxReturn;\n\n  private heroService = inject(HeroesService);\n\n  set taxReturn(htr: HeroTaxReturn) {\n    this.originalTaxReturn = htr;\n    this.currentTaxReturn  = htr.clone();\n  }\n\n  get taxReturn(): HeroTaxReturn {\n    return this.currentTaxReturn;\n  }\n\n  restoreTaxReturn() {\n    this.taxReturn = this.originalTaxReturn;\n  }\n\n  saveTaxReturn() {\n    this.taxReturn = this.currentTaxReturn;\n    this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();\n  }\n}\n</docs-code>\n\nHere is the `HeroTaxReturnComponent` that makes use of `HeroTaxReturnService`.\n\n<docs-code header=\"src/app/hero-tax-return.component.ts\" language=\"typescript\">\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroTaxReturnService } from './hero-tax-return.service';\n\n@Component({\n  selector: 'app-hero-tax-return',\n  templateUrl: './hero-tax-return.component.html',\n  styleUrls: [ './hero-tax-return.component.css' ],\n  providers: [ HeroTaxReturnService ]\n})\nexport class HeroTaxReturnComponent {\n  message = '';\n\n  @Output() close = new EventEmitter<void>();\n\n  get taxReturn(): HeroTaxReturn {\n    return this.heroTaxReturnService.taxReturn;\n  }\n\n  @Input()\n  set taxReturn(htr: HeroTaxReturn) {\n    this.heroTaxReturnService.taxReturn = htr;\n  }\n\n  private heroTaxReturnService = inject(HeroTaxReturnService);\n\n  onCanceled()  {\n    this.flashMessage('Canceled');\n    this.heroTaxReturnService.restoreTaxReturn();\n  }\n\n  onClose() { this.close.emit(); }\n\n  onSaved() {\n    this.flashMessage('Saved');\n    this.heroTaxReturnService.saveTaxReturn();\n  }\n\n  flashMessage(msg: string) {\n    this.message = msg;\n    setTimeout(() => this.message = '', 500);\n  }\n}\n</docs-code>\n\nThe _tax-return-to-edit_ arrives by way of the `@Input()` property, which is implemented with getters and setters.\nThe setter initializes the component's own instance of the `HeroTaxReturnService` with the incoming return.\nThe getter always returns what that service says is the current state of the hero.\nThe component also asks the service to save and restore this tax return.\n\nThis won't work if the service is an application-wide singleton.\nEvery component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.\n\nTo prevent this, configure the component-level injector of `HeroTaxReturnComponent` to provide the service, using the `providers` property in the component metadata.\n\n<docs-code header=\"src/app/hero-tax-return.component.ts (providers)\" language=\"typescript\">\nproviders: [HeroTaxReturnService]\n</docs-code>\n\nThe `HeroTaxReturnComponent` has its own provider of the `HeroTaxReturnService`.\nRecall that every component _instance_ has its own injector.\nProviding the service at the component level ensures that _every_ instance of the component gets a private instance of the service. This makes sure that no tax return gets overwritten.\n\nHELPFUL: The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere in the documentation.\n\n### Scenario: specialized providers\n\nAnother reason to provide a service again at another level is to substitute a _more specialized_ implementation of that service, deeper in the component tree.\n\nFor example, consider a `Car` component that includes tire service information and depends on other services to provide more details about the car.\n\nThe root injector, marked as (A), uses _generic_ providers for details about `CarService` and `EngineService`.\n\n1. `Car` component (A).  Component (A) displays tire service data about a car and specifies generic services to provide more information about the car.\n\n2. Child component (B). Component (B) defines its own, _specialized_ providers for `CarService` and `EngineService` that have special capabilities suitable for what's going on in component (B).\n\n3. Child component (C) as a child of Component (B). Component (C) defines its own, even _more specialized_ provider for `CarService`.\n\n```mermaid\ngraph TD;\nsubgraph COMPONENT_A[Component A]\nsubgraph COMPONENT_B[Component B]\nCOMPONENT_C[Component C]\nend\nend\n\nstyle COMPONENT_A fill:#BDD7EE\nstyle COMPONENT_B fill:#FFE699\nstyle COMPONENT_C fill:#A9D18E,color:#000\nclassDef noShadow filter:none\nclass COMPONENT_A,COMPONENT_B,COMPONENT_C noShadow\n```\n\nBehind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.\n\nWhen you resolve an instance of `Car` at the deepest component (C), its injector produces:\n\n* An instance of `Car` resolved by injector (C)\n* An `Engine` resolved by injector (B)\n* Its `Tires` resolved by the root injector (A).\n\n```mermaid\ngraph BT;\n\nsubgraph A[\" \"]\ndirection LR\nRootInjector[\"(A) RootInjector\"]\nServicesA[\"CarService, EngineService, TiresService\"]\nend\n\nsubgraph B[\" \"]\ndirection LR\nParentInjector[\"(B) ParentInjector\"]\nServicesB[\"CarService2, EngineService2\"]\nend\n\nsubgraph C[\" \"]\ndirection LR\nChildInjector[\"(C) ChildInjector\"]\nServicesC[\"CarService3\"]\nend\n\ndirection LR\ncar[\"(C) Car\"]\nengine[\"(B) Engine\"]\ntires[\"(A) Tires\"]\n\ndirection BT\ncar-->ChildInjector\nChildInjector-->ParentInjector-->RootInjector\n\nclass car,engine,tires,RootInjector,ParentInjector,ChildInjector,ServicesA,ServicesB,ServicesC,A,B,C noShadow\nstyle car fill:#A9D18E,color:#000\nstyle ChildInjector fill:#A9D18E,color:#000\nstyle engine fill:#FFE699,color:#000\nstyle ParentInjector fill:#FFE699,color:#000\nstyle tires fill:#BDD7EE,color:#000\nstyle RootInjector fill:#BDD7EE,color:#000\n```\n\n## More on dependency injection\n\n<docs-pill-row>\n  <docs-pill href=\"/guide/di/dependency-injection-providers\" title=\"DI Providers\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 7488
  },
  {
    "id": 31,
    "file": "lightweight-injection-tokens",
    "fullFileName": "adev/src/content/guide/di/lightweight-injection-tokens.md",
    "startLine": 7492,
    "content": "# Optimizing client application size with lightweight injection tokens\n\nThis page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\nDesigning your library with *lightweight injection tokens* helps optimize the bundle size of client applications that use your library.\n\nYou can manage the dependency structure among your components and injectable services to optimize bundle size by using tree-shakable providers.\nThis normally ensures that if a provided component or service is never actually used by the application, the compiler can remove its code from the bundle.\n\nDue to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\nThis page describes a dependency injection design pattern that supports proper tree-shaking by using lightweight injection tokens.\n\nThe lightweight injection token design pattern is especially important for library developers.\nIt ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's application bundle.\n\nWhen an application uses your library, there might be some services that your library supplies which the client application doesn't use.\nIn this case, the application developer should expect that service to be tree-shaken, and not contribute to the size of the compiled application.\nBecause the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so.\nTo prevent the retention of unused components, your library should use the lightweight injection token design pattern.\n\n## When tokens are retained\n\nTo better explain the condition under which token retention occurs, consider a library that provides a library-card component.\nThis component contains a body and can contain an optional header:\n\n<docs-code language=\"html\">\n\n<lib-card>;\n  <lib-header>…</lib-header>;\n</lib-card>;\n\n</docs-code>\n\nIn a likely implementation, the `<lib-card>` component uses `@ContentChild()` or `@ContentChildren()` to get `<lib-header>` and `<lib-body>`, as in the following:\n\n<docs-code language=\"typescript\" highlight=\"[12]\">\n@Component({\n  selector: 'lib-header',\n  …,\n})\nclass LibHeaderComponent {}\n\n@Component({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @ContentChild(LibHeaderComponent) header: LibHeaderComponent|null = null;\n}\n\n</docs-code>\n\nBecause `<lib-header>` is optional, the element can appear in the template in its minimal form, `<lib-card></lib-card>`.\nIn this case, `<lib-header>` is not used and you would expect it to be tree-shaken, but that is not what happens.\nThis is because `LibCardComponent` actually contains two references to the `LibHeaderComponent`:\n\n<docs-code language=\"typescript\">\n@ContentChild(LibHeaderComponent) header: LibHeaderComponent;\n</docs-code>\n\n* One of these reference is in the *type position*-- that is, it specifies `LibHeaderComponent` as a type: `header: LibHeaderComponent;`.\n* The other reference is in the *value position*-- that is, LibHeaderComponent is the value of the `@ContentChild()` parameter decorator: `@ContentChild(LibHeaderComponent)`.\n\nThe compiler handles token references in these positions differently:\n\n* The compiler erases *type position* references after conversion from TypeScript, so they have no impact on tree-shaking.\n* The compiler must keep *value position* references at runtime, which **prevents** the component from being tree-shaken.\n\nIn the example, the compiler retains the `LibHeaderComponent` token that occurs in the value position.\nThis prevents the referenced component from being tree-shaken, even if the application does not actually use `<lib-header>` anywhere.\nIf `LibHeaderComponent` 's code, template, and styles combine to become too large, including it unnecessarily can significantly increase the size of the client application.\n\n## When to use the lightweight injection token pattern\n\nThe tree-shaking problem arises when a component is used as an injection token.\nThere are two cases when that can happen:\n\n* The token is used in the value position of a [content query](guide/components/queries#content-queries).\n* The token is used as a type specifier for constructor injection.\n\nIn the following example, both uses of the `OtherComponent` token cause retention of `OtherComponent`, preventing it from being tree-shaken when it is not used:\n\n<docs-code language=\"typescript\" highlight=\"[[2],[4]]\">\nclass MyComponent {\n  constructor(@Optional() other: OtherComponent) {}\n\n  @ContentChild(OtherComponent) other: OtherComponent|null;\n}\n</docs-code>\n\nAlthough tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for dependency injection are needed at runtime.\nThese effectively change `constructor(@Optional() other: OtherComponent)` to `constructor(@Optional() @Inject(OtherComponent) other)`.\nThe token is now in a value position, which causes the tree-shaker to keep the reference.\n\nHELPFUL: Libraries should use [tree-shakable providers](guide/di/dependency-injection#providing-dependency) for all services, providing dependencies at the root level rather than in components or modules.\n\n## Using lightweight injection tokens\n\nThe lightweight injection token design pattern consists of using a small abstract class as an injection token, and providing the actual implementation at a later stage.\nThe abstract class is retained, not tree-shaken, but it is small and has no material impact on the application size.\n\nThe following example shows how this works for the `LibHeaderComponent`:\n\n<docs-code language=\"typescript\" language=\"[[1],[6],[17]]\">\nabstract class LibHeaderToken {}\n\n@Component({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {}\n\n@Component({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;\n}\n</docs-code>\n\nIn this example, the `LibCardComponent` implementation no longer refers to `LibHeaderComponent` in either the type position or the value position.\nThis lets full tree-shaking of `LibHeaderComponent` take place.\nThe `LibHeaderToken` is retained, but it is only a class declaration, with no concrete implementation.\nIt is small and does not materially impact the application size when retained after compilation.\n\nInstead, `LibHeaderComponent` itself implements the abstract `LibHeaderToken` class.\nYou can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.\n\nTo summarize, the lightweight injection token pattern consists of the following:\n\n1. A lightweight injection token that is represented as an abstract class.\n1. A component definition that implements the abstract class.\n1. Injection of the lightweight pattern, using `@ContentChild()` or `@ContentChildren()`.\n1. A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation.\n\n### Use the lightweight injection token for API definition\n\nA component that injects a lightweight injection token might need to invoke a method in the injected class.\nThe token is now an abstract class. Since the injectable component implements that class, you must also declare an abstract method in the abstract lightweight injection token class.\nThe implementation of the method, with all its code overhead, resides in the injectable component that can be tree-shaken.\nThis lets the parent communicate with the child, if it is present, in a type-safe manner.\n\nFor example, the `LibCardComponent` now queries `LibHeaderToken` rather than `LibHeaderComponent`.\nThe following example shows how the pattern lets `LibCardComponent` communicate with the `LibHeaderComponent` without actually referring to `LibHeaderComponent`:\n\n<docs-code language=\"typescript\" highlight=\"[[3],[13,16],[27]]\">\nabstract class LibHeaderToken {\n  abstract doSomething(): void;\n}\n\n@Component({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {\n  doSomething(): void {\n    // Concrete implementation of `doSomething`\n  }\n}\n\n@Component({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent implement AfterContentInit {\n  @ContentChild(LibHeaderToken) header: LibHeaderToken|null = null;\n\n  ngAfterContentInit(): void {\n    if (this.header !== null) {\n      this.header?.doSomething();\n    }\n  }\n}\n</docs-code>\n\nIn this example, the parent queries the token to get the child component, and stores the resulting component reference if it is present.\nBefore calling a method in the child, the parent component checks to see if the child component is present.\nIf the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.\n\n### Naming your lightweight injection token\n\nLightweight injection tokens are only useful with components.\nThe Angular style guide suggests that you name components using the \"Component\" suffix.\nThe example \"LibHeaderComponent\" follows this convention.\n\nYou should maintain the relationship between the component and its token while still distinguishing between them.\nThe recommended style is to use the component base name with the suffix \"`Token`\" to name your lightweight injection tokens: \"`LibHeaderToken`.\"\n\n\n\n================================================\n",
    "endLine": 7687
  },
  {
    "id": 32,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/di/overview.md",
    "startLine": 7691,
    "content": "<docs-decorative-header title=\"Dependency injection in Angular\" imgSrc=\"adev/src/assets/images/dependency_injection.svg\"> <!-- markdownlint-disable-line -->\n\"DI\" is a design pattern and mechanism for creating and delivering some parts of an app to other parts of an app that require them.\n</docs-decorative-header>\n\nTIP: Check out Angular's [Essentials](essentials/dependency-injection) before diving into this comprehensive guide.\n\nWhen you develop a smaller part of your system, like a module or a class, you may need to use features from other classes. For example, you may need an HTTP service to make backend calls. Dependency Injection, or DI, is a design pattern and mechanism for creating and delivering some parts of an application to other parts of an application that require them. Angular supports this design pattern and you can use it in your applications to increase flexibility and modularity.\n\nIn Angular, dependencies are typically services, but they also can be values, such as strings or functions. An injector for an application (created automatically during bootstrap) instantiates dependencies when needed, using a configured provider of the service or value.\n\n## Learn about Angular dependency injection\n\n<docs-card-container>\n  <docs-card title=\"Understanding dependency injection\" href=\"/guide/di/dependency-injection\">\n    Learn basic principles of dependency injection in Angular.\n  </docs-card>\n  <docs-card title=\"Creating and injecting service\" href=\"/guide/di/creating-injectable-service\">\n    Describes how to create a service and inject it in other services and components.\n  </docs-card>\n  <docs-card title=\"Configuring dependency providers\" href=\"/guide/di/dependency-injection-providers\">\n    Describes how to configure dependencies using the providers field on the @Component and @NgModule decorators. Also describes how to use InjectionToken to provide and inject values in DI, which can be helpful when you want to use a value other than classes as dependencies.\n  </docs-card>\n    <docs-card title=\"Injection context\" href=\"/guide/di/dependency-injection-context\">\n    Describes what an injection context is and how to use the DI system where you need it.\n  </docs-card>\n  <docs-card title=\"Hierarchical injectors\" href=\"/guide/di/hierarchical-dependency-injection\">\n    Hierarchical DI enables you to share dependencies between different parts of the application only when and if you need to. This is an advanced topic.\n  </docs-card>\n</docs-card-container>\n\n\n\n================================================\n",
    "endLine": 7722
  },
  {
    "id": 33,
    "file": "attribute-directives",
    "fullFileName": "adev/src/content/guide/directives/attribute-directives.md",
    "startLine": 7726,
    "content": "# Attribute directives\n\nChange the appearance or behavior of DOM elements and Angular components with attribute directives.\n\n## Building an attribute directive\n\nThis section walks you through creating a highlight directive that sets the background color of the host element to yellow.\n\n1. To create a directive, use the CLI command [`ng generate directive`](tools/cli/schematics).\n\n    <docs-code language=\"shell\">\n\n    ng generate directive highlight\n\n    </docs-code>\n\n    The CLI creates `src/app/highlight.directive.ts`, a corresponding test file `src/app/highlight.directive.spec.ts`.\n\n    <docs-code header=\"src/app/highlight.directive.ts\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.0.ts\"/>\n\n    The `@Directive()` decorator's configuration property specifies the directive's CSS attribute selector, `[appHighlight]`.\n\n1. Import `ElementRef` from `@angular/core`.\n    `ElementRef` grants direct access to the host DOM element through its `nativeElement` property.\n\n1. Add `ElementRef` in the directive's `constructor()` to [inject](guide/di) a reference to the host DOM element, the element to which you apply `appHighlight`.\n\n1. Add logic to the `HighlightDirective` class that sets the background to yellow.\n\n    <docs-code header=\"src/app/highlight.directive.ts\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.1.ts\"/>\n\nHELPFUL: Directives *do not* support namespaces.\n\n<docs-code header=\"src/app/app.component.avoid.html (unsupported)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.avoid.html\" visibleRegion=\"unsupported\"/>\n\n## Applying an attribute directive\n\n1. To use the `HighlightDirective`, add a `<p>` element to the HTML template with the directive as an attribute.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.1.html\" visibleRegion=\"applied\"/>\n\nAngular creates an instance of the `HighlightDirective` class and injects a reference to the `<p>` element into the directive's constructor, which sets the `<p>` element's background style to yellow.\n\n## Handling user events\n\nThis section shows you how to detect when a user mouses into or out of the element and to respond by setting or clearing the highlight color.\n\n1. Import `HostListener` from '@angular/core'.\n\n    <docs-code header=\"src/app/highlight.directive.ts (imports)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.2.ts\" visibleRegion=\"imports\"/>\n\n1. Add two event handlers that respond when the mouse enters or leaves, each with the `@HostListener()` decorator.\n\n    <docs-code header=\"src/app/highlight.directive.ts (mouse-methods)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.2.ts\" visibleRegion=\"mouse-methods\"/>\n\nSubscribe to events of the DOM element that hosts an attribute directive, the `<p>` in this case, with the `@HostListener()` decorator.\n\nHELPFUL: The handlers delegate to a helper method, `highlight()`, that sets the color on the host DOM element, `el`.\n\nThe complete directive is as follows:\n\n<docs-code header=\"src/app/highlight.directive.ts\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.2.ts\"/>\n\nThe background color appears when the pointer hovers over the paragraph element and disappears as the pointer moves out.\n\n<img alt=\"Second Highlight\" src=\"assets/images/guide/attribute-directives/highlight-directive-anim.gif\">\n\n## Passing values into an attribute directive\n\nThis section walks you through setting the highlight color while applying the `HighlightDirective`.\n\n1. In `highlight.directive.ts`, import `Input` from `@angular/core`.\n\n    <docs-code header=\"src/app/highlight.directive.ts (imports)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.3.ts\" visibleRegion=\"imports\"/>\n\n1. Add an `appHighlight` `@Input()` property.\n\n    <docs-code header=\"src/app/highlight.directive.ts\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.3.ts\" visibleRegion=\"input\"/>\n\n    The `@Input()` decorator adds metadata to the class that makes the directive's `appHighlight` property available for binding.\n\n1. In `app.component.ts`, add a `color` property to the `AppComponent`.\n\n    <docs-code header=\"src/app/app.component.ts (class)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.1.ts\" visibleRegion=\"class\"/>\n\n1. To simultaneously apply the directive and the color, use property binding with the `appHighlight` directive selector, setting it equal to `color`.\n\n    <docs-code header=\"src/app/app.component.html (color)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.html\" visibleRegion=\"color\"/>\n\n    The `[appHighlight]` attribute binding performs two tasks:\n\n    * Applies the highlighting directive to the `<p>` element\n    * Sets the directive's highlight color with a property binding\n\n### Setting the value with user input\n\nThis section guides you through adding radio buttons to bind your color choice to the `appHighlight` directive.\n\n1. Add markup to `app.component.html` for choosing a color as follows:\n\n    <docs-code header=\"src/app/app.component.html (v2)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.html\" visibleRegion=\"v2\"/>\n\n1. Revise the `AppComponent.color` so that it has no initial value.\n\n    <docs-code header=\"src/app/app.component.ts (class)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.ts\" visibleRegion=\"class\"/>\n\n1. In `highlight.directive.ts`, revise `onMouseEnter` method so that it first tries to highlight with `appHighlight` and falls back to `red` if `appHighlight` is `undefined`.\n\n    <docs-code header=\"src/app/highlight.directive.ts (mouse-enter)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.3.ts\" visibleRegion=\"mouse-enter\"/>\n\n1. Serve your application to verify that the user can choose the color with the radio buttons.\n\n    <img alt=\"Animated gif of the refactored highlight directive changing color according to the radio button the user selects\" src=\"assets/images/guide/attribute-directives/highlight-directive-v2-anim.gif\">\n\n## Binding to a second property\n\nThis section guides you through configuring your application so the developer can set the default color.\n\n1. Add a second `Input()` property to `HighlightDirective` called `defaultColor`.\n\n    <docs-code header=\"src/app/highlight.directive.ts (defaultColor)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.ts\" visibleRegion=\"defaultColor\"/>\n\n1. Revise the directive's `onMouseEnter` so that it first tries to highlight with the `appHighlight`, then with the `defaultColor`, and falls back to `red` if both properties are `undefined`.\n\n    <docs-code header=\"src/app/highlight.directive.ts (mouse-enter)\" path=\"adev/src/content/examples/attribute-directives/src/app/highlight.directive.ts\" visibleRegion=\"mouse-enter\"/>\n\n1. To bind to the `AppComponent.color` and fall back to \"violet\" as the default color, add the following HTML.\n    In this case,  the `defaultColor` binding doesn't use square brackets, `[]`, because it is static.\n\n    <docs-code header=\"src/app/app.component.html (defaultColor)\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.html\" visibleRegion=\"defaultColor\"/>\n\n    As with components, you can add multiple directive property bindings to a host element.\n\nThe default color is red if there is no default color binding.\nWhen the user chooses a color the selected color becomes the active highlight color.\n\n<img alt=\"Animated gif of final highlight directive that shows red color with no binding and violet with the default color set. When user selects color, the selection takes precedence.\" src=\"assets/images/guide/attribute-directives/highlight-directive-final-anim.gif\">\n\n## Deactivating Angular processing with `NgNonBindable`\n\nTo prevent expression evaluation in the browser, add `ngNonBindable` to the host element.\n`ngNonBindable` deactivates interpolation, directives, and binding in templates.\n\nIn the following example, the expression `{{ 1 + 1 }}` renders just as it does in your code editor, and does not display `2`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.html\" visibleRegion=\"ngNonBindable\"/>\n\nApplying `ngNonBindable` to an element stops binding for that element's child elements.\nHowever, `ngNonBindable` still lets directives work on the element where you apply `ngNonBindable`.\nIn the following example, the `appHighlight` directive is still active but Angular does not evaluate the expression `{{ 1 + 1 }}`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/attribute-directives/src/app/app.component.html\" visibleRegion=\"ngNonBindable-with-directive\"/>\n\nIf you apply `ngNonBindable` to a parent element, Angular disables interpolation and binding of any sort, such as property binding or event binding, for the element's children.\n\n\n\n================================================\nFILE: adev/src/content/guide/directives/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"directives\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:directives.svg\",\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 7901
  },
  {
    "id": 34,
    "file": "directive-composition-api",
    "fullFileName": "adev/src/content/guide/directives/directive-composition-api.md",
    "startLine": 7905,
    "content": "# Directive composition API\n\nAngular directives offer a great way to encapsulate reusable behaviors— directives can apply\nattributes, CSS classes, and event listeners to an element.\n\nThe *directive composition API* lets you apply directives to a component's host element from\n*within* the component TypeScript class.\n\n## Adding directives to a component\n\nYou apply directives to a component by adding a `hostDirectives` property to a component's\ndecorator. We call such directives *host directives*.\n\nIn this example, we apply the directive `MenuBehavior` to the host element of `AdminMenu`. This\nworks similarly to applying the `MenuBehavior` to the `<admin-menu>` element in a template.\n\n```typescript\n@Component({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n```\n\nWhen the framework renders a component, Angular also creates an instance of each host directive. The\ndirectives' host bindings apply to the component's host element. By default, host directive inputs\nand outputs are not exposed as part of the component's public API. See\n[Including inputs and outputs](#including-inputs-and-outputs) below for more information.\n\n**Angular applies host directives statically at compile time.** You cannot dynamically add\ndirectives at runtime.\n\n**Directives used in `hostDirectives` may not specify `standalone: false`.**\n\n**Angular ignores the `selector` of directives applied in the `hostDirectives` property.**\n\n## Including inputs and outputs\n\nWhen you apply `hostDirectives` to your component, the inputs and outputs from the host directives\nare not included in your component's API by default. You can explicitly include inputs and outputs\nin your component's API by expanding the entry in `hostDirectives`:\n\n```typescript\n@Component({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n```\n\nBy explicitly specifying the inputs and outputs, consumers of the component with `hostDirective` can\nbind them in a template:\n\n```angular-html\n\n<admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\">\n```\n\nFurthermore, you can alias inputs and outputs from `hostDirective` to customize the API of your\ncomponent:\n\n```typescript\n@Component({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n```\n\n```angular-html\n\n<admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\">\n```\n\n## Adding directives to another directive\n\nYou can also add `hostDirectives` to other directives, in addition to components. This enables the\ntransitive aggregation of multiple behaviors.\n\nIn the following example, we define two directives, `Menu` and `Tooltip`. We then compose the behavior\nof these two directives in `MenuWithTooltip`. Finally, we apply `MenuWithTooltip`\nto `SpecializedMenuWithTooltip`.\n\nWhen `SpecializedMenuWithTooltip` is used in a template, it creates instances of all of `Menu`\n, `Tooltip`, and `MenuWithTooltip`. Each of these directives' host bindings apply to the host\nelement of `SpecializedMenuWithTooltip`.\n\n```typescript\n@Directive({...})\nexport class Menu { }\n\n@Directive({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from multiple other directives\n@Directive({\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@Directive({\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n```\n\n## Host directive semantics\n\n### Directive execution order\n\nHost directives go through the same lifecycle as components and directives used directly in a\ntemplate. However, host directives always execute their constructor, lifecycle hooks, and bindings _before_ the component or directive on which they are applied.\n\nThe following example shows minimal use of a host directive:\n\n```typescript\n@Component({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n```\n\nThe order of execution here is:\n\n1. `MenuBehavior` instantiated\n2. `AdminMenu` instantiated\n3. `MenuBehavior` receives inputs (`ngOnInit`)\n4. `AdminMenu` receives inputs (`ngOnInit`)\n5. `MenuBehavior` applies host bindings\n6. `AdminMenu` applies host bindings\n\nThis order of operations means that components with `hostDirectives` can override any host bindings\nspecified by a host directive.\n\nThis order of operations extends to nested chains of host directives, as shown in the following\nexample.\n\n```typescript\n@Directive({...})\nexport class Tooltip { }\n\n@Directive({\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@Directive({\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n```\n\nIn the example above, the order of execution is:\n\n1. `Tooltip` instantiated\n2. `CustomTooltip` instantiated\n3. `EvenMoreCustomTooltip` instantiated\n4. `Tooltip` receives inputs (`ngOnInit`)\n5. `CustomTooltip` receives inputs (`ngOnInit`)\n6. `EvenMoreCustomTooltip` receives inputs (`ngOnInit`)\n7. `Tooltip` applies host bindings\n8. `CustomTooltip` applies host bindings\n9. `EvenMoreCustomTooltip` applies host bindings\n\n### Dependency injection\n\nA component or directive that specifies `hostDirectives` can inject the instances of those host\ndirectives and vice versa.\n\nWhen applying host directives to a component, both the component and host directives can define\nproviders.\n\nIf a component or directive with `hostDirectives` and those host directives both provide the same\ninjection token, the providers defined by class with `hostDirectives` take precedence over providers\ndefined by the host directives.\n\n\n\n================================================\n",
    "endLine": 8096
  },
  {
    "id": 35,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/directives/overview.md",
    "startLine": 8100,
    "content": "<docs-decorative-header title=\"Built-in directives\" imgSrc=\"adev/src/assets/images/directives.svg\"> <!-- markdownlint-disable-line -->\nDirectives are classes that add additional behavior to elements in your Angular applications.\n</docs-decorative-header>\n\nUse Angular's built-in directives to manage forms, lists, styles, and what users see.\n\nThe different types of Angular directives are as follows:\n\n| Directive Types                                          | Details                                                                           |\n| :------------------------------------------------------- | :-------------------------------------------------------------------------------- |\n| [Components](guide/components)                           | Used with a template. This type of directive is the most common directive type.   |\n| [Attribute directives](#built-in-attribute-directives)   | Change the appearance or behavior of an element, component, or another directive. |\n| [Structural directives](#built-in-structural-directives) | Change the DOM layout by adding and removing DOM elements.                        |\n\nThis guide covers built-in [attribute directives](#built-in-attribute-directives) and [structural directives](#built-in-structural-directives).\n\n## Built-in attribute directives\n\nAttribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components.\n\nThe most common attribute directives are as follows:\n\n| Common directives                                             | Details                                            |\n| :------------------------------------------------------------ | :------------------------------------------------- |\n| [`NgClass`](#adding-and-removing-classes-with-ngclass)        | Adds and removes a set of CSS classes.             |\n| [`NgStyle`](#setting-inline-styles-with-ngstyle)              | Adds and removes a set of HTML styles.             |\n| [`NgModel`](#displaying-and-updating-properties-with-ngmodel) | Adds two-way data binding to an HTML form element. |\n\nHELPFUL: Built-in directives use only public APIs. They do not have special access to any private APIs that other directives can't access.\n\n## Adding and removing classes with `NgClass`\n\nAdd or remove multiple CSS classes simultaneously with `ngClass`.\n\nHELPFUL: To add or remove a _single_ class, use [class binding](guide/templates/class-binding) rather than `NgClass`.\n\n### Import `NgClass` in the component\n\nTo use `NgClass`, add it to the component's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (NgClass import)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-ng-class\"/>\n\n### Using `NgClass` with an expression\n\nOn the element you'd like to style, add `[ngClass]` and set it equal to an expression.\nIn this case, `isSpecial` is a boolean set to `true` in `app.component.ts`.\nBecause `isSpecial` is true, `ngClass` applies the class of `special` to the `<div>`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"special-div\"/>\n\n### Using `NgClass` with a method\n\n1. To use `NgClass` with a method, add the method to the component class.\n   In the following example, `setCurrentClasses()` sets the property `currentClasses` with an object that adds or removes three classes based on the `true` or `false` state of three other component properties.\n\n   Each key of the object is a CSS class name.\n   If a key is `true`, `ngClass` adds the class.\n   If a key is `false`, `ngClass` removes the class.\n\n   <docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"setClasses\"/>\n\n1. In the template, add the `ngClass` property binding to `currentClasses` to set the element's classes:\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgClass-1\"/>\n\nFor this use case, Angular applies the classes on initialization and in case of changes caused by reassigning the `currentClasses` object.\nThe full example calls `setCurrentClasses()` initially with `ngOnInit()` when the user clicks on the `Refresh currentClasses` button.\nThese steps are not necessary to implement `ngClass`.\n\n## Setting inline styles with `NgStyle`\n\nHELPFUL: To add or remove a _single_ style, use [style bindings](guide/templates/binding#css-class-and-style-property-bindings) rather than `NgStyle`.\n\n### Import `NgStyle` in the component\n\nTo use `NgStyle`, add it to the component's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (NgStyle import)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-ng-style\"/>\n\nUse `NgStyle` to set multiple inline styles simultaneously, based on the state of the component.\n\n1. To use `NgStyle`, add a method to the component class.\n\n   In the following example, `setCurrentStyles()` sets the property `currentStyles` with an object that defines three styles, based on the state of three other component properties.\n\n   <docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"setStyles\"/>\n\n1. To set the element's styles, add an `ngStyle` property binding to `currentStyles`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgStyle-2\"/>\n\nFor this use case, Angular applies the styles upon initialization and in case of changes.\nTo do this, the full example calls `setCurrentStyles()` initially with `ngOnInit()` and when the dependent properties change through a button click.\nHowever, these steps are not necessary to implement `ngStyle` on its own.\n\n## Displaying and updating properties with `ngModel`\n\nUse the `NgModel` directive to display a data property and update that property when the user makes changes.\n\n1. Import `FormsModule` and add it to the AppComponent's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (FormsModule import)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-forms-module\" />\n\n1. Add an `[(ngModel)]` binding on an HTML `<form>` element and set it equal to the property, here `name`.\n\n   <docs-code header=\"src/app/app.component.html (NgModel example)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgModel-1\"/>\n\n   This `[(ngModel)]` syntax can only set a data-bound property.\n\nTo customize your configuration, write the expanded form, which separates the property and event binding.\nUse [property binding](guide/templates/property-binding) to set the property and [event binding](guide/templates/event-listeners) to respond to changes.\nThe following example changes the `<input>` value to uppercase:\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"uppercase\"/>\n\nHere are all variations in action, including the uppercase version:\n\n<img alt=\"NgModel variations\" src=\"assets/images/guide/built-in-directives/ng-model-anim.gif\">\n\n### `NgModel` and value accessors\n\nThe `NgModel` directive works for an element supported by a [ControlValueAccessor](api/forms/ControlValueAccessor).\nAngular provides _value accessors_ for all of the basic HTML form elements.\nFor more information, see [Forms](guide/forms).\n\nTo apply `[(ngModel)]` to a non-form built-in element or a third-party custom component, you have to write a value accessor.\nFor more information, see the API documentation on [DefaultValueAccessor](api/forms/DefaultValueAccessor).\n\nHELPFUL: When you write an Angular component, you don't need a value accessor or `NgModel` if you name the value and event properties according to Angular's [two-way binding syntax](guide/templates/two-way-binding#how-two-way-binding-works).\n\n## Built-in structural directives\n\nStructural directives are responsible for HTML layout.\nThey shape or reshape the DOM's structure, typically by adding, removing, and manipulating the host elements to which they are attached.\n\nThis section introduces the most common built-in structural directives:\n\n| Common built-in structural directives              | Details                                                          |\n| :------------------------------------------------- | :--------------------------------------------------------------- |\n| [`NgIf`](#adding-or-removing-an-element-with-ngif) | Conditionally creates or disposes of subviews from the template. |\n| [`NgFor`](#listing-items-with-ngfor)               | Repeat a node for each item in a list.                           |\n| [`NgSwitch`](#switching-cases-with-ngswitch)       | A set of directives that switch among alternative views.         |\n\nFor more information, see [Structural Directives](guide/directives/structural-directives).\n\n## Adding or removing an element with `NgIf`\n\nAdd or remove an element by applying an `NgIf` directive to a host element.\n\nWhen `NgIf` is `false`, Angular removes an element and its descendants from the DOM.\nAngular then disposes of their components, which frees up memory and resources.\n\n### Import `NgIf` in the component\n\nTo use `NgIf`, add it to the component's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (NgIf import)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-ng-if\"/>\n\n### Using `NgIf`\n\nTo add or remove an element, bind `*ngIf` to a condition expression such as `isActive` in the following example.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgIf-1\"/>\n\nWhen the `isActive` expression returns a truthy value, `NgIf` adds the `ItemDetailComponent` to the DOM.\nWhen the expression is falsy, `NgIf` removes the `ItemDetailComponent` from the DOM and disposes of the component and all of its subcomponents.\n\nFor more information on `NgIf` and `NgIfElse`, see the [NgIf API documentation](api/common/NgIf).\n\n### Guarding against `null`\n\nBy default, `NgIf` prevents display of an element bound to a null value.\n\nTo use `NgIf` to guard a `<div>`, add `*ngIf=\"yourProperty\"` to the `<div>`.\nIn the following example, the `currentCustomer` name appears because there is a `currentCustomer`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgIf-2\"/>\n\nHowever, if the property is `null`, Angular does not display the `<div>`.\nIn this example, Angular does not display the `nullCustomer` because it is `null`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgIf-2b\"/>\n\n## Listing items with `NgFor`\n\nUse the `NgFor` directive to present a list of items.\n\n### Import `NgFor` in the component\n\nTo use `NgFor`, add it to the component's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (NgFor import)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-ng-for\"/>\n\n### Using `NgFor`\n\nTo use `NgFor`, you have to:\n\n1. Define a block of HTML that determines how Angular renders a single item.\n1. To list your items, assign the shorthand `let item of items` to `*ngFor`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgFor-1\"/>\n\nThe string `\"let item of items\"` instructs Angular to do the following:\n\n- Store each item in the `items` array in the local `item` looping variable\n- Make each item available to the templated HTML for each iteration\n- Translate `\"let item of items\"` into an `<ng-template>` around the host element\n- Repeat the `<ng-template>` for each `item` in the list\n\nFor more information see the [Structural directive shorthand](guide/directives/structural-directives#structural-directive-shorthand) section of [Structural directives](guide/directives/structural-directives).\n\n### Repeating a component view\n\nTo repeat a component element, apply `*ngFor` to the selector.\nIn the following example, the selector is `<app-item-detail>`.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgFor-2\"/>\n\nReference a template input variable, such as `item`, in the following locations:\n\n- Within the `ngFor` host element\n- Within the host element descendants to access the item's properties\n\nThe following example references `item` first in an interpolation and then passes in a binding to the `item` property of the `<app-item-detail>` component.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgFor-1-2\"/>\n\nFor more information about template input variables, see [Structural directive shorthand](guide/directives/structural-directives#structural-directive-shorthand).\n\n### Getting the `index` of `*ngFor`\n\nGet the `index` of `*ngFor` in a template input variable and use it in the template.\n\nIn the `*ngFor`, add a semicolon and `let i=index` to the shorthand.\nThe following example gets the `index` in a variable named `i` and displays it with the item name.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgFor-3\"/>\n\nThe index property of the `NgFor` directive context returns the zero-based index of the item in each iteration.\n\nAngular translates this instruction into an `<ng-template>` around the host element,\nthen uses this template repeatedly to create a new set of elements and bindings for each `item`\nin the list.\nFor more information about shorthand, see the [Structural Directives](guide/directives/structural-directives#structural-directive-shorthand) guide.\n\n## Repeating elements when a condition is true\n\nTo repeat a block of HTML when a particular condition is true, put the `*ngIf` on a container element that wraps an `*ngFor` element.\n\nFor more information see [one structural directive per element](guide/directives/structural-directives#one-structural-directive-per-element).\n\n### Tracking items with `*ngFor` `trackBy`\n\nReduce the number of calls your application makes to the server by tracking changes to an item list.\nWith the `*ngFor` `trackBy` property, Angular can change and re-render only those items that have changed, rather than reloading the entire list of items.\n\n1. Add a method to the component that returns the value `NgFor` should track.\nIn this example, the value to track is the item's `id`.\nIf the browser has already rendered `id`, Angular keeps track of it and doesn't re-query the server for the same `id`.\n\n<docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"trackByItems\"/>\n\n1. In the shorthand expression, set `trackBy` to the `trackByItems()` method.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"trackBy\"/>\n\n**Change ids** creates new items with new `item.id`s.\nIn the following illustration of the `trackBy` effect, **Reset items** creates new items with the same `item.id`s.\n\n- With no `trackBy`, both buttons trigger complete DOM element replacement.\n- With `trackBy`, only changing the `id` triggers element replacement.\n\n<img alt=\"Animation of trackBy\" src=\"assets/images/guide/built-in-directives/ngfor-trackby.gif\">\n\n## Hosting a directive without a DOM element\n\nThe Angular `<ng-container>` is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM.\n\nUse `<ng-container>` when there's no single element to host the directive.\n\nHere's a conditional paragraph using `<ng-container>`.\n\n<docs-code header=\"src/app/app.component.html (ngif-ngcontainer)\" path=\"adev/src/content/examples/structural-directives/src/app/app.component.html\" visibleRegion=\"ngif-ngcontainer\"/>\n\n<img alt=\"ngcontainer paragraph with proper style\" src=\"assets/images/guide/structural-directives/good-paragraph.png\">\n\n1. Import the `ngModel` directive from `FormsModule`.\n\n1. Add `FormsModule` to the imports section of the relevant Angular module.\n\n1. To conditionally exclude an `<option>`, wrap the `<option>` in an `<ng-container>`.\n\n   <docs-code header=\"src/app/app.component.html (select-ngcontainer)\" path=\"adev/src/content/examples/structural-directives/src/app/app.component.html\" visibleRegion=\"select-ngcontainer\"/>\n\n   <img alt=\"ngcontainer options work properly\" src=\"assets/images/guide/structural-directives/select-ngcontainer-anim.gif\">\n\n## Switching cases with `NgSwitch`\n\nLike the JavaScript `switch` statement, `NgSwitch` displays one element from among several possible elements, based on a switch condition.\nAngular puts only the selected element into the DOM.\n\n<!--todo: API Flagged -->\n\n`NgSwitch` is a set of three directives:\n\n| `NgSwitch` directives | Details                                                                                                                                                                |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `NgSwitch`            | An attribute directive that changes the behavior of its companion directives.                                                                                          |\n| `NgSwitchCase`        | Structural directive that adds its element to the DOM when its bound value equals the switch value and removes its bound value when it doesn't equal the switch value. |\n| `NgSwitchDefault`     | Structural directive that adds its element to the DOM when there is no selected `NgSwitchCase`.                                                                        |\n\nTo use the directives, add the `NgSwitch`, `NgSwitchCase` and `NgSwitchDefault` to the component's `imports` list.\n\n<docs-code header=\"src/app/app.component.ts (NgSwitch imports)\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"import-ng-switch\"/>\n\n### Using `NgSwitch`\n\n1. On an element, such as a `<div>`, add `[ngSwitch]` bound to an expression that returns the switch value, such as `feature`.\n   Though the `feature` value in this example is a string, the switch value can be of any type.\n\n1. Bind to `*ngSwitchCase` and `*ngSwitchDefault` on the elements for the cases.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgSwitch\"/>\n\n1. In the parent component, define `currentItem`, to use it in the `[ngSwitch]` expression.\n\n<docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.ts\" visibleRegion=\"item\"/>\n\n1. In each child component, add an `item` [input property](guide/components/inputs) which is bound to the `currentItem` of the parent component.\n   The following two snippets show the parent component and one of the child components.\n   The other child components are identical to `StoutItemComponent`.\n\n   <docs-code header=\"In each child component, here StoutItemComponent\" path=\"adev/src/content/examples/built-in-directives/src/app/item-switch.component.ts\" visibleRegion=\"input\"/>\n\n   <img alt=\"Animation of NgSwitch\" src=\"assets/images/guide/built-in-directives/ngswitch.gif\">\n\nSwitch directives also work with built-in HTML elements and web components.\nFor example, you could replace the `<app-best-item>` switch case with a `<div>` as follows.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/built-in-directives/src/app/app.component.html\" visibleRegion=\"NgSwitch-div\"/>\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/directives/attribute-directives\" title=\"Attribute Directives\"/>\n  <docs-pill href=\"guide/directives/structural-directives\" title=\"Structural Directives\"/>\n  <docs-pill href=\"guide/directives/directive-composition-api\" title=\"Directive composition API\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 8450
  },
  {
    "id": 36,
    "file": "structural-directives",
    "fullFileName": "adev/src/content/guide/directives/structural-directives.md",
    "startLine": 8454,
    "content": "# Structural directives\n\nStructural directives are directives applied to an `<ng-template>` element that conditionally or repeatedly render the content of that `<ng-template>`.\n\n## Example use case\n\nIn this guide you'll build a structural directive which fetches data from a given data source and renders its template when that data is available. This directive is called `SelectDirective`, after the SQL keyword `SELECT`, and match it with an attribute selector `[select]`.\n\n`SelectDirective` will have an input naming the data source to be used, which you will call `selectFrom`. The `select` prefix for this input is important for the [shorthand syntax](#structural-directive-shorthand). The directive will instantiate its `<ng-template>` with a template context providing the selected data.\n\nThe following is an example of using this directive directly on an `<ng-template>` would look like:\n\n```angular-html\n<ng-template select let-data [selectFrom]=\"source\">\n  <p>The data is: {{ data }}</p>\n</ng-template>\n```\n\nThe structural directive can wait for the data to become available and then render its `<ng-template>`.\n\nHELPFUL: Note that Angular's `<ng-template>` element defines a template that doesn't render anything by default, if you just wrap elements in an `<ng-template>` without applying a structural directive those elements will not be rendered.\n\nFor more information, see the [ng-template API](api/core/ng-template) documentation.\n\n## Structural directive shorthand\n\nAngular supports a shorthand syntax for structural directives which avoids the need to explicitly author an `<ng-template>` element.\n\nStructural directives can be applied directly on an element by prefixing the directive attribute selector with an asterisk (`*`), such as `*select`. Angular transforms the asterisk in front of a structural directive into an `<ng-template>` that hosts the directive and surrounds the element and its descendants.\n\nYou can use this with `SelectDirective` as follows:\n\n```angular-html\n<p *select=\"let data from source\">The data is: {{data}}</p>\n```\n\nThis example shows the flexibility of structural directive shorthand syntax, which is sometimes called _microsyntax_.\n\nWhen used in this way, only the structural directive and its bindings are applied to the `<ng-template>`. Any other attributes or bindings on the `<p>` tag are left alone. For example, these two forms are equivalent:\n\n```angular-html\n<!-- Shorthand syntax: -->\n<p class=\"data-view\" *select=\"let data from source\">The data is: {{data}}</p>\n\n<!-- Long-form syntax: -->\n<ng-template select let-data [selectFrom]=\"source\">\n  <p class=\"data-view\">The data is: {{data}}</p>\n</ng-template>\n```\n\nShorthand syntax is expanded through a set of conventions. A more thorough [grammar](#structural-directive-syntax-reference) is defined below, but in the above example, this transformation can be explained as follows:\n\nThe first part of the `*select` expression is `let data`, which declares a template variable `data`. Since no assignment follows, the template variable is bound to the template context property `$implicit`.\n\nThe second piece of syntax is a key-expression pair, `from source`. `from` is a binding key and `source` is a regular template expression. Binding keys are mapped to properties by transforming them to PascalCase and prepending the structural directive selector. The `from` key is mapped to `selectFrom`, which is then bound to the expression `source`. This is why many structural directives will have inputs that are all prefixed with the structural directive's selector.\n\n## One structural directive per element\n\nYou can only apply one structural directive per element when using the shorthand syntax. This is because there is only one `<ng-template>` element onto which that directive gets unwrapped. Multiple directives would require multiple nested `<ng-template>`, and it's unclear which directive should be first. `<ng-container>` can be used when to create wrapper layers when multiple structural directives need to be applied around the same physical DOM element or component, which allows the user to define the nested structure.\n\n## Creating a structural directive\n\nThis section guides you through creating the `SelectDirective`.\n\n<docs-workflow>\n<docs-step title=\"Generate the directive\">\nUsing the Angular CLI, run the following command, where `select` is the name of the directive:\n\n```shell\nng generate directive select\n```\n\nAngular creates the directive class and specifies the CSS selector, `[select]`, that identifies the directive in a template.\n</docs-step>\n<docs-step title=\"Make the directive structural\">\nImport `TemplateRef`, and `ViewContainerRef`. Inject `TemplateRef` and `ViewContainerRef` in the directive as private properties.\n\n```ts\nimport {Directive, TemplateRef, ViewContainerRef} from '@angular/core';\n\n@Directive({\n  selector: '[select]',\n})\nexport class SelectDirective {\n  private templateRef = inject(TemplateRef);\n  private ViewContainerRef = inject(ViewContainerRef);\n}\n\n```\n\n</docs-step>\n<docs-step title=\"Add the 'selectFrom' input\">\nAdd a `selectFrom` `@Input()` property.\n\n```ts\nexport class SelectDirective {\n  // ...\n\n  @Input({required: true}) selectFrom!: DataSource;\n}\n```\n\n</docs-step>\n<docs-step title=\"Add the business logic\">\nWith `SelectDirective` now scaffolded as a structural directive with its input, you can now add the logic to fetch the data and render the template with it:\n\n```ts\nexport class SelectDirective {\n  // ...\n\n  async ngOnInit() {\n    const data = await this.selectFrom.load();\n    this.viewContainerRef.createEmbeddedView(this.templateRef, {\n      // Create the embedded view with a context object that contains\n      // the data via the key `$implicit`.\n      $implicit: data,\n    });\n  }\n}\n```\n\n</docs-step>\n</docs-workflow>\n\nThat's it - `SelectDirective` is up and running. A follow-up step might be to [add template type-checking support](#typing-the-directives-context).\n\n## Structural directive syntax reference\n\nWhen you write your own structural directives, use the following syntax:\n\n<docs-code hideCopy language=\"typescript\">\n\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n\n</docs-code>\n\nThe following patterns describe each portion of the structural directive grammar:\n\n```ts\nas = :export \"as\" :local \";\"?\nkeyExp = :key \":\"? :expression (\"as\" :local)? \";\"?\nlet = \"let\" :local \"=\" :export \";\"?\n```\n\n| Keyword      | Details                                            |\n| :----------- | :------------------------------------------------- |\n| `prefix`     | HTML attribute key                                 |\n| `key`        | HTML attribute key                                 |\n| `local`      | Local variable name used in the template           |\n| `export`     | Value exported by the directive under a given name |\n| `expression` | Standard Angular expression                        |\n\n### How Angular translates shorthand\n\nAngular translates structural directive shorthand into the normal binding syntax as follows:\n\n| Shorthand | Translation |\n|:--- |:--- |\n| `prefix` and naked `expression` | `[prefix]=\"expression\"` |\n| `keyExp` | `[prefixKey]=\"expression\"` (The `prefix` is added to the `key`) |\n| `let local` | `let-local=\"export\"` |\n\n### Shorthand examples\n\nThe following table provides shorthand examples:\n\n| Shorthand | How Angular interprets the syntax |\n|:--- |:--- |\n| `*ngFor=\"let item of [1,2,3]\"` | `<ng-template ngFor let-item [ngForOf]=\"[1, 2, 3]\">` |\n| `*ngFor=\"let item of [1,2,3] as items; trackBy: myTrack; index as i\"` | `<ng-template ngFor let-item [ngForOf]=\"[1,2,3]\" let-items=\"ngForOf\" [ngForTrackBy]=\"myTrack\" let-i=\"index\">` |\n| `*ngIf=\"exp\"`| `<ng-template [ngIf]=\"exp\">` |\n| `*ngIf=\"exp as value\"` | `<ng-template [ngIf]=\"exp\" let-value=\"ngIf\">` |\n\n## Improving template type checking for custom directives\n\nYou can improve template type checking for custom directives by adding template guards to your directive definition.\nThese guards help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors.\nTwo different types of guards are possible:\n\n* `ngTemplateGuard_(input)` lets you control how an input expression should be narrowed based on the type of a specific input.\n* `ngTemplateContextGuard` is used to determine the type of the context object for the template, based on the type of the directive itself.\n\nThis section provides examples of both kinds of guards.\nFor more information, see [Template type checking](tools/cli/template-typecheck \"Template type-checking guide\").\n\n### Type narrowing with template guards\n\nA structural directive in a template controls whether that template is rendered at run time. Some structural directives want to perform type narrowing based on the type of input expression.\n\nThere are two narrowings which are possible with input guards:\n\n* Narrowing the input expression based on a TypeScript type assertion function.\n* Narrowing the input expression based on its truthiness.\n\nTo narrow the input expression by defining a type assertion function:\n\n```ts\n// This directive only renders its template if the actor is a user.\n// You want to assert that within the template, the type of the `actor`\n// expression is narrowed to `User`.\n@Directive(...)\nclass ActorIsUser {\n  @Input() actor: User|Robot;\n\n  static ngTemplateGuard_actor(dir: ActorIsUser, expr: User|Robot): expr is User {\n    // The return statement is unnecessary in practice, but included to\n    // prevent TypeScript errors.\n    return true;\n  }\n}\n```\n\nType-checking will behave within the template as if the `ngTemplateGuard_actor` has been asserted on the expression bound to the input.\n\nSome directives only render their templates when an input is truthy. It's not possible to capture the full semantics of truthiness in a type assertion function, so instead a literal type of `'binding'` can be used to signal to the template type-checker that the binding expression itself should be used as the guard:\n\n```ts\n@Directive(...)\nclass CustomIf {\n  @Input() condition!: any;\n\n  static ngTemplateGuard_condition: 'binding';\n}\n```\n\nThe template type-checker will behave as if the expression bound to `condition` was asserted to be truthy within the template.\n\n### Typing the directive's context\n\nIf your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static `ngTemplateContextGuard` type assertion function. This function can use the type of the directive to derive the type of the context, which is useful when the type of the directive is generic.\n\nFor the `SelectDirective` described above, you can implement an `ngTemplateContextGuard` to correctly specify the data type, even if the data source is generic.\n\n```ts\n// Declare an interface for the template context:\nexport interface SelectTemplateContext<T> {\n  $implicit: T;\n}\n\n@Directive(...)\nexport class SelectDirective<T> {\n  // The directive's generic type `T` will be inferred from the `DataSource` type\n  // passed to the input.\n  @Input({required: true}) selectFrom!: DataSource<T>;\n\n  // Narrow the type of the context using the generic type of the directive.\n  static ngTemplateContextGuard<T>(dir: SelectDirective<T>, ctx: any): ctx is SelectTemplateContext<T> {\n    // As before the guard body is not used at runtime, and included only to avoid\n    // TypeScript errors.\n    return true;\n  }\n}\n```\n\n\n\n================================================\nFILE: adev/src/content/guide/forms/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"forms\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:overview.svg\",\n        \"//adev/src/content/examples\",\n    ],\n    mermaid_blocks = True,\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 8729
  },
  {
    "id": 37,
    "file": "dynamic-forms",
    "fullFileName": "adev/src/content/guide/forms/dynamic-forms.md",
    "startLine": 8733,
    "content": "# Building dynamic forms\n\nMany forms, such as questionnaires, can be very similar to one another in format and intent.\nTo make it faster and easier to generate different versions of such a form, you can create a _dynamic form template_ based on metadata that describes the business object model.\nThen, use the template to generate new forms automatically, according to changes in the data model.\n\nThe technique is particularly useful when you have a type of form whose content must change frequently to meet rapidly changing business and regulatory requirements.\nA typical use-case is a questionnaire.\nYou might need to get input from users in different contexts.\nThe format and style of the forms a user sees should remain constant, while the actual questions you need to ask vary with the context.\n\nIn this tutorial you will build a dynamic form that presents a basic questionnaire.\nYou build an online application for heroes seeking employment.\nThe agency is constantly tinkering with the application process, but by using the dynamic form\nyou can create the new forms on the fly without changing the application code.\n\nThe tutorial walks you through the following steps.\n\n1. Enable reactive forms for a project.\n1. Establish a data model to represent form controls.\n1. Populate the model with sample data.\n1. Develop a component to create form controls dynamically.\n\nThe form you create uses input validation and styling to improve the user experience.\nIt has a Submit button that is only enabled when all user input is valid, and flags invalid input with color coding and error messages.\n\nThe basic version can evolve to support a richer variety of questions, more graceful rendering, and superior user experience.\n\n## Enable reactive forms for your project\n\nDynamic forms are based on reactive forms.\n\nTo give the application access reactive forms directives, import `ReactiveFormsModule` from the `@angular/forms` library into the necessary components.\n\n<docs-code-multifile>\n    <docs-code header=\"dynamic-form.component.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form.component.ts\"/>\n    <docs-code header=\"dynamic-form-question.component.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form-question.component.ts\"/>\n</docs-code-multifile>\n\n## Create a form object model\n\nA dynamic form requires an object model that can describe all scenarios needed by the form functionality.\nThe example hero-application form is a set of questions — that is, each control in the form must ask a question and accept an answer.\n\nThe data model for this type of form must represent a question.\nThe example includes the `DynamicFormQuestionComponent`, which defines a question as the fundamental object in the model.\n\nThe following `QuestionBase` is a base class for a set of controls that can represent the question and its answer in the form.\n\n<docs-code header=\"src/app/question-base.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/question-base.ts\"/>\n\n### Define control classes\n\nFrom this base, the example derives two new classes, `TextboxQuestion` and `DropdownQuestion`, that represent different control types.\nWhen you create the form template in the next step, you instantiate these specific question types in order to render the appropriate controls dynamically.\n\nThe `TextboxQuestion` control type is represented in a form template using an `<input>` element. It presents a question and lets users enter input. The `type` attribute of the element is defined based on the `type` field specified in the `options` argument (for example `text`, `email`, `url`).\n\n<docs-code header=\"question-textbox.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/question-textbox.ts\"/>\n\nThe `DropdownQuestion` control type presents a list of choices in a select box.\n\n <docs-code header=\"question-dropdown.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/question-dropdown.ts\"/>\n\n### Compose form groups\n\nA dynamic form uses a service to create grouped sets of input controls, based on the form model.\nThe following `QuestionControlService` collects a set of `FormGroup` instances that consume the metadata from the question model.\nYou can specify default values and validation rules.\n\n<docs-code header=\"src/app/question-control.service.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/question-control.service.ts\"/>\n\n## Compose dynamic form contents\n\nThe dynamic form itself is represented by a container component, which you add in a later step.\nEach question is represented in the form component's template by an `<app-question>` tag, which matches an instance of `DynamicFormQuestionComponent`.\n\nThe `DynamicFormQuestionComponent` is responsible for rendering the details of an individual question based on values in the data-bound question object.\nThe form relies on a [`[formGroup]` directive](api/forms/FormGroupDirective \"API reference\") to connect the template HTML to the underlying control objects.\nThe `DynamicFormQuestionComponent` creates form groups and populates them with controls defined in the question model, specifying display and validation rules.\n\n<docs-code-multifile>\n  <docs-code header=\"dynamic-form-question.component.html\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form-question.component.html\"/>\n  <docs-code header=\"dynamic-form-question.component.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form-question.component.ts\"/>\n</docs-code-multifile>\n\nThe goal of the `DynamicFormQuestionComponent` is to present question types defined in your model.\nYou only have two types of questions at this point but you can imagine many more.\nThe `ngSwitch` statement in the template determines which type of question to display.\nThe switch uses directives with the [`formControlName`](api/forms/FormControlName \"FormControlName directive API reference\") and [`formGroup`](api/forms/FormGroupDirective \"FormGroupDirective API reference\") selectors.\nBoth directives are defined in `ReactiveFormsModule`.\n\n### Supply data\n\nAnother service is needed to supply a specific set of questions from which to build an individual form.\nFor this exercise you create the `QuestionService` to supply this array of questions from the hard-coded sample data.\nIn a real-world app, the service might fetch data from a backend system.\nThe key point, however, is that you control the hero job-application questions entirely through the objects returned from `QuestionService`.\nTo maintain the questionnaire as requirements change, you only need to add, update, and remove objects from the `questions` array.\n\nThe `QuestionService` supplies a set of questions in the form of an array bound to `@Input()` questions.\n\n<docs-code header=\"src/app/question.service.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/question.service.ts\"/>\n\n## Create a dynamic form template\n\nThe `DynamicFormComponent` component is the entry point and the main container for the form, which is represented using the `<app-dynamic-form>` in a template.\n\nThe `DynamicFormComponent` component presents a list of questions by binding each one to an `<app-question>` element that matches the `DynamicFormQuestionComponent`.\n\n<docs-code-multifile>\n    <docs-code header=\"dynamic-form.component.html\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form.component.html\"/>\n    <docs-code header=\"dynamic-form.component.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/dynamic-form.component.ts\"/>\n</docs-code-multifile>\n\n### Display the form\n\nTo display an instance of the dynamic form, the `AppComponent` shell template passes the `questions` array returned by the `QuestionService` to the form container component, `<app-dynamic-form>`.\n\n<docs-code header=\"app.component.ts\" path=\"adev/src/content/examples/dynamic-form/src/app/app.component.ts\"/>\n\nThis separation of model and data lets you repurpose the components for any type of survey, as long as it's compatible with the _question_ object model.\n\n### Ensuring valid data\n\nThe form template uses dynamic data binding of metadata to render the form without making any hardcoded assumptions about specific questions.\nIt adds both control metadata and validation criteria dynamically.\n\nTo ensure valid input, the _Save_ button is disabled until the form is in a valid state.\nWhen the form is valid, click _Save_ and the application renders the current form values as JSON.\n\nThe following figure shows the final form.\n\n<img alt=\"Dynamic-Form\" src=\"assets/images/guide/dynamic-form/dynamic-form.png\">\n\n## Next steps\n\n<docs-pill-row>\n  <docs-pill title=\"Validating form input\" href=\"guide/forms/reactive-forms#validating-form-input\" />\n  <docs-pill title=\"Form validation guide\" href=\"guide/forms/form-validation\" />\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 8876
  },
  {
    "id": 38,
    "file": "form-validation",
    "fullFileName": "adev/src/content/guide/forms/form-validation.md",
    "startLine": 8880,
    "content": "# Validating form input\n\nYou can improve overall data quality by validating user input for accuracy and completeness.\nThis page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms.\n\n## Validating input in template-driven forms\n\nTo add validation to a template-driven form, you add the same validation attributes as you would with [native HTML form validation](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation).\nAngular uses directives to match these attributes with validator functions in the framework.\n\nEvery time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an `INVALID` status, or null, which results in a VALID status.\n\nYou can then inspect the control's state by exporting `ngModel` to a local template variable.\nThe following example exports `NgModel` into a variable called `name`:\n\n<docs-code header=\"template/actor-form-template.component.html (name)\" path=\"adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html\" visibleRegion=\"name-with-error-msg\"/>\n\nNotice the following features illustrated by the example.\n\n* The `<input>` element carries the HTML validation attributes: `required` and `minlength`.\n    It also carries a custom validator directive, `forbiddenName`.\n    For more information, see the [Custom validators](#defining-custom-validators) section.\n\n* `#name=\"ngModel\"` exports `NgModel` into a local variable called `name`.\n    `NgModel` mirrors many of the properties of its underlying `FormControl` instance, so you can use this in the template to check for control states such as `valid` and `dirty`.\n    For a full list of control properties, see the [AbstractControl](api/forms/AbstractControl) API reference.\n\n  * The `*ngIf` on the `<div>` element reveals a set of nested message `divs` but only if the `name` is invalid and the control is either `dirty` or `touched`.\n\n  * Each nested `<div>` can present a custom message for one of the possible validation errors.\n        There are messages for `required`, `minlength`, and `forbiddenName`.\n\nHELPFUL: To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the `dirty` or `touched` states in a control.\n\n* When the user changes the value in the watched field, the control is marked as \"dirty\"\n* When the user blurs the form control element, the control is marked as \"touched\"\n\n## Validating input in reactive forms\n\nIn a reactive form, the source of truth is the component class.\nInstead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class.\nAngular then calls these functions whenever the value of the control changes.\n\n### Validator functions\n\nValidator functions can be either synchronous or asynchronous.\n\n| Validator type   | Details |\n|:---              |:---     |\n| Sync validators  | Synchronous functions that take a control instance and immediately return either a set of validation errors or `null`. Pass these in as the second argument when you instantiate a `FormControl`.                       |\n| Async validators | Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or `null`. Pass these in as the third argument when you instantiate a `FormControl`. |\n\nFor performance reasons, Angular only runs async validators if all sync validators pass.\nEach must complete before errors are set.\n\n### Built-in validator functions\n\nYou can choose to [write your own validator functions](#defining-custom-validators), or you can use some of Angular's built-in validators.\n\nThe same built-in validators that are available as attributes in template-driven forms, such as `required` and `minlength`, are all available to use as functions from the `Validators` class.\nFor a full list of built-in validators, see the [Validators](api/forms/Validators) API reference.\n\nTo update the actor form to be a reactive form, use some of the same\nbuilt-in validators —this time, in function form, as in the following example.\n\n<docs-code header=\"reactive/actor-form-reactive.component.ts (validator functions)\" path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.1.ts\" visibleRegion=\"form-group\"/>\n\nIn this example, the `name` control sets up two built-in validators —`Validators.required` and `Validators.minLength(4)`— and one custom validator, `forbiddenNameValidator`.\n\nAll of these validators are synchronous, so they are passed as the second argument.\nNotice that you can support multiple validators by passing the functions in as an array.\n\nThis example also adds a few getter methods.\nIn a reactive form, you can always access any form control through the `get` method on its parent group, but sometimes it's useful to define getters as shorthand for the template.\n\nIf you look at the template for the `name` input again, it is fairly similar to the template-driven example.\n\n<docs-code header=\"reactive/actor-form-reactive.component.html (name with error msg)\" path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.html\" visibleRegion=\"name-with-error-msg\"/>\n\nThis form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the `name` getter defined in  the component class.\n\nNotice that the `required` attribute is still present in the template. Although it's not necessary for validation, it should be retained for accessibility purposes.\n\n## Defining custom validators\n\nThe built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator.\n\nConsider the `forbiddenNameValidator` function from the previous example.\nHere's what the definition of that function looks like.\n\n<docs-code header=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" path=\"adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts\" visibleRegion=\"custom-validator\"/>\n\nThe function is a factory that takes a regular expression to detect a *specific* forbidden name and returns a validator function.\n\nIn this sample, the forbidden name is \"bob\", so the validator rejects any actor name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.\n\nThe `forbiddenNameValidator` factory returns the configured validator function.\nThat function takes an Angular control object and returns *either* null if the control value is valid *or* a validation error object.\nThe validation error object typically has a property whose name is the validation key, `'forbiddenName'`, and whose value is an arbitrary dictionary of values that you could insert into an error message, `{name}`.\n\nCustom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object.\nIn the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation.\n\n### Adding custom validators to reactive forms\n\nIn reactive forms, add a custom validator by passing the function directly to the `FormControl`.\n\n<docs-code header=\"reactive/actor-form-reactive.component.ts (validator functions)\" path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.1.ts\" visibleRegion=\"custom-validator\"/>\n\n### Adding custom validators to template-driven forms\n\nIn template-driven forms, add a directive to the template, where the directive wraps the validator function.\nFor example, the corresponding `ForbiddenValidatorDirective` serves as a wrapper around the `forbiddenNameValidator`.\n\nAngular recognizes the directive's role in the validation process because the directive registers itself with the `NG_VALIDATORS` provider, as shown in the following example.\n`NG_VALIDATORS` is a predefined provider with an extensible collection of validators.\n\n<docs-code header=\"shared/forbidden-name.directive.ts (providers)\" path=\"adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts\" visibleRegion=\"directive-providers\"/>\n\nThe directive class then implements the `Validator` interface, so that it can easily integrate with Angular forms.\nHere is the rest of the directive to help you get an idea of how it all comes together.\n\n<docs-code header=\"shared/forbidden-name.directive.ts (directive)\" path=\"adev/src/content/examples/form-validation/src/app/shared/forbidden-name.directive.ts\" visibleRegion=\"directive\"/>\n\nOnce the `ForbiddenValidatorDirective` is ready, you can add its selector, `appForbiddenName`, to any input element to activate it.\nFor example:\n\n<docs-code header=\"template/actor-form-template.component.html (forbidden-name-input)\" path=\"adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html\" visibleRegion=\"name-input\"/>\n\nHELPFUL: Notice that the custom validation directive is instantiated with `useExisting` rather than `useClass`.\nThe registered validator must be *this instance* of the `ForbiddenValidatorDirective` —the instance in the form with its `forbiddenName` property bound to \"bob\".\n\nIf you were to replace `useExisting` with `useClass`, then you'd be registering a new class instance, one that doesn't have a `forbiddenName`.\n\n## Control status CSS classes\n\nAngular automatically mirrors many control properties onto the form control element as CSS classes.\nUse these classes to style form control elements according to the state of the form.\nThe following classes are currently supported.\n\n* `.ng-valid`\n* `.ng-invalid`\n* `.ng-pending`\n* `.ng-pristine`\n* `.ng-dirty`\n* `.ng-untouched`\n* `.ng-touched`\n* `.ng-submitted` \\(enclosing form element only\\)\n\nIn the following example, the actor form uses the `.ng-valid` and `.ng-invalid` classes to\nset the color of each form control's border.\n\n<docs-code header=\"forms.css (status classes)\" path=\"adev/src/content/examples/form-validation/src/assets/forms.css\"/>\n\n## Cross-field validation\n\nA cross-field validator is a [custom validator](#defining-custom-validators \"Read about custom validators\") that compares the values of different fields in a form and accepts or rejects them in combination.\nFor example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both.\nSome field values might also depend on others; a user might be allowed to choose B only if A is also chosen.\n\nThe following cross validation examples show how to do the following:\n\n* Validate reactive or template-based form input based on the values of two sibling controls,\n* Show a descriptive error message after the user interacted with the form and the validation failed.\n\nThe examples use cross-validation to ensure that actors do not reuse the same name in their role by filling out the Actor Form.\nThe validators do this by checking that the actor names and roles do not match.\n\n### Adding cross-validation to reactive forms\n\nThe form has the following structure:\n\n<docs-code language=\"javascript\">\n\nconst actorForm = new FormGroup({\n  'name': new FormControl(),\n  'role': new FormControl(),\n  'skill': new FormControl()\n});\n\n</docs-code>\n\nNotice that the `name` and `role` are sibling controls.\nTo evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the `FormGroup`.\nYou query the `FormGroup` for its child controls so that you can compare their values.\n\nTo add a validator to the `FormGroup`, pass the new validator in as the second argument on creation.\n\n<docs-code language=\"javascript\">\n\nconst actorForm = new FormGroup({\n  'name': new FormControl(),\n  'role': new FormControl(),\n  'skill': new FormControl()\n}, { validators: unambiguousRoleValidator });\n\n</docs-code>\n\nThe validator code is as follows.\n\n<docs-code header=\"shared/unambiguous-role.directive.ts\" path=\"adev/src/content/examples/form-validation/src/app/shared/unambiguous-role.directive.ts\" visibleRegion=\"cross-validation-validator\"/>\n\nThe `unambiguousRoleValidator` validator implements the `ValidatorFn` interface.\nIt takes an Angular control object as an argument and returns either null if the form is valid, or `ValidationErrors` otherwise.\n\nThe validator retrieves the child controls by calling the `FormGroup`'s [get](api/forms/AbstractControl#get) method, then compares the values of the `name` and `role` controls.\n\nIf the values do not match, the role is unambiguous, both are valid, and the validator returns null.\nIf they do match, the actor's role is ambiguous and the validator must mark the form as invalid by returning an error object.\n\nTo provide better user experience, the template shows an appropriate error message when the form is invalid.\n\n<docs-code header=\"reactive/actor-form-template.component.html\" path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.html\" visibleRegion=\"cross-validation-error-message\"/>\n\nThis `*ngIf` displays the error if the `FormGroup` has the cross validation error returned by the `unambiguousRoleValidator` validator, but only if the user finished [interacting with the form](#control-status-css-classes).\n\n### Adding cross-validation to template-driven forms\n\nFor a template-driven form, you must create a directive to wrap the validator function.\nYou provide that directive as the validator using the [`NG_VALIDATORS` token](/api/forms/NG_VALIDATORS), as shown in the following example.\n\n<docs-code header=\"shared/unambiguous-role.directive.ts\" path=\"adev/src/content/examples/form-validation/src/app/shared/unambiguous-role.directive.ts\" visibleRegion=\"cross-validation-directive\"/>\n\nYou must add the new directive to the HTML template.\nBecause the validator must be registered at the highest level in the form, the following template puts the directive on the `form` tag.\n\n<docs-code header=\"template/actor-form-template.component.html\" path=\"adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html\" visibleRegion=\"cross-validation-register-validator\"/>\n\nTo provide better user experience, an appropriate error message appears when the form is invalid.\n\n<docs-code header=\"template/actor-form-template.component.html\" path=\"adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html\" visibleRegion=\"cross-validation-error-message\"/>\n\nThis is the same in both template-driven and reactive forms.\n\n## Creating asynchronous validators\n\nAsynchronous validators implement the `AsyncValidatorFn` and `AsyncValidator` interfaces.\nThese are very similar to their synchronous counterparts, with the following differences.\n\n* The `validate()` functions must return a Promise or an observable,\n* The observable returned must be finite, meaning it must complete at some point.\n    To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as `first`, `last`, `take`, or `takeUntil`.\n\nAsynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful.\nThis check lets forms avoid potentially expensive async validation processes \\(such as an HTTP request\\) if the more basic validation methods have already found invalid input.\n\nAfter asynchronous validation begins, the form control enters a `pending` state.\nInspect the control's `pending` property and use it to give visual feedback about the ongoing validation operation.\n\nA common UI pattern is to show a spinner while the async validation is being performed.\nThe following example shows how to achieve this in a template-driven form.\n\n<docs-code language=\"html\">\n\n<input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator>\n<app-spinner *ngIf=\"model.pending\"></app-spinner>\n\n</docs-code>\n\n### Implementing a custom async validator\n\nIn the following example, an async validator ensures that actors are cast for a role that is not already taken.\nNew actors are constantly auditioning and old actors are retiring, so the list of available roles cannot be retrieved ahead of time.\nTo validate the potential role entry, the validator must initiate an asynchronous operation to consult a central database of all currently cast actors.\n\nThe following code creates the validator class, `UniqueRoleValidator`, which implements the `AsyncValidator` interface.\n\n<docs-code path=\"adev/src/content/examples/form-validation/src/app/shared/role.directive.ts\" visibleRegion=\"async-validator\"/>\n\nThe `actorsService` property is initialized with an instace of the `ActorsService` token, which defines the following interface.\n\n<docs-code language=\"typescript\">\ninterface ActorsService {\n  isRoleTaken: (role: string) => Observable<boolean>;\n}\n</docs-code>\n\nIn a real world application, the `ActorsService` would be responsible for making an HTTP request to the actor database to check if the role is available.\nFrom the validator's point of view, the actual implementation of the service is not important, so the example can just code against the `ActorsService` interface.\n\nAs the validation begins, the `UnambiguousRoleValidator` delegates to the `ActorsService` `isRoleTaken()` method with the current control value.\nAt this point the control is marked as `pending` and remains in this state until the observable chain returned from the `validate()` method completes.\n\nThe `isRoleTaken()` method dispatches an HTTP request that checks if the role is available, and returns `Observable<boolean>` as the result.\nThe `validate()` method pipes the response through the `map` operator and transforms it into a validation result.\n\nThe method then, like any validator, returns `null` if the form is valid, and `ValidationErrors` if it is not.\nThis validator handles any potential errors with the `catchError` operator.\nIn this case, the validator treats the `isRoleTaken()` error as a successful validation, because failure to make a validation request does not necessarily mean that the role is invalid.\nYou could handle the error differently and return the `ValidationError` object instead.\n\nAfter some time passes, the observable chain completes and the asynchronous validation is done.\nThe `pending` flag is set to `false`, and the form validity is updated.\n\n### Adding async validators to reactive forms\n\nTo use an async validator in reactive forms, begin by injecting the validator into a property of the component class.\n\n<docs-code path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.2.ts\" visibleRegion=\"async-validator-inject\"/>\n\nThen, pass the validator function directly to the `FormControl` to apply it.\n\nIn the following example, the `validate` function of `UnambiguousRoleValidator` is applied to `roleControl` by passing it to the control's `asyncValidators` option and binding it to the instance of `UnambiguousRoleValidator` that was injected into `ActorFormReactiveComponent`.\nThe value of `asyncValidators` can be either a single async validator function, or an array of functions.\nTo learn more about `FormControl` options, see the [AbstractControlOptions](api/forms/AbstractControlOptions) API reference.\n\n<docs-code path=\"adev/src/content/examples/form-validation/src/app/reactive/actor-form-reactive.component.2.ts\" visibleRegion=\"async-validator-usage\"/>\n\n### Adding async validators to template-driven forms\n\nTo use an async validator in template-driven forms, create a new directive and register the `NG_ASYNC_VALIDATORS` provider on it.\n\nIn the example below, the directive injects the `UniqueRoleValidator` class that contains the actual validation logic and invokes it in the `validate` function, triggered by Angular when validation should happen.\n\n<docs-code path=\"adev/src/content/examples/form-validation/src/app/shared/role.directive.ts\" visibleRegion=\"async-validator-directive\"/>\n\nThen, as with synchronous validators, add the directive's selector to an input to activate it.\n\n<docs-code header=\"template/actor-form-template.component.html (unique-unambiguous-role-input)\" path=\"adev/src/content/examples/form-validation/src/app/template/actor-form-template.component.html\" visibleRegion=\"role-input\"/>\n\n### Optimizing performance of async validators\n\nBy default, all validators run after every form value change.\nWith synchronous validators, this does not normally have a noticeable impact on application performance.\nAsync validators, however, commonly perform some kind of HTTP request to validate the control.\nDispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible.\n\nYou can delay updating the form validity by changing the `updateOn` property from `change` (default) to `submit` or `blur`.\n\nWith template-driven forms, set the property in the template.\n\n<docs-code language=\"html\">\n<input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">\n</docs-code>\n\nWith reactive forms, set the property in the `FormControl` instance.\n\n<docs-code language=\"typescript\">\nnew FormControl('', {updateOn: 'blur'});\n</docs-code>\n\n## Interaction with native HTML form validation\n\nBy default, Angular disables [native HTML form validation](https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation) by adding the `novalidate` attribute on the enclosing `<form>` and uses directives to match these attributes with validator functions in the framework.\nIf you want to use native validation **in combination** with Angular-based validation, you can re-enable it with the `ngNativeValidate` directive.\nSee the [API docs](api/forms/NgForm#native-dom-validation-ui) for details.\n\n\n\n================================================\n",
    "endLine": 9229
  },
  {
    "id": 39,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/forms/overview.md",
    "startLine": 9233,
    "content": "<docs-decorative-header title=\"Forms in Angular\" imgSrc=\"adev/src/assets/images/overview.svg\"> <!-- markdownlint-disable-line -->\nHandling user input with forms is the cornerstone of many common applications.\n</docs-decorative-header>\n\nApplications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks.\n\nAngular provides two different approaches to handling user input through forms: reactive and template-driven.\nBoth capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.\n\nThis guide provides information to help you decide which type of form works best for your situation.\nIt introduces the common building blocks used by both approaches.\nIt also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.\n\n## Choosing an approach\n\nReactive forms and template-driven forms process and manage form data differently.\nEach approach offers different advantages.\n\n| Forms                 | Details                                                                                                                                                                                                                                                                                                                                                                                                             |\n| :-------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Reactive forms        | Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.                                                                                            |\n| Template-driven forms | Rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit. |\n\n### Key differences\n\nThe following table summarizes the key differences between reactive and template-driven forms.\n\n|                                                   | Reactive                             | Template-driven                 |\n| :------------------------------------------------ | :----------------------------------- | :------------------------------ |\n| [Setup of form model](#setting-up-the-form-model) | Explicit, created in component class | Implicit, created by directives |\n| [Data model](#mutability-of-the-data-model)       | Structured and immutable             | Unstructured and mutable        |\n| [Data flow](#data-flow-in-forms)                  | Synchronous                          | Asynchronous                    |\n| [Form validation](#form-validation)               | Functions                            | Directives                      |\n\n### Scalability\n\nIf forms are a central part of your application, scalability is very important.\nBeing able to reuse form models across components is critical.\n\nReactive forms are more scalable than template-driven forms.\nThey provide direct access to the underlying form API, and use [synchronous data flow](#data-flow-in-reactive-forms) between the view and the data model, which makes creating large-scale forms easier.\nReactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.\n\nTemplate-driven forms focus on simple scenarios and are not as reusable.\nThey abstract away the underlying form API, and use [asynchronous data flow](#data-flow-in-template-driven-forms) between the view and the data model.\nThe abstraction of template-driven forms also affects testing.\nTests are deeply reliant on manual change detection execution to run properly, and require more setup.\n\n## Setting up the form model\n\nBoth reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model.\nThe two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.\n\n### Common form foundation classes\n\nBoth reactive and template-driven forms are built on the following base classes.\n\n| Base classes           | Details                                                                             |\n| :--------------------- | :---------------------------------------------------------------------------------- |\n| `FormControl`          | Tracks the value and validation status of an individual form control.               |\n| `FormGroup`            | Tracks the same values and status for a collection of form controls.                |\n| `FormArray`            | Tracks the same values and status for an array of form controls.                    |\n| `ControlValueAccessor` | Creates a bridge between Angular `FormControl` instances and built-in DOM elements. |\n\n### Setup in reactive forms\n\nWith reactive forms, you define the form model directly in the component class.\nThe `[formControl]` directive links the explicitly created `FormControl` instance to a specific form element in the view, using an internal value accessor.\n\nThe following component implements an input field for a single control, using reactive forms.\nIn this example, the form model is the `FormControl` instance.\n\n<docs-code path=\"adev/src/content/examples/forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts\"/>\n\nIMPORTANT: In reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the `[formControl]` directive on the `<input>` element.\n\n### Setup in template-driven forms\n\nIn template-driven forms, the form model is implicit, rather than explicit.\nThe directive `NgModel` creates and manages a `FormControl` instance for a given form element.\n\nThe following component implements the same input field for a single control, using template-driven forms.\n\n<docs-code path=\"adev/src/content/examples/forms-overview/src/app/template/favorite-color/favorite-color.component.ts\"/>\n\nIMPORTANT: In a template-driven form the source of truth is the template. The `NgModel` directive automatically manages the `FormControl` instance for you.\n\n## Data flow in forms\n\nWhen an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view.\nAs users change values and make selections through the view, the new values must be reflected in the data model.\nSimilarly, when the program logic changes values in the data model, those values must be reflected in the view.\n\nReactive and template-driven forms differ in how they handle data flowing from the user or from programmatic changes.\nThe following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above.\n\n### Data flow in reactive forms\n\nIn reactive forms each form element in the view is directly linked to the form model (a `FormControl` instance).\nUpdates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered.\n\nThe view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n1. The user types a value into the input element, in this case the favorite color _Blue_.\n1. The form input element emits an \"input\" event with the latest value.\n1. The `ControlValueAccessor` listening for events on the form input element immediately relays the new value to the `FormControl` instance.\n1. The `FormControl` instance emits the new value through the `valueChanges` observable.\n1. Any subscribers to the `valueChanges` observable receive the new value.\n\n```mermaid\nflowchart TB\n    U{User}\n    I(\"&lt;input&gt;\")\n    CVA(ControlValueAccessor)\n    FC(FormControl)\n    O(Observers)\n    U-->|Types in the input box|I\n    I-->|Fires the 'input' event|CVA\n    CVA-->|\"Calls setValue() on the FormControl\"|FC\n    FC-.->|Fires a 'valueChanges' event to observers|O\n```\n\nThe model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps.\n\n1. The user calls the `favoriteColorControl.setValue()` method, which updates the `FormControl` value.\n1. The `FormControl` instance emits the new value through the `valueChanges` observable.\n1. Any subscribers to the `valueChanges` observable receive the new value.\n1. The control value accessor on the form input element updates the element with the new value.\n\n```mermaid\nflowchart TB\n    U{User}\n    I(\"&lt;input&gt;\")\n    CVA(ControlValueAccessor)\n    FC(FormControl)\n    O(Observers)\n    U-->|\"Calls setValue() on the FormControl\"|FC\n    FC-->|Notifies the ControlValueAccessor|CVA\n    FC-.->|Fires a 'valueChanges' event to observers|O\n    CVA-->|\"Updates the value of the &lt;input&gt;\"|I\n```\n\n### Data flow in template-driven forms\n\nIn template-driven forms, each form element is linked to a directive that manages the form model internally.\n\nThe view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.\n\n1. The user types _Blue_ into the input element.\n1. The input element emits an \"input\" event with the value _Blue_.\n1. The control value accessor attached to the input triggers the `setValue()` method on the `FormControl` instance.\n1. The `FormControl` instance emits the new value through the `valueChanges` observable.\n1. Any subscribers to the `valueChanges` observable receive the new value.\n1. The control value accessor also calls the `NgModel.viewToModelUpdate()` method which emits an `ngModelChange` event.\n1. Because the component template uses two-way data binding for the `favoriteColor` property, the `favoriteColor` property in the component is updated to the value emitted by the `ngModelChange` event \\(_Blue_\\).\n\n```mermaid\nflowchart TB\n    U{User}\n    I(\"&lt;input&gt;\")\n    CVA(ControlValueAccessor)\n    FC(FormControl)\n    M(NgModel)\n    O(Observers)\n    C(Component)\n    P(Two-way binding)\n    U-->|Types in the input box|I\n    I-->|Fires the 'input' event|CVA\n    CVA-->|\"Calls setValue() on the FormControl\"|FC\n    FC-.->|Fires a 'valueChanges' event to observers|O\n    CVA-->|\"Calls viewToModelUpdate()\"|M\n    M-->|Emits an ngModelChange event|C\n    C-->|Updates the value of the two-way bound property|P\n```\n\nThe model-to-view diagram shows how data flows from model to view when the `favoriteColor` changes from _Blue_ to _Red_, through the following steps\n\n1. The `favoriteColor` value is updated in the component.\n1. Change detection begins.\n1. During change detection, the `ngOnChanges` lifecycle hook is called on the `NgModel` directive instance because the value of one of its inputs has changed.\n1. The `ngOnChanges()` method queues an async task to set the value for the internal `FormControl` instance.\n1. Change detection completes.\n1. On the next tick, the task to set the `FormControl` instance value is executed.\n1. The `FormControl` instance emits the latest value through the `valueChanges` observable.\n1. Any subscribers to the `valueChanges` observable receive the new value.\n1. The control value accessor updates the form input element in the view with the latest `favoriteColor` value.\n\n```mermaid\nflowchart TB\n    C(Component)\n    P(Property bound to NgModel)\n    C-->|Updates the property value|P\n    P-->|Triggers CD|CD1\n\n\n    subgraph CD1 [First Change Detection]\n        direction TB\n        M(NgModel)\n        FC(FormControl)\n\n        M-->|Asynchronously sets FormControl value|FC\n    end\n    CD1-->|Async actions trigger a second round of Change Detection|CD2\n\n    subgraph CD2 [Second Change Detection]\n        direction TB\n        FC2(FormControl)\n        O(Observers)\n        CVA(ControlValueAccessor)\n        I(\"&lt;input&gt;\")\n        FC2-.->|Fires a 'valueChanges' event to observers|O\n        O-->|ControlValueAccessor receives valueChanges event|CVA\n        CVA-->|Sets the value in the control|I\n    end\n```\n\nNOTE: `NgModel` triggers a second change detection to avoid `ExpressionChangedAfterItHasBeenChecked` errors, because the value change originates in an input binding.\n\n### Mutability of the data model\n\nThe change-tracking method plays a role in the efficiency of your application.\n\n| Forms                 | Details                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Reactive forms        | Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the `FormControl` instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. |\n| Template-driven forms | Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required.                                                                                                                                                                                                                                 |\n\nThe difference is demonstrated in the previous examples that use the favorite-color input element.\n\n- With reactive forms, the **`FormControl` instance** always returns a new value when the control's value is updated\n- With template-driven forms, the **favorite color property** is always modified to its new value\n\n## Form validation\n\nValidation is an integral part of managing any set of forms.\nWhether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.\n\n| Forms                 | Details                                                                                                      |\n| :-------------------- | :----------------------------------------------------------------------------------------------------------- |\n| Reactive forms        | Define custom validators as **functions** that receive a control to validate                                 |\n| Template-driven forms | Tied to template **directives**, and must provide custom validator directives that wrap validation functions |\n\nFor more information, see [Form Validation](guide/forms/form-validation#validating-input-in-reactive-forms).\n\n## Testing\n\nTesting plays a large part in complex applications.\nA simpler testing strategy is useful when validating that your forms function correctly.\nReactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes.\nThe following examples demonstrate the process of testing forms with reactive and template-driven forms.\n\n### Testing reactive forms\n\nReactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI.\nIn these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.\n\nThe following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form.\n\n<!--todo: make consistent with other topics -->\n\n#### Verifying view-to-model data flow\n\nThe first example performs the following steps to verify the view-to-model data flow.\n\n1. Query the view for the form input element, and create a custom \"input\" event for the test.\n1. Set the new value for the input to _Red_, and dispatch the \"input\" event on the form input element.\n1. Assert that the component's `favoriteColorControl` value matches the value from the input.\n\n<docs-code header=\"Favorite color test - view to model\" path=\"adev/src/content/examples/forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" visibleRegion=\"view-to-model\"/>\n\nThe next example performs the following steps to verify the model-to-view data flow.\n\n1. Use the `favoriteColorControl`, a `FormControl` instance, to set the new value.\n1. Query the view for the form input element.\n1. Assert that the new value set on the control matches the value in the input.\n\n<docs-code header=\"Favorite color test - model to view\" path=\"adev/src/content/examples/forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" visibleRegion=\"model-to-view\"/>\n\n### Testing template-driven forms\n\nWriting tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.\n\nThe following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.\n\nThe following test verifies the data flow from view to model.\n\n<docs-code header=\"Favorite color test - view to model\" path=\"adev/src/content/examples/forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" visibleRegion=\"view-to-model\"/>\n\nHere are the steps performed in the view to model test.\n\n1. Query the view for the form input element, and create a custom \"input\" event for the test.\n1. Set the new value for the input to _Red_, and dispatch the \"input\" event on the form input element.\n1. Run change detection through the test fixture.\n1. Assert that the component `favoriteColor` property value matches the value from the input.\n\nThe following test verifies the data flow from model to view.\n\n<docs-code header=\"Favorite color test - model to view\" path=\"adev/src/content/examples/forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" visibleRegion=\"model-to-view\"/>\n\nHere are the steps performed in the model to view test.\n\n1. Use the component instance to set the value of the `favoriteColor` property.\n1. Run change detection through the test fixture.\n1. Use the `tick()` method to simulate the passage of time within the `fakeAsync()` task.\n1. Query the view for the form input element.\n1. Assert that the input value matches the value of the `favoriteColor` property in the component instance.\n\n## Next steps\n\nTo learn more about reactive forms, see the following guides:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/forms/reactive-forms\" title=\"Reactive forms\"/>\n  <docs-pill href=\"guide/forms/form-validation#validating-input-in-reactive-forms\" title=\"Form validation\"/>\n  <docs-pill href=\"guide/forms/dynamic-forms\" title=\"Dynamic forms\"/>\n</docs-pill-row>\n\nTo learn more about template-driven forms, see the following guides:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/forms/template-driven-forms\" title=\"Template Driven Forms tutorial\" />\n  <docs-pill href=\"guide/forms/form-validation#validating-input-in-template-driven-forms\" title=\"Form validation\" />\n  <docs-pill href=\"api/forms/NgForm\" title=\"NgForm directive API reference\" />\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 9559
  },
  {
    "id": 40,
    "file": "reactive-forms",
    "fullFileName": "adev/src/content/guide/forms/reactive-forms.md",
    "startLine": 9563,
    "content": "# Reactive forms\n\nReactive forms provide a model-driven approach to handling form inputs whose values change over time.\nThis guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time.\n\n## Overview of reactive forms\n\nReactive forms use an explicit and immutable approach to managing the state of a form at a given point in time.\nEach change to the form state returns a new state, which maintains the integrity of the model between changes.\nReactive forms are built around observable streams, where form inputs and values are provided as streams of input values, which can be accessed synchronously.\n\nReactive forms also provide a straightforward path to testing because you are assured that your data is consistent and predictable when requested.\nAny consumers of the streams have access to manipulate that data safely.\n\nReactive forms differ from [template-driven forms](guide/forms/template-driven-forms) in distinct ways.\nReactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams.\n\nTemplate-driven forms let direct access modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously.\nSee the [Forms Overview](guide/forms) for detailed comparisons between the two paradigms.\n\n## Adding a basic form control\n\nThere are three steps to using form controls.\n\n1. Generate a new component and register the reactive forms module. This module declares the reactive-form directives that you need to use reactive forms.\n1. Instantiate a new `FormControl`.\n1. Register the `FormControl` in the template.\n\nYou can then display the form by adding the component to the template.\n\nThe following examples show how to add a single form control.\nIn the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element.\n\n<docs-workflow>\n\n<docs-step title=\"Generate a new component and import the ReactiveFormsModule\">\nUse the CLI command `ng generate component` to generate a component in your project and import `ReactiveFormsModule` from the `@angular/forms` package and add it to your Component's `imports` array.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.ts (excerpt)\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts\" visibleRegion=\"imports\" />\n</docs-step>\n\n<docs-step title=\"Declare a FormControl instance\">\nUse the constructor of `FormControl` to set its initial value, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.ts\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts\" visibleRegion=\"create-control\"/>\n</docs-step>\n\n<docs-step title=\"Register the control in the template\">\nAfter you create the control in the component class, you must associate it with a form control element in the template. Update the template with the form control using the `formControl` binding provided by `FormControlDirective`, which is also included in the `ReactiveFormsModule`.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.html\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html\" visibleRegion=\"control-binding\" />\n\nUsing the template binding syntax, the form control is now registered to the `name` input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view.\n</docs-step>\n\n<docs-step title=\"Display the component\">\nThe `FormControl` assigned to the `name` property is displayed when the `<app-name-editor>` component is added to a template.\n\n<docs-code header=\"src/app/app.component.html (name editor)\" path=\"adev/src/content/examples/reactive-forms/src/app/app.component.1.html\" visibleRegion=\"app-name-editor\"/>\n</docs-step>\n</docs-workflow>\n\n### Displaying a form control value\n\nYou can display the value in the following ways.\n\n- Through the `valueChanges` observable where you can listen for changes in the form's value in the template using `AsyncPipe` or in the component class using the `subscribe()` method\n- With the `value` property, which gives you a snapshot of the current value\n\nThe following example shows you how to display the current value using interpolation in the template.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.html (control value)\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html\" visibleRegion=\"display-value\"/>\n\nThe displayed value changes as you update the form control element.\n\nReactive forms provide access to information about a given control through properties and methods provided with each instance.\nThese properties and methods of the underlying [AbstractControl](api/forms/AbstractControl 'API reference') class are used to control form state and determine when to display messages when handling [input validation](#validating-form-input 'Learn more about validating form input').\n\nRead about other `FormControl` properties and methods in the [API Reference](api/forms/FormControl 'Detailed syntax reference').\n\n### Replacing a form control value\n\nReactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction.\nA form control instance provides a `setValue()` method that updates the value of the form control and validates the structure of the value provided against the control's structure.\nFor example, when retrieving form data from a backend API or service, use the `setValue()` method to update the control to its new value, replacing the old value entirely.\n\nThe following example adds a method to the component class to update the value of the control to _Nancy_ using the `setValue()` method.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.ts (update value)\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.ts\" visibleRegion=\"update-value\"/>\n\nUpdate the template with a button to simulate a name update.\nWhen you click the **Update Name** button, the value entered in the form control element is reflected as its current value.\n\n<docs-code header=\"src/app/name-editor/name-editor.component.html (update value)\" path=\"adev/src/content/examples/reactive-forms/src/app/name-editor/name-editor.component.html\" visibleRegion=\"update-value\"/>\n\nThe form model is the source of truth for the control, so when you click the button, the value of the input is changed within the component class, overriding its current value.\n\nHELPFUL: In this example, you're using a single control.\nWhen using the `setValue()` method with a [form group](#grouping-form-controls) or [form array](#creating-dynamic-forms) instance, the value needs to match the structure of the group or array.\n\n## Grouping form controls\n\nForms typically contain several related controls.\nReactive forms provide two ways of grouping multiple related controls into a single input form.\n\n| Form groups | Details                                                                                                                                                                                                                                                |\n| :---------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Form group  | Defines a form with a fixed set of controls that you can manage together. Form group basics are discussed in this section. You can also [nest form groups](#creating-nested-form-groups 'See more about nesting groups') to create more complex forms. |\n| Form array  | Defines a dynamic form, where you can add and remove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see [Creating dynamic forms](#creating-dynamic-forms).                              |\n\nJust as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances \\(for example, a form\\).\nEach control in a form group instance is tracked by name when creating the form group.\nThe following example shows how to manage multiple form control instances in a single group.\n\nGenerate a `ProfileEditor` component and import the `FormGroup` and `FormControl` classes from the `@angular/forms` package.\n\n<docs-code language=\"shell\">\nng generate component ProfileEditor\n</docs-code>\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (imports)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" visibleRegion=\"imports\"/>\n\nTo add a form group to this component, take the following steps.\n\n1. Create a `FormGroup` instance.\n1. Associate the `FormGroup` model and view.\n1. Save the form data.\n\n<docs-workflow>\n\n<docs-step title=\"Create a FormGroup instance\">\nCreate a property in the component class named `profileForm` and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control.\n\nFor the profile form, add two form control instances with the names `firstName` and `lastName`\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (form group)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" visibleRegion=\"formgroup\"/>\n\nThe individual form controls are now collected within a group. A `FormGroup` instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as `value` and `untouched`) and methods (such as `setValue()`) as a form control instance.\n</docs-step>\n\n<docs-step title=\"Associate the FormGroup model and view\">\nA form group tracks the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (template form group)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html\" visibleRegion=\"formgroup\"/>\n\nJust as a form group contains a group of controls, the _profileForm_ `FormGroup` is bound to the `form` element with the `FormGroup` directive, creating a communication layer between the model and the form containing the inputs. The `formControlName` input provided by the `FormControlName` directive binds each individual input to the form control defined in `FormGroup`. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value.\n</docs-step>\n\n<docs-step title=\"Save form data\">\nThe `ProfileEditor` component accepts input from the user, but in a real scenario you want to capture the form value and make it available for further processing outside the component. The `FormGroup` directive listens for the `submit` event emitted by the `form` element and emits an `ngSubmit` event that you can bind to a callback function. Add an `ngSubmit` event listener to the `form` tag with the `onSubmit()` callback method.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (submit event)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html\" visibleRegion=\"ng-submit\"/>\n\nThe `onSubmit()` method in the `ProfileEditor` component captures the current value of `profileForm`. Use `EventEmitter` to keep the form encapsulated and to provide the form value outside the component. The following example uses `console.warn` to log a message to the browser console.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (submit method)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"on-submit\"/>\n\nThe `submit` event is emitted by the `form` tag using the built-in DOM event. You trigger the event by clicking a button with `submit` type. This lets the user press the **Enter** key to submit the completed form.\n\nUse a `button` element to add a button to the bottom of the form to trigger the form submission.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (submit button)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html\" visibleRegion=\"submit-button\"/>\n\nThe button in the preceding snippet also has a `disabled` binding attached to it to disable the button when `profileForm` is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the [Validating form input](#validating-form-input) section.\n</docs-step>\n\n<docs-step title=\"Display the component\">\nTo display the `ProfileEditor` component that contains the form, add it to a component template.\n\n<docs-code header=\"src/app/app.component.html (profile editor)\" path=\"adev/src/content/examples/reactive-forms/src/app/app.component.1.html\" visibleRegion=\"app-profile-editor\"/>\n\n`ProfileEditor` lets you manage the form control instances for the `firstName` and `lastName` controls within the form group instance.\n\n### Creating nested form groups\n\nForm groups can accept both individual form control instances and other form group instances as children.\nThis makes composing complex form models easier to maintain and logically group together.\n\nWhen building complex forms, managing the different areas of information is easier in smaller sections.\nUsing a nested form group instance lets you break large forms groups into smaller, more manageable ones.\n\nTo make more complex forms, use the following steps.\n\n1. Create a nested group.\n1. Group the nested form in the template.\n\nSome types of information naturally fall into the same group.\nA name and address are typical examples of such nested groups, and are used in the following examples.\n\n<docs-workflow>\n<docs-step title=\"Create a nested group\">\nTo create a nested group in `profileForm`, add a nested `address` element to the form group instance.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (nested form group)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" visibleRegion=\"nested-formgroup\"/>\n\nIn this example, `address group` combines the current `firstName` and `lastName` controls with the new `street`, `city`, `state`, and `zip` controls. Even though the `address` element in the form group is a child of the overall `profileForm` element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model.\n</docs-step>\n\n<docs-step title=\"Group the nested form in the template\">\nAfter you update the model in the component class, update the template to connect the form group instance and its input elements. Add the `address` form group containing the `street`, `city`, `state`, and `zip` fields to the `ProfileEditor` template.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (template nested form group)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html\" visibleRegion=\"formgroupname\"/>\n\nThe `ProfileEditor` form is displayed as one group, but the model is broken down further to represent the logical grouping areas.\n\nDisplay the value for the form group instance in the component template using the `value` property and `JsonPipe`.\n</docs-step>\n</docs-workflow>\n\n### Updating parts of the data model\n\nWhen updating the value for a form group instance that contains multiple controls, you might only want to update parts of the model.\nThis section covers how to update specific parts of a form control data model.\n\nThere are two ways to update the model value:\n\n| Methods        | Details                                                                                                                                                               |\n| :------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `setValue()`   | Set a new value for an individual control. The `setValue()` method strictly adheres to the structure of the form group and replaces the entire value for the control. |\n| `patchValue()` | Replace any properties defined in the object that have changed in the form model.                                                                                     |\n\nThe strict checks of the `setValue()` method help catch nesting errors in complex forms, while `patchValue()` fails silently on those errors.\n\nIn `ProfileEditorComponent`, use the `updateProfile` method with the following example to update the first name and street address for the user.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (patch value)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" visibleRegion=\"patch-value\"/>\n\nSimulate an update by adding a button to the template to update the user profile on demand.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (update value)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.html\" visibleRegion=\"patch-value\"/>\n\nWhen a user clicks the button, the `profileForm` model is updated with new values for `firstName` and `street`. Notice that `street` is provided in an object inside the `address` property.\nThis is necessary because the `patchValue()` method applies the update against the model structure.\n`PatchValue()` only updates properties that the form model defines.\n\n## Using the FormBuilder service to generate controls\n\nCreating form control instances manually can become repetitive when dealing with multiple forms.\nThe `FormBuilder` service provides convenient methods for generating controls.\n\nUse the following steps to take advantage of this service.\n\n1. Import the `FormBuilder` class.\n1. Inject the `FormBuilder` service.\n1. Generate the form contents.\n\nThe following examples show how to refactor the `ProfileEditor` component to use the form builder service to create form control and form group instances.\n\n<docs-workflow>\n<docs-step title=\"Import the FormBuilder class\">\nImport the `FormBuilder` class from the `@angular/forms` package.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (import)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts\" visibleRegion=\"form-builder-imports\"/>\n\n</docs-step>\n\n<docs-step title=\"Inject the FormBuilder service\">\nThe `FormBuilder` service is an injectable provider from the reactive forms module. Use the `inject()` function to inject this dependency in your component.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (property init)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts\" visibleRegion=\"inject-form-builder\"/>\n\n</docs-step>\n<docs-step title=\"Generate form controls\">\nThe `FormBuilder` service has three methods: `control()`, `group()`, and `array()`. These are factory methods for generating instances in your component classes including form controls, form groups, and form arrays. Use the `group` method to create the `profileForm` controls.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (form builder)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts\" visibleRegion=\"form-builder\"/>\n\nIn the preceding example, you use the `group()` method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.\n\nTIP: You can define the control with just the initial value, but if your controls need sync or async validation, add sync and async validators as the second and third items in the array. Compare using the form builder to creating the instances manually.\n\n  <docs-code-multifile>\n    <docs-code header=\"src/app/profile-editor/profile-editor.component.ts (instances)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" visibleRegion=\"formgroup-compare\"/>\n    <docs-code header=\"src/app/profile-editor/profile-editor.component.ts (form builder)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts\" visibleRegion=\"formgroup-compare\"/>\n  </docs-code-multifile>\n</docs-step>\n\n</docs-workflow>\n\n## Validating form input\n\n_Form validation_ is used to ensure that user input is complete and correct.\nThis section covers adding a single validator to a form control and displaying the overall form status.\nForm validation is covered more extensively in the [Form Validation](guide/forms/form-validation) guide.\n\nUse the following steps to add form validation.\n\n1. Import a validator function in your form component.\n1. Add the validator to the field in the form.\n1. Add logic to handle the validation status.\n\nThe most common validation is making a field required.\nThe following example shows how to add a required validation to the `firstName` control and display the result of validation.\n\n<docs-workflow>\n<docs-step title=\"Import a validator function\">\nReactive forms include a set of validator functions for common use cases. These functions receive a control to validate against and return an error object or a null value based on the validation check.\n\nImport the `Validators` class from the `@angular/forms` package.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (import)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"validator-imports\"/>\n</docs-step>\n\n<docs-step title=\"Make a field required\">\nIn the `ProfileEditor` component, add the `Validators.required` static method as the second item in the array for the `firstName` control.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (required validator)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"required-validator\"/>\n</docs-step>\n\n<docs-step title=\"Display form status\">\nWhen you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its `status` property.\n\nDisplay the current status of `profileForm` using interpolation.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (display status)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html\" visibleRegion=\"display-status\"/>\n\nThe **Submit** button is disabled because `profileForm` is invalid due to the required `firstName` form control. After you fill out the `firstName` input, the form becomes valid and the **Submit** button is enabled.\n\nFor more on form validation, visit the [Form Validation](guide/forms/form-validation) guide.\n</docs-step>\n</docs-workflow>\n\n## Creating dynamic forms\n\n`FormArray` is an alternative to `FormGroup` for managing any number of unnamed controls.\nAs with form group instances, you can dynamically insert and remove controls from form array instances, and the form array instance value and validation status is calculated from its child controls.\nHowever, you don't need to define a key for each control by name, so this is a great option if you don't know the number of child values in advance.\n\nTo define a dynamic form, take the following steps.\n\n1. Import the `FormArray` class.\n1. Define a `FormArray` control.\n1. Access the `FormArray` control with a getter method.\n1. Display the form array in a template.\n\nThe following example shows you how to manage an array of _aliases_ in `ProfileEditor`.\n\n<docs-workflow>\n<docs-step title=\"Import the `FormArray` class\">\nImport the `FormArray` class from `@angular/forms` to use for type information. The `FormBuilder` service is ready to create a `FormArray` instance.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (import)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.2.ts\" visibleRegion=\"form-array-imports\"/>\n</docs-step>\n\n<docs-step title=\"Define a `FormArray` control\">\nYou can initialize a form array with any number of controls, from zero to many, by defining them in an array. Add an `aliases` property to the form group instance for `profileForm` to define the form array.\n\nUse the `FormBuilder.array()` method to define the array, and the `FormBuilder.control()` method to populate the array with an initial control.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (aliases form array)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"aliases\"/>\n\nThe aliases control in the form group instance is now populated with a single control until more controls are added dynamically.\n</docs-step>\n\n<docs-step title=\"Access the `FormArray` control\">\nA getter provides access to the aliases in the form array instance compared to repeating the `profileForm.get()` method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is straightforward to repeat for additional controls. <br />\n\nUse the getter syntax to create an `aliases` class property to retrieve the alias's form array control from the parent form group.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (aliases getter)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"aliases-getter\"/>\n\nBecause the returned control is of the type `AbstractControl`, you need to provide an explicit type to access the method syntax for the form array instance. Define a method to dynamically insert an alias control into the alias's form array. The `FormArray.push()` method inserts the control as a new item in the array.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.ts (add alias)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.ts\" visibleRegion=\"add-alias\"/>\n\nIn the template, each control is displayed as a separate input field.\n\n</docs-step>\n\n<docs-step title=\"Display the form array in the template\">\n\nTo attach the aliases from your form model, you must add it to the template. Similar to the `formGroupName` input provided by `FormGroupNameDirective`, `formArrayName` binds communication from the form array instance to the template with `FormArrayNameDirective`.\n\nAdd the following template HTML after the `<div>` closing the `formGroupName` element.\n\n<docs-code header=\"src/app/profile-editor/profile-editor.component.html (aliases form array template)\" path=\"adev/src/content/examples/reactive-forms/src/app/profile-editor/profile-editor.component.html\" visibleRegion=\"formarrayname\"/>\n\nThe `*ngFor` directive iterates over each form control instance provided by the aliases form array instance. Because form array elements are unnamed, you assign the index to the `i` variable and pass it to each control to bind it to the `formControlName` input.\n\nEach time a new alias instance is added, the new form array instance is provided its control based on the index. This lets you track each individual control when calculating the status and value of the root control.\n\n</docs-step>\n\n<docs-step title=\"Add an alias\">\n\nInitially, the form contains one `Alias` field. To add another field, click the **Add Alias** button. You can also validate the array of aliases reported by the form model displayed by `Form Value` at the bottom of the template. Instead of a form control instance for each alias, you can compose another form group instance with additional fields. The process of defining a control for each item is the same.\n</docs-step>\n\n</docs-workflow>\n\n## Reactive forms API summary\n\nThe following table lists the base classes and services used to create and manage reactive form controls.\nFor complete syntax details, see the API reference documentation for the [Forms package](api#forms 'API reference').\n\n### Classes\n\n| Class             | Details                                                                                                                                                                                 |\n| :---------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `AbstractControl` | The abstract base class for the concrete form control classes `FormControl`, `FormGroup`, and `FormArray`. It provides their common behaviors and properties.                           |\n| `FormControl`     | Manages the value and validity status of an individual form control. It corresponds to an HTML form control such as `<input>` or `<select>`.                                            |\n| `FormGroup`       | Manages the value and validity state of a group of `AbstractControl` instances. The group's properties include its child controls. The top-level form in your component is `FormGroup`. |\n| `FormArray`       | Manages the value and validity state of a numerically indexed array of `AbstractControl` instances.                                                                                     |\n| `FormBuilder`     | An injectable service that provides factory methods for creating control instances.                                                                                                     |\n| `FormRecord`      | Tracks the value and validity state of a collection of `FormControl` instances, each of which has the same value type.                                                                  |\n\n### Directives\n\n| Directive              | Details                                                                                    |\n| :--------------------- | :----------------------------------------------------------------------------------------- |\n| `FormControlDirective` | Syncs a standalone `FormControl` instance to a form control element.                       |\n| `FormControlName`      | Syncs `FormControl` in an existing `FormGroup` instance to a form control element by name. |\n| `FormGroupDirective`   | Syncs an existing `FormGroup` instance to a DOM element.                                   |\n| `FormGroupName`        | Syncs a nested `FormGroup` instance to a DOM element.                                      |\n| `FormArrayName`        | Syncs a nested `FormArray` instance to a DOM element.                                      |\n\n\n\n================================================\n",
    "endLine": 9980
  },
  {
    "id": 41,
    "file": "template-driven-forms",
    "fullFileName": "adev/src/content/guide/forms/template-driven-forms.md",
    "startLine": 9984,
    "content": "# Building a template-driven form\n\nThis tutorial shows you how to create a template-driven form. The control elements in the form are bound to data properties that have input validation. The input validation helps maintain data integrity and styling to improve the user experience.\n\nTemplate-driven forms use [two-way data binding](guide/templates/two-way-binding) to update the data model in the component as changes are made in the template and vice versa.\n\n<docs-callout helpful title=\"Template vs Reactive forms\">\nAngular supports two design approaches for interactive forms. Template-driven forms allow you to use form-specific directives in your Angular template. Reactive forms provide a model-driven approach to building forms.\n\nTemplate-driven forms are a great choice for small or simple forms, while reactive forms are more scalable and suitable for complex forms. For a comparison of the two approaches, see [Choosing an approach](guide/forms#choosing-an-approach)\n</docs-callout>\n\nYou can build almost any kind of form with an Angular template —login forms, contact forms, and pretty much any business form.\nYou can lay out the controls creatively and bind them to the data in your object model.\nYou can specify validation rules and display validation errors, conditionally allow input from specific controls, trigger built-in visual feedback, and much more.\n\n## Objectives\n\nThis tutorial teaches you how to do the following:\n\n- Build an Angular form with a component and template\n- Use `ngModel` to create two-way data bindings for reading and writing input-control values\n- Provide visual feedback using special CSS classes that track the state of the controls\n- Display validation errors to users and conditionally allow input from form controls based on the form status\n- Share information across HTML elements using [template reference variables](guide/templates/variables#template-reference-variables)\n\n## Build a template-driven form\n\nTemplate-driven forms rely on directives defined in the `FormsModule`.\n\n| Directives     | Details                                                                                                                                                                                                                                                                         |\n| :------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `NgModel`      | Reconciles value changes in the attached form element with changes in the data model, allowing you to respond to user input with input validation and error handling.                                                                                                           |\n| `NgForm`       | Creates a top-level `FormGroup` instance and binds it to a `<form>` element to track aggregated form value and validation status. As soon as you import `FormsModule`, this directive becomes active by default on all `<form>` tags. You don't need to add a special selector. |\n| `NgModelGroup` | Creates and binds a `FormGroup` instance to a DOM element.                                                                                                                                                                                                                      |\n\n### Step overview\n\nIn the course of this tutorial, you bind a sample form to data and handle user input using the following steps.\n\n1. Build the basic form.\n   - Define a sample data model\n   - Include required infrastructure such as the `FormsModule`\n1. Bind form controls to data properties using the `ngModel` directive and two-way data-binding syntax.\n   - Examine how `ngModel` reports control states using CSS classes\n   - Name controls to make them accessible to `ngModel`\n1. Track input validity and control status using `ngModel`.\n   - Add custom CSS to provide visual feedback on the status\n   - Show and hide validation-error messages\n1. Respond to a native HTML button-click event by adding to the model data.\n1. Handle form submission using the [`ngSubmit`](api/forms/NgForm#properties) output property of the form.\n   - Disable the **Submit** button until the form is valid\n   - After submit, swap out the finished form for different content on the page\n\n## Build the form\n\n<!-- TODO: link to preview -->\n<!-- <docs-code live/> -->\n\n1. The provided sample application creates the `Actor` class which defines the data model reflected in the form.\n\n<docs-code header=\"src/app/actor.ts\" language=\"typescript\" path=\"adev/src/content/examples/forms/src/app/actor.ts\"/>\n\n1. The form layout and details are defined in the `ActorFormComponent` class.\n\n   <docs-code header=\"src/app/actor-form/actor-form.component.ts (v1)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" visibleRegion=\"v1\"/>\n\n   The component's `selector` value of \"app-actor-form\" means you can drop this form in a parent template using the `<app-actor-form>` tag.\n\n1. The following code creates a new actor instance, so that the initial form can show an example actor.\n\n   <docs-code language=\"typescript\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" language=\"typescript\" visibleRegion=\"Marilyn\"/>\n\n   This demo uses dummy data for `model` and `skills`.\n   In a real app, you would inject a data service to get and save real data, or expose these properties as inputs and outputs.\n\n1. The component enables the Forms feature by importing the `FormsModule` module.\n\n   <docs-code language=\"typescript\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" language=\"typescript\" visibleRegion=\"imports\"/>\n\n1. The form is displayed in the application layout defined by the root component's template.\n\n   <docs-code header=\"src/app/app.component.html\" language=\"html\" path=\"adev/src/content/examples/forms/src/app/app.component.html\"/>\n\n   The initial template defines the layout for a form with two form groups and a submit button.\n   The form groups correspond to two properties of the Actor data model, name and studio.\n   Each group has a label and a box for user input.\n\n   - The **Name** `<input>` control element has the HTML5 `required` attribute\n   - The **Studio** `<input>` control element does not because `studio` is optional\n\n   The **Submit** button has some classes on it for styling.\n   At this point, the form layout is all plain HTML5, with no bindings or directives.\n\n1. The sample form uses some style classes from [Twitter Bootstrap](https://getbootstrap.com/css): `container`, `form-group`, `form-control`, and `btn`.\n   To use these styles, the application's style sheet imports the library.\n\n<docs-code header=\"src/styles.css\" path=\"adev/src/content/examples/forms/src/styles.1.css\"/>\n\n1. The form requires that an actor's skill is chosen from a predefined list of `skills` maintained internally in `ActorFormComponent`.\n   The Angular [NgForOf directive](api/common/NgForOf 'API reference') iterates over the data values to populate the `<select>` element.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (skills)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"skills\"/>\n\nIf you run the application right now, you see the list of skills in the selection control.\nThe input elements are not yet bound to data values or events, so they are still blank and have no behavior.\n\n## Bind input controls to data properties\n\nThe next step is to bind the input controls to the corresponding `Actor` properties with two-way data binding, so that they respond to user input by updating the data model, and also respond to programmatic changes in the data by updating the display.\n\nThe `ngModel` directive declared in the `FormsModule` lets you bind controls in your template-driven form to properties in your data model.\nWhen you include the directive using the syntax for two-way data binding, `[(ngModel)]`, Angular can track the value and user interaction of the control and keep the view synced with the model.\n\n1. Edit the template file `actor-form.component.html`.\n1. Find the `<input>` tag next to the **Name** label.\n1. Add the `ngModel` directive, using two-way data binding syntax `[(ngModel)]=\"...\"`.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"ngModelName-1\"/>\n\nHELPFUL: This example has a temporary diagnostic interpolation after each input tag, `{{model.name}}`, to show the current data value of the corresponding property. The comment reminds you to remove the diagnostic lines when you have finished observing the two-way data binding at work.\n\n### Access the overall form status\n\nWhen you imported the `FormsModule` in your component, Angular automatically created and attached an [NgForm](api/forms/NgForm) directive to the `<form>` tag in the template (because `NgForm` has the selector `form` that matches `<form>` elements).\n\nTo get access to the `NgForm` and the overall form status, declare a [template reference variable](guide/templates/variables#template-reference-variables).\n\n1. Edit the template file `actor-form.component.html`.\n1. Update the `<form>` tag with a template reference variable, `#actorForm`, and set its value as follows.\n\n   <docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"template-variable\"/>\n\n   The `actorForm` template variable is now a reference to the `NgForm` directive instance that governs the form as a whole.\n\n1. Run the app.\n1. Start typing in the **Name** input box.\n\n   As you add and delete characters, you can see them appear and disappear from the data model.\n\nThe diagnostic line that shows interpolated values demonstrates that values are really flowing from the input box to the model and back again.\n\n### Naming control elements\n\nWhen you use `[(ngModel)]` on an element, you must define a `name` attribute for that element.\nAngular uses the assigned name to register the element with the `NgForm` directive attached to the parent `<form>` element.\n\nThe example added a `name` attribute to the `<input>` element and set it to \"name\", which makes sense for the actor's name.\nAny unique value will do, but using a descriptive name is helpful.\n\n1. Add similar `[(ngModel)]` bindings and `name` attributes to **Studio** and **Skill**.\n1. You can now remove the diagnostic messages that show interpolated values.\n1. To confirm that two-way data binding works for the entire actor model, add a new text binding with the [`json`](api/common/JsonPipe) pipe at the top to the component's template, which serializes the data to a string.\n\nAfter these revisions, the form template should look like the following:\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"ngModel-2\"/>\n\nYou'll notice that:\n\n- Each `<input>` element has an `id` property.\n  This is used by the `<label>` element's `for` attribute to match the label to its input control.\n  This is a [standard HTML feature](https://developer.mozilla.org/docs/Web/HTML/Element/label).\n\n- Each `<input>` element also has the required `name` property that Angular uses to register the control with the form.\n\nWhen you have observed the effects, you can delete the `{{ model | json }}` text binding.\n\n## Track form states\n\nAngular applies the `ng-submitted` class to `form` elements after the form has been submitted. This class can be used to change the form's style after it has been submitted.\n\n## Track control states\n\nAdding the `NgModel` directive to a control adds class names to the control that describe its state.\nThese classes can be used to change a control's style based on its state.\n\nThe following table describes the class names that Angular applies based on the control's state.\n\n| States                           | Class if true | Class if false |\n| :------------------------------- | :------------ | :------------- |\n| The control has been visited.    | `ng-touched`  | `ng-untouched` |\n| The control's value has changed. | `ng-dirty`    | `ng-pristine`  |\n| The control's value is valid.    | `ng-valid`    | `ng-invalid`   |\n\nAngular also applies the `ng-submitted` class to `form` elements upon submission,\nbut not to the controls inside the `form` element.\n\nYou use these CSS classes to define the styles for your control based on its status.\n\n### Observe control states\n\nTo see how the classes are added and removed by the framework, open the browser's developer tools and inspect the `<input>` element that represents the actor name.\n\n1. Using your browser's developer tools, find the `<input>` element that corresponds to the **Name** input box.\n   You can see that the element has multiple CSS classes in addition to \"form-control\".\n\n1. When you first bring it up, the classes indicate that it has a valid value, that the value has not been changed since initialization or reset, and that the control has not been visited since initialization or reset.\n\n   <docs-code language=\"html\">\n\n   <input class=\"form-control ng-untouched ng-pristine ng-valid\">;\n\n   </docs-code>\n\n1. Take the following actions on the **Name** `<input>` box, and observe which classes appear.\n\n   - Look but don't touch.\n     The classes indicate that it is untouched, pristine, and valid.\n\n   - Click inside the name box, then click outside it.\n     The control has now been visited, and the element has the `ng-touched` class instead of the `ng-untouched` class.\n\n   - Add slashes to the end of the name.\n     It is now touched and dirty.\n\n   - Erase the name.\n     This makes the value invalid, so the `ng-invalid` class replaces the `ng-valid` class.\n\n### Create visual feedback for states\n\nThe `ng-valid`/`ng-invalid` pair is particularly interesting, because you want to send a\nstrong visual signal when the values are invalid.\nYou also want to mark required fields.\n\nYou can mark required fields and invalid data at the same time with a colored bar\non the left of the input box.\n\nTo change the appearance in this way, take the following steps.\n\n1. Add definitions for the `ng-*` CSS classes.\n1. Add these class definitions to a new `forms.css` file.\n1. Add the new file to the project as a sibling to `index.html`:\n\n<docs-code header=\"src/assets/forms.css\" language=\"css\" path=\"adev/src/content/examples/forms/src/assets/forms.css\"/>\n\n1. In the `index.html` file, update the `<head>` tag to include the new style sheet.\n\n<docs-code header=\"src/index.html (styles)\" path=\"adev/src/content/examples/forms/src/index.html\" visibleRegion=\"styles\"/>\n\n### Show and hide validation error messages\n\nThe **Name** input box is required and clearing it turns the bar red.\nThat indicates that something is wrong, but the user doesn't know what is wrong or what to do about it.\nYou can provide a helpful message by checking for and responding to the control's state.\n\nThe **Skill** select box is also required, but it doesn't need this kind of error handling because the selection box already constrains the selection to valid values.\n\nTo define and show an error message when appropriate, take the following steps.\n\n<docs-workflow>\n<docs-step title=\"Add a local reference to the input\">\nExtend the `input` tag with a template reference variable that you can use to access the input box's Angular control from within the template. In the example, the variable is `#name=\"ngModel\"`.\n\nThe template reference variable (`#name`) is set to `\"ngModel\"` because that is the value of the [`NgModel.exportAs`](api/core/Directive#exportAs) property. This property tells Angular how to link a reference variable to a directive.\n</docs-step>\n\n<docs-step title=\"Add the error message\">\nAdd a `<div>` that contains a suitable error message.\n</docs-step>\n\n<docs-step title=\"Make the error message conditional\">\nShow or hide the error message by binding properties of the `name` control to the message `<div>` element's `hidden` property.\n</docs-step>\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (hidden-error-msg)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"hidden-error-msg\"/>\n\n<docs-step title=\"Add a conditional error message to name\">\nAdd a conditional error message to the `name` input box, as in the following example.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"name-with-error-msg\"/>\n</docs-step>\n</docs-workflow>\n\n<docs-callout title='Illustrating the \"pristine\" state'>\n\nIn this example, you hide the message when the control is either valid or _pristine_.\nPristine means the user hasn't changed the value since it was displayed in this form.\nIf you ignore the `pristine` state, you would hide the message only when the value is valid.\nIf you arrive in this component with a new, blank actor or an invalid actor, you'll see the error message immediately, before you've done anything.\n\nYou might want the message to display only when the user makes an invalid change.\nHiding the message while the control is in the `pristine` state achieves that goal.\nYou'll see the significance of this choice when you add a new actor to the form in the next step.\n\n</docs-callout>\n\n## Add a new actor\n\nThis exercise shows how you can respond to a native HTML button-click event by adding to the model data.\nTo let form users add a new actor, you will add a **New Actor** button that responds to a click event.\n\n1. In the template, place a \"New Actor\" `<button>` element at the bottom of the form.\n1. In the component file, add the actor-creation method to the actor data model.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.ts (New Actor method)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" visibleRegion=\"new-actor\"/>\n\n1. Bind the button's click event to an actor-creation method, `newActor()`.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (New Actor button)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"new-actor-button-no-reset\"/>\n\n1. Run the application again and click the **New Actor** button.\n\n   The form clears, and the _required_ bars to the left of the input box are red, indicating invalid `name` and `skill` properties.\n   Notice that the error messages are hidden.\n   This is because the form is pristine; you haven't changed anything yet.\n\n1. Enter a name and click **New Actor** again.\n\n   Now the application displays a `Name is required` error message, because the input box is no longer pristine.\n   The form remembers that you entered a name before clicking **New Actor**.\n\n1. To restore the pristine state of the form controls, clear all of the flags imperatively by calling the form's `reset()` method after calling the `newActor()` method.\n\n   <docs-code header=\"src/app/actor-form/actor-form.component.html (Reset the form)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"new-actor-button-form-reset\"/>\n\n   Now clicking **New Actor** resets both the form and its control flags.\n\n## Submit the form with `ngSubmit`\n\nThe user should be able to submit this form after filling it in.\nThe **Submit** button at the bottom of the form does nothing on its own, but it does trigger a form-submit event because of its type (`type=\"submit\"`).\n\nTo respond to this event, take the following steps.\n\n<docs-workflow>\n\n<docs-step title=\"Listen to ngOnSubmit\">\nBind the form's [`ngSubmit`](api/forms/NgForm#properties) event property to the actor-form component's `onSubmit()` method.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (ngSubmit)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"ngSubmit\"/>\n</docs-step>\n\n<docs-step title=\"Bind the disabled property\">\nUse the template reference variable, `#actorForm` to access the form that contains the **Submit** button and create an event binding.\n\nYou will bind the form property that indicates its overall validity to the **Submit** button's `disabled` property.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (submit-button)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"submit-button\"/>\n</docs-step>\n\n<docs-step title=\"Run the application\">\nNotice that the button is enabled —although it doesn't do anything useful yet.\n</docs-step>\n\n<docs-step title=\"Delete the Name value\">\nThis violates the \"required\" rule, so it displays the error message —and notice that it also disables the **Submit** button.\n\nYou didn't have to explicitly wire the button's enabled state to the form's validity.\nThe `FormsModule` did this automatically when you defined a template reference variable on the enhanced form element, then referred to that variable in the button control.\n</docs-step>\n</docs-workflow>\n\n### Respond to form submission\n\nTo show a response to form submission, you can hide the data entry area and display something else in its place.\n\n<docs-workflow>\n<docs-step title=\"Wrap the form\">\nWrap the entire form in a `<div>` and bind its `hidden` property to the `ActorFormComponent.submitted` property.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"edit-div\"/>\n\nThe main form is visible from the start because the `submitted` property is false until you submit the form, as this fragment from the `ActorFormComponent` shows:\n\n<docs-code header=\"src/app/actor-form/actor-form.component.ts (submitted)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" visibleRegion=\"submitted\"/>\n\nWhen you click the **Submit** button, the `submitted` flag becomes true and the form disappears.\n</docs-step>\n\n<docs-step title=\"Add the submitted state\">\nTo show something else while the form is in the submitted state, add the following HTML below the new `<div>` wrapper.\n\n<docs-code header=\"src/app/actor-form/actor-form.component.html (excerpt)\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"submitted\"/>\n\nThis `<div>`, which shows a read-only actor with interpolation bindings, appears only while the component is in the submitted state.\n\nThe alternative display includes an _Edit_ button whose click event is bound to an expression that clears the `submitted` flag.\n</docs-step>\n\n<docs-step title=\"Test the Edit button\">\nClick the *Edit* button to switch the display back to the editable form.\n</docs-step>\n</docs-workflow>\n\n## Summary\n\nThe Angular form discussed in this page takes advantage of the following\nframework features to provide support for data modification, validation, and more.\n\n- An Angular HTML form template\n- A form component class with a `@Component` decorator\n- Handling form submission by binding to the `NgForm.ngSubmit` event property\n- Template-reference variables such as `#actorForm` and `#name`\n- `[(ngModel)]` syntax for two-way data binding\n- The use of `name` attributes for validation and form-element change tracking\n- The reference variable's `valid` property on input controls indicates whether a control is valid or should show error messages\n- Controlling the **Submit** button's enabled state by binding to `NgForm` validity\n- Custom CSS classes that provide visual feedback to users about controls that are not valid\n\nHere's the code for the final version of the application:\n\n<docs-code-multifile>\n    <docs-code header=\"actor-form/actor-form.component.ts\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.ts\" visibleRegion=\"final\"/>\n    <docs-code header=\"actor-form/actor-form.component.html\" path=\"adev/src/content/examples/forms/src/app/actor-form/actor-form.component.html\" visibleRegion=\"final\"/>\n    <docs-code header=\"actor.ts\" path=\"adev/src/content/examples/forms/src/app/actor.ts\"/>\n    <docs-code header=\"app.component.html\" path=\"adev/src/content/examples/forms/src/app/app.component.html\"/>\n    <docs-code header=\"app.component.ts\" path=\"adev/src/content/examples/forms/src/app/app.component.ts\"/>\n    <docs-code header=\"main.ts\" path=\"adev/src/content/examples/forms/src/main.ts\"/>\n    <docs-code header=\"forms.css\" path=\"adev/src/content/examples/forms/src/assets/forms.css\"/>\n</docs-code-multifile>\n\n\n\n================================================\n",
    "endLine": 10397
  },
  {
    "id": 42,
    "file": "typed-forms",
    "fullFileName": "adev/src/content/guide/forms/typed-forms.md",
    "startLine": 10401,
    "content": "# Typed Forms\n\nAs of Angular 14, reactive forms are strictly typed by default.\n\nAs background for this guide, you should already be familiar with [Angular Reactive Forms](guide/forms/reactive-forms).\n\n## Overview of Typed Forms\n\n<docs-video src=\"https://www.youtube.com/embed/L-odCf4MfJc\" alt=\"Typed Forms in Angular\" />\n\nWith Angular reactive forms, you explicitly specify a *form model*. As a simple example, consider this basic user login form:\n\n```ts\nconst login = new FormGroup({\n  email: new FormControl(''),\n  password: new FormControl(''),\n});\n```\n\nAngular provides many APIs for interacting with this `FormGroup`. For example, you may call `login.value`, `login.controls`, `login.patchValue`, etc. (For a full API reference, see the [API documentation](api/forms/FormGroup).)\n\nIn previous Angular versions, most of these APIs included `any` somewhere in their types, and interacting with the structure of the controls, or the values themselves, was not type-safe. For example: you could write the following invalid code:\n\n```ts\nconst emailDomain = login.value.email.domain;\n```\n\nWith strictly typed reactive forms, the above code does not compile, because there is no `domain` property on `email`.\n\nIn addition to the added safety, the types enable a variety of other improvements, such as better autocomplete in IDEs, and an explicit way to specify form structure.\n\nThese improvements currently apply only to *reactive* forms (not [*template-driven* forms](guide/forms/template-driven-forms)).\n\n## Untyped Forms\n\nNon-typed forms are still supported, and will continue to work as before. To use them, you must import the `Untyped` symbols from `@angular/forms`:\n\n```ts\nconst login = new UntypedFormGroup({\n  email: new UntypedFormControl(''),\n  password: new UntypedFormControl(''),\n});\n```\n\nEach `Untyped` symbol has exactly the same semantics as in previous Angular version. By removing the `Untyped` prefixes, you can incrementally enable the types.\n\n## `FormControl`: Getting Started\n\nThe simplest possible form consists of a single control:\n\n```ts\nconst email = new FormControl('angularrox@gmail.com');\n```\n\nThis control will be automatically inferred to have the type `FormControl<string|null>`. TypeScript will automatically enforce this type throughout the [`FormControl` API](api/forms/FormControl), such as `email.value`, `email.valueChanges`, `email.setValue(...)`, etc.\n\n### Nullability\n\nYou might wonder: why does the type of this control include `null`?  This is because the control can become `null` at any time, by calling reset:\n\n```ts\nconst email = new FormControl('angularrox@gmail.com');\nemail.reset();\nconsole.log(email.value); // null\n```\n\nTypeScript will enforce that you always handle the possibility that the control has become `null`. If you want to make this control non-nullable, you may use the `nonNullable` option. This will cause the control to reset to its initial value, instead of `null`:\n\n```ts\nconst email = new FormControl('angularrox@gmail.com', {nonNullable: true});\nemail.reset();\nconsole.log(email.value); // angularrox@gmail.com\n```\n\nTo reiterate, this option affects the runtime behavior of your form when `.reset()` is called, and should be flipped with care.\n\n### Specifying an Explicit Type\n\nIt is possible to specify the type, instead of relying on inference. Consider a control that is initialized to `null`. Because the initial value is `null`, TypeScript will infer `FormControl<null>`, which is narrower than we want.\n\n```ts\nconst email = new FormControl(null);\nemail.setValue('angularrox@gmail.com'); // Error!\n```\n\nTo prevent this, we explicitly specify the type as `string|null`:\n\n```ts\nconst email = new FormControl<string|null>(null);\nemail.setValue('angularrox@gmail.com');\n```\n\n## `FormArray`: Dynamic, Homogenous Collections\n\nA `FormArray` contains an open-ended list of controls. The type parameter corresponds to the type of each inner control:\n\n```ts\nconst names = new FormArray([new FormControl('Alex')]);\nnames.push(new FormControl('Jess'));\n```\n\nThis `FormArray` will have the inner controls type `FormControl<string|null>`.\n\nIf you want to have multiple different element types inside the array, you must use `UntypedFormArray`, because TypeScript cannot infer which element type will occur at which position.\n\n## `FormGroup` and `FormRecord`\n\nAngular provides the `FormGroup` type for forms with an enumerated set of keys, and a type called `FormRecord`, for open-ended or dynamic groups.\n\n### Partial Values\n\nConsider again a login form:\n\n```ts\nconst login = new FormGroup({\n    email: new FormControl('', {nonNullable: true}),\n    password: new FormControl('', {nonNullable: true}),\n});\n```\n\nOn any `FormGroup`, it is [possible to disable controls](api/forms/FormGroup). Any disabled control will not appear in the group's value.\n\nAs a consequence, the type of `login.value` is `Partial<{email: string, password: string}>`. The `Partial` in this type means that each member might be undefined.\n\nMore specifically, the type of `login.value.email` is `string|undefined`, and TypeScript will enforce that you handle the possibly `undefined` value (if you have `strictNullChecks` enabled).\n\nIf you want to access the value *including* disabled controls, and thus bypass possible `undefined` fields, you can use `login.getRawValue()`.\n\n### Optional Controls and Dynamic Groups\n\nSome forms have controls that may or may not be present, which can be added and removed at runtime. You can represent these controls using *optional fields*:\n\n```ts\ninterface LoginForm {\n  email: FormControl<string>;\n  password?: FormControl<string>;\n}\n\nconst login = new FormGroup<LoginForm>({\n  email: new FormControl('', {nonNullable: true}),\n  password: new FormControl('', {nonNullable: true}),\n});\n\nlogin.removeControl('password');\n```\n\nIn this form, we explicitly specify the type, which allows us to make the `password` control optional. TypeScript will enforce that only optional controls can be added or removed.\n\n### `FormRecord`\n\nSome `FormGroup` usages do not fit the above pattern because the keys are not known ahead of time. The `FormRecord` class is designed for that case:\n\n```ts\nconst addresses = new FormRecord<FormControl<string|null>>({});\naddresses.addControl('Andrew', new FormControl('2340 Folsom St'));\n```\n\nAny control of type `string|null` can be added to this `FormRecord`.\n\nIf you need a `FormGroup` that is both dynamic (open-ended) and heterogeneous (the controls are different types), no improved type safety is possible, and you should use `UntypedFormGroup`.\n\nA `FormRecord` can also be built with the `FormBuilder`:\n\n```ts\nconst addresses = fb.record({'Andrew': '2340 Folsom St'});\n```\n\n## `FormBuilder` and `NonNullableFormBuilder`\n\nThe `FormBuilder` class has been upgraded to support the new types as well, in the same manner as the above examples.\n\nAdditionally, an additional builder is available: `NonNullableFormBuilder`. This type is shorthand for specifying `{nonNullable: true}` on every control, and can eliminate significant boilerplate from large non-nullable forms. You can access it using the `nonNullable` property on a `FormBuilder`:\n\n```ts\nconst fb = new FormBuilder();\nconst login = fb.nonNullable.group({\n  email: '',\n  password: '',\n});\n```\n\nOn the above example, both inner controls will be non-nullable (i.e. `nonNullable` will be set).\n\nYou can also inject it using the name `NonNullableFormBuilder`.\n\n\n\n================================================\nFILE: adev/src/content/guide/http/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"http\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 10602
  },
  {
    "id": 43,
    "file": "interceptors",
    "fullFileName": "adev/src/content/guide/http/interceptors.md",
    "startLine": 10606,
    "content": "# Interceptors\n\n`HttpClient` supports a form of middleware known as _interceptors_.\n\nTLDR: Interceptors are middleware that allows common patterns around retrying, caching, logging, and authentication to be abstracted away from individual requests.\n\n`HttpClient` supports two kinds of interceptors: functional and DI-based. Our recommendation is to use functional interceptors because they have more predictable behavior, especially in complex setups. Our examples in this guide use functional interceptors, and we cover [DI-based interceptors](#di-based-interceptors) in their own section at the end.\n\n## Interceptors\n\nInterceptors are generally functions which you can run for each request, and have broad capabilities to affect the contents and overall flow of requests and responses. You can install multiple interceptors, which form an interceptor chain where each interceptor processes the request or response before forwarding it to the next interceptor in the chain.\n\nYou can use interceptors to implement a variety of common patterns, such as:\n\n* Adding authentication headers to outgoing requests to a particular API.\n* Retrying failed requests with exponential backoff.\n* Caching responses for a period of time, or until invalidated by mutations.\n* Customizing the parsing of responses.\n* Measuring server response times and log them.\n* Driving UI elements such as a loading spinner while network operations are in progress.\n* Collecting and batch requests made within a certain timeframe.\n* Automatically failing requests after a configurable deadline or timeout.\n* Regularly polling the server and refreshing results.\n\n## Defining an interceptor\n\nThe basic form of an interceptor is a function which receives the outgoing `HttpRequest` and a `next` function representing the next processing step in the interceptor chain.\n\nFor example, this `loggingInterceptor` will log the outgoing request URL to `console.log` before forwarding the request:\n\n<docs-code language=\"ts\">\nexport function loggingInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {\n  console.log(req.url);\n  return next(req);\n}\n</docs-code>\n\nIn order for this interceptor to actually intercept requests, you must configure `HttpClient` to use it.\n\n## Configuring interceptors\n\nYou declare the set of interceptors to use when configuring `HttpClient` through dependency injection, by using the `withInterceptors` feature:\n\n<docs-code language=\"ts\">\nbootstrapApplication(AppComponent, {providers: [\n  provideHttpClient(\n    withInterceptors([loggingInterceptor, cachingInterceptor]),\n  )\n]});\n</docs-code>\n\nThe interceptors you configure are chained together in the order that you've listed them in the providers. In the above example, the `loggingInterceptor` would process the request and then forward it to the `cachingInterceptor`.\n\n### Intercepting response events\n\nAn interceptor may transform the `Observable` stream of `HttpEvent`s returned by `next` in order to access or manipulate the response. Because this stream includes all response events, inspecting the `.type` of each event may be necessary in order to identify the final response object.\n\n<docs-code language=\"ts\">\nexport function loggingInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {\n  return next(req).pipe(tap(event => {\n    if (event.type === HttpEventType.Response) {\n      console.log(req.url, 'returned a response with status', event.status);\n    }\n  }));\n}\n</docs-code>\n\nTIP: Interceptors naturally associate responses with their outgoing requests, because they transform the response stream in a closure that captures the request object.\n\n## Modifying requests\n\nMost aspects of `HttpRequest` and `HttpResponse` instances are _immutable_, and interceptors cannot directly modify them. Instead, interceptors apply mutations by cloning these objects using the `.clone()` operation, and specifying which properties should be mutated in the new instance. This might involve performing immutable updates on the value itself (like `HttpHeaders` or `HttpParams`).\n\nFor example, to add a header to a request:\n\n<docs-code language=\"ts\">\nconst reqWithHeader = req.clone({\n  headers: req.headers.set('X-New-Header', 'new header value'),\n});\n</docs-code>\n\nThis immutability allows most interceptors to be idempotent if the same `HttpRequest` is submitted to the interceptor chain multiple times. This can happen for a few reasons, including when a request is retried after failure.\n\nCRITICAL: The body of a request or response is **not** protected from deep mutations. If an interceptor must mutate the body, take care to handle running multiple times on the same request.\n\n## Dependency injection in interceptors\n\nInterceptors are run in the _injection context_ of the injector which registered them, and can use  Angular's `inject` API to retrieve dependencies.\n\nFor example, suppose an application has a service called `AuthService`, which creates authentication tokens for outgoing requests. An interceptor can inject and use this service:\n\n<docs-code language=\"ts\">\nexport function authInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn) {\n  // Inject the current `AuthService` and use it to get an authentication token:\n  const authToken = inject(AuthService).getAuthToken();\n\n  // Clone the request to add the authentication header.\n  const newReq = req.clone({\n    headers: req.headers.append('X-Authentication-Token', authToken),\n  });\n  return next(newReq);\n}\n</docs-code>\n\n## Request and response metadata\n\nOften it's useful to include information in a request that's not sent to the backend, but is specifically meant for interceptors. `HttpRequest`s have a `.context` object which stores this kind of metadata as an instance of `HttpContext`. This object functions as a typed map, with keys of type `HttpContextToken`.\n\nTo illustrate how this system works, let's use metadata to control whether a caching interceptor is enabled for a given request.\n\n### Defining context tokens\n\nTo store whether the caching interceptor should cache a particular request in that request's `.context` map, define a new `HttpContextToken` to act as a key:\n\n<docs-code language=\"ts\">\nexport const CACHING_ENABLED = new HttpContextToken<boolean>(() => true);\n</docs-code>\n\nThe provided function creates the default value for the token for requests that haven't explicitly set a value for it. Using a function ensures that if the token's value is an object or array, each request gets its own instance.\n\n### Reading the token in an interceptor\n\nAn interceptor can then read the token and choose to apply caching logic or not based on its value:\n\n<docs-code language=\"ts\">\nexport function cachingInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {\n  if (req.context.get(CACHING_ENABLED)) {\n    // apply caching logic\n    return ...;\n  } else {\n    // caching has been disabled for this request\n    return next(req);\n  }\n}\n</docs-code>\n\n### Setting context tokens when making a request\n\nWhen making a request via the `HttpClient` API, you can provide values for `HttpContextToken`s:\n\n<docs-code language=\"ts\">\nconst data$ = http.get('/sensitive/data', {\n  context: new HttpContext().set(CACHING_ENABLED, false),\n});\n</docs-code>\n\nInterceptors can read these values from the `HttpContext` of the request.\n\n### The request context is mutable\n\nUnlike other properties of `HttpRequest`s, the associated `HttpContext` is _mutable_. If an interceptor changes the context of a request that is later retried, the same interceptor will observe the context mutation when it runs again. This is useful for passing state across multiple retries if needed.\n\n## Synthetic responses\n\nMost interceptors will simply invoke the `next` handler while transforming either the request or the response, but this is not strictly a requirement. This section discusses several of the ways in which an interceptor may incorporate more advanced behavior.\n\nInterceptors are not required to invoke `next`. They may instead choose to construct responses through some other mechanism, such as from a cache or by sending the request through an alternate mechanism.\n\nConstructing a response is possible using the `HttpResponse` constructor:\n\n<docs-code language=\"ts\">\nconst resp = new HttpResponse({\n  body: 'response body',\n});\n</docs-code>\n\n## DI-based interceptors\n\n`HttpClient` also supports interceptors which are defined as injectable classes and configured through the DI system. The capabilities of DI-based interceptors are identical to those of functional interceptors, but the configuration mechanism is different.\n\nA DI-based interceptor is an injectable class which implements the `HttpInterceptor` interface:\n\n<docs-code language=\"ts\">\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, handler: HttpHandler): Observable<HttpEvent<any>> {\n    console.log('Request URL: ' + req.url);\n    return handler.handle(req);\n  }\n}\n</docs-code>\n\nDI-based interceptors are configured through a dependency injection multi-provider:\n\n<docs-code language=\"ts\">\nbootstrapApplication(AppComponent, {providers: [\n  provideHttpClient(\n    // DI-based interceptors must be explicitly enabled.\n    withInterceptorsFromDi(),\n  ),\n\n  {provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true},\n]});\n</docs-code>\n\nDI-based interceptors run in the order that their providers are registered. In an app with an extensive and hierarchical DI configuration, this order can be very hard to predict.\n\n\n\n================================================\n",
    "endLine": 10804
  },
  {
    "id": 44,
    "file": "making-requests",
    "fullFileName": "adev/src/content/guide/http/making-requests.md",
    "startLine": 10808,
    "content": "# Making HTTP requests\n\n`HttpClient` has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server. Each method returns an [RxJS `Observable`](https://rxjs.dev/guide/observable) which, when subscribed, sends the request and then emits the results when the server responds.\n\nNOTE: `Observable`s created by `HttpClient` may be subscribed any number of times and will make a new backend request for each subscription.\n\nThrough an options object passed to the request method, various properties of the request and the returned response type can be adjusted.\n\n## Fetching JSON data\n\nFetching data from a backend often requires making a GET request using the [`HttpClient.get()`](api/common/http/HttpClient#get) method. This method takes two arguments: the string endpoint URL from which to fetch, and an *optional options* object to configure the request.\n\nFor example, to fetch configuration data from a hypothetical API using the `HttpClient.get()` method:\n\n<docs-code language=\"ts\">\nhttp.get<Config>('/api/config').subscribe(config => {\n  // process the configuration.\n});\n</docs-code>\n\nNote the generic type argument which specifies that the data returned by the server will be of type `Config`. This argument is optional, and if you omit it then the returned data will have type `Object`.\n\nTIP: When dealing with data of uncertain structure and potential `undefined` or `null` values, consider using the `unknown` type instead of `Object` as the response type.\n\nCRITICAL: The generic type of request methods is a type **assertion** about the data returned by the server. `HttpClient` does not verify that the actual return data matches this type.\n\n## Fetching other types of data\n\nBy default, `HttpClient` assumes that servers will return JSON data. When interacting with a non-JSON API, you can tell `HttpClient` what response type to expect and return when making the request. This is done with the `responseType` option.\n\n| **`responseType` value** | **Returned response type** |\n| - | - |\n| `'json'` (default) | JSON data of the given generic type |\n| `'text'` | string data |\n| `'arraybuffer'` | [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing the raw response bytes |\n| `'blob'` | [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob) instance |\n\nFor example, you can ask `HttpClient` to download the raw bytes of a `.jpeg` image into an `ArrayBuffer`:\n\n<docs-code language=\"ts\">\nhttp.get('/images/dog.jpg', {responseType: 'arraybuffer'}).subscribe(buffer => {\n  console.log('The image is ' + buffer.byteLength + ' bytes large');\n});\n</docs-code>\n\n<docs-callout important title=\"Literal value for `responseType`\">\nBecause the value of `responseType` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `responseType: 'text' as const`.\n</docs-callout>\n\n## Mutating server state\n\nServer APIs which perform mutations often require making POST requests with a request body specifying the new state or the change to be made.\n\nThe [`HttpClient.post()`](api/common/http/HttpClient#post) method behaves similarly to `get()`, and accepts an additional `body` argument before its options:\n\n<docs-code language=\"ts\">\nhttp.post<Config>('/api/config', newConfig).subscribe(config => {\n  console.log('Updated config:', config);\n});\n</docs-code>\n\nMany different types of values can be provided as the request's `body`, and `HttpClient` will serialize them accordingly:\n\n| **`body` type** | **Serialized as** |\n| - | - |\n| string | Plain text |\n| number, boolean, array, or plain object | JSON |\n| [`ArrayBuffer`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | raw data from the buffer |\n| [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob) | raw data with the `Blob`'s content type |\n| [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData) | `multipart/form-data` encoded data |\n| [`HttpParams`](api/common/http/HttpParams) or [`URLSearchParams`](https://developer.mozilla.org/docs/Web/API/URLSearchParams) | `application/x-www-form-urlencoded` formatted string |\n\nIMPORTANT: Remember to `.subscribe()` to mutation request `Observable`s in order to actually fire the request.\n\n## Setting URL parameters\n\nSpecify request parameters that should be included in the request URL using the `params` option.\n\nPassing an object literal is the simplest way of configuring URL parameters:\n\n<docs-code language=\"ts\">\nhttp.get('/api/config', {\n  params: {filter: 'all'},\n}).subscribe(config => {\n  // ...\n});\n</docs-code>\n\nAlternatively, pass an instance of `HttpParams` if you need more control over the construction or serialization of the parameters.\n\nIMPORTANT: Instances of `HttpParams` are _immutable_ and cannot be directly changed. Instead, mutation methods such as `append()` return a new instance of `HttpParams` with the mutation applied.\n\n<docs-code language=\"ts\">\nconst baseParams = new HttpParams().set('filter', 'all');\n\nhttp.get('/api/config', {\n  params: baseParams.set('details', 'enabled'),\n}).subscribe(config => {\n  // ...\n});\n</docs-code>\n\nYou can instantiate `HttpParams` with a custom `HttpParameterCodec` that determines how `HttpClient` will encode the parameters into the URL.\n\n## Setting request headers\n\nSpecify request headers that should be included in the request using the `headers` option.\n\nPassing an object literal is the simplest way of configuring request headers:\n\n<docs-code language=\"ts\">\nhttp.get('/api/config', {\n  headers: {\n    'X-Debug-Level': 'verbose',\n  }\n}).subscribe(config => {\n  // ...\n});\n</docs-code>\n\nAlternatively, pass an instance of `HttpHeaders` if you need more control over the construction of headers\n\nIMPORTANT: Instances of `HttpHeaders` are _immutable_ and cannot be directly changed. Instead, mutation methods such as `append()` return a new instance of `HttpHeaders` with the mutation applied.\n\n<docs-code language=\"ts\">\nconst baseHeaders = new HttpHeaders().set('X-Debug-Level', 'minimal');\n\nhttp.get<Config>('/api/config', {\n  headers: baseHeaders.set('X-Debug-Level', 'verbose'),\n}).subscribe(config => {\n  // ...\n});\n</docs-code>\n\n## Interacting with the server response events\n\nFor convenience, `HttpClient` by default returns an `Observable` of the data returned by the server (the response body). Occasionally it's desirable to examine the actual response, for example to retrieve specific response headers.\n\nTo access the entire response, set the `observe` option to `'response'`:\n\n<docs-code language=\"ts\">\nhttp.get<Config>('/api/config', {observe: 'response'}).subscribe(res => {\n  console.log('Response status:', res.status);\n  console.log('Body:', res.body);\n});\n</docs-code>\n\n<docs-callout important title=\"Literal value for `observe`\">\nBecause the value of `observe` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `observe: 'response' as const`.\n</docs-callout>\n\n## Receiving raw progress events\n\nIn addition to the response body or response object, `HttpClient` can also return a stream of raw _events_ corresponding to specific moments in the request lifecycle. These events include when the request is sent, when the response header is returned, and when the body is complete. These events can also include _progress events_ which report upload and download status for large request or response bodies.\n\nProgress events are disabled by default (as they have a performance cost) but can be enabled with the `reportProgress` option.\n\nNOTE: The optional `fetch` implementation of `HttpClient` does not report _upload_ progress events.\n\nTo observe the event stream, set the `observe` option to `'events'`:\n\n<docs-code language=\"ts\">\nhttp.post('/api/upload', myData, {\n  reportProgress: true,\n  observe: 'events',\n}).subscribe(event => {\n  switch (event.type) {\n    case HttpEventType.UploadProgress:\n      console.log('Uploaded ' + event.loaded + ' out of ' + event.total + ' bytes');\n      break;\n    case HttpEventType.Response:\n      console.log('Finished uploading!');\n      break;\n  }\n});\n</docs-code>\n\n<docs-callout important title=\"Literal value for `observe`\">\nBecause the value of `observe` affects the type returned by `HttpClient`, it must have a literal type and not a `string` type.\n\nThis happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as `observe: 'events' as const`.\n</docs-callout>\n\nEach `HttpEvent` reported in the event stream has a `type` which distinguishes what the event represents:\n\n| **`type` value** | **Event meaning** |\n| - | - |\n| `HttpEventType.Sent` | The request has been dispatched to the server |\n| `HttpEventType.UploadProgress` | An `HttpUploadProgressEvent` reporting progress on uploading the request body |\n| `HttpEventType.ResponseHeader` | The head of the response has been received, including status and headers |\n| `HttpEventType.DownloadProgress` | An `HttpDownloadProgressEvent` reporting progress on downloading the response body |\n| `HttpEventType.Response` | The entire response has been received, including the response body |\n| `HttpEventType.User` | A custom event from an Http interceptor.\n\n## Handling request failure\n\nThere are two ways an HTTP request can fail:\n\n* A network or connection error can prevent the request from reaching the backend server.\n* The backend can receive the request but fail to process it, and return an error response.\n\n`HttpClient` captures both kinds of errors in an `HttpErrorResponse` which it returns through the `Observable`'s error channel. Network errors have a `status` code of `0` and an `error` which is an instance of [`ProgressEvent`](https://developer.mozilla.org/docs/Web/API/ProgressEvent). Backend errors have the failing `status` code returned by the backend, and the error response as the `error`. Inspect the response to identify the error's cause and the appropriate action to handle the error.\n\nThe [RxJS library](https://rxjs.dev/) offers several operators which can be useful for error handling.\n\nYou can use the `catchError` operator to transform an error response into a value for the UI. This value can tell the UI to display an error page or value, and capture the error's cause if necessary.\n\nSometimes transient errors such as network interruptions can cause a request to fail unexpectedly, and simply retrying the request will allow it to succeed. RxJS provides several *retry* operators which automatically re-subscribe to a failed `Observable` under certain conditions. For example, the `retry()` operator will automatically attempt to re-subscribe a specified number of times.\n\n## Http `Observable`s\n\nEach request method on `HttpClient` constructs and returns an `Observable` of the requested response type. Understanding how these `Observable`s work is important when using `HttpClient`.\n\n`HttpClient` produces what RxJS calls \"cold\" `Observable`s, meaning that no actual request happens until the `Observable` is subscribed. Only then is the request actually dispatched to the server. Subscribing to the same `Observable` multiple times will trigger multiple backend requests. Each subscription is independent.\n\nTIP: You can think of `HttpClient` `Observable`s as _blueprints_ for actual server requests.\n\nOnce subscribed, unsubscribing will abort the in-progress request. This is very useful if the `Observable` is subscribed via the `async` pipe, as it will automatically cancel the request if the user navigates away from the current page. Additionally, if you use the `Observable` with an RxJS combinator like `switchMap`, this cancellation will clean up any stale requests.\n\nOnce the response returns, `Observable`s from `HttpClient` usually complete (although interceptors can influence this).\n\nBecause of the automatic completion, there is usually no risk of memory leaks if `HttpClient` subscriptions are not cleaned up. However, as with any async operation, we strongly recommend that you clean up subscriptions when the component using them is destroyed, as the subscription callback may otherwise run and encounter errors when it attempts to interact with the destroyed component.\n\nTIP: Using the `async` pipe or the `toSignal` operation to subscribe to `Observable`s ensures that subscriptions are disposed properly.\n\n## Best practices\n\nWhile `HttpClient` can be injected and used directly from components, generally we recommend you create reusable, injectable services which isolate and encapsulate data access logic. For example, this `UserService` encapsulates the logic to request data for a user by their id:\n\n<docs-code language=\"ts\">\n@Injectable({providedIn: 'root'})\nexport class UserService {\n  private http = inject(HttpClient);\n\n  getUser(id: string): Observable<User> {\n    return this.http.get<User>(`/api/user/${id}`);\n  }\n}\n</docs-code>\n\nWithin a component, you can combine `@if` with the `async` pipe to render the UI for the data only after it's finished loading:\n\n<docs-code language=\"ts\">\nimport { AsyncPipe } from '@angular/common';\n@Component({\n  imports: [AsyncPipe],\n  template: `\n    @if (user$ | async; as user) {\n      <p>Name: {{ user.name }}</p>\n      <p>Biography: {{ user.biography }}</p>\n    }\n  `,\n})\nexport class UserProfileComponent {\n  @Input() userId!: string;\n  user$!: Observable<User>;\n\n  private userService = inject(UserService);\n\n  constructor(): void {\n    this.user$ = this.userService.getUser(this.userId);\n  }\n}\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 11078
  },
  {
    "id": 45,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/http/overview.md",
    "startLine": 11082,
    "content": "# Understanding communicating with backend services using HTTP\n\nMost front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services. Angular provides a client HTTP API for Angular applications, the `HttpClient` service class in `@angular/common/http`.\n\n## HTTP client service features\n\nThe HTTP client service offers the following major features:\n\n* The ability to request [typed response values](guide/http/making-requests#fetching-json-data)\n* Streamlined [error handling](guide/http/making-requests#handling-request-failure)\n* Request and response [interception](guide/http/interceptors)\n* Robust [testing utilities](guide/http/testing)\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/http/setup\" title=\"Setting up HttpClient\"/>\n  <docs-pill href=\"guide/http/making-requests\" title=\"Making HTTP requests\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 11103
  },
  {
    "id": 46,
    "file": "security",
    "fullFileName": "adev/src/content/guide/http/security.md",
    "startLine": 11107,
    "content": "# `HttpClient` security\n\n`HttpClient` includes built-in support for two common HTTP security mechanisms: XSSI protection and XSRF/CSRF protection.\n\nTIP: Also consider adopting a [Content Security Policy](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy) for your APIs.\n\n## XSSI protection\n\nCross-Site Script Inclusion (XSSI) is a form of [Cross-Site Scripting](https://en.wikipedia.org/wiki/Cross-site_scripting) attack where an attacker loads JSON data from your API endpoints as `<script>`s on a page they control. Different JavaScript techniques can then be used to access this data.\n\nA common technique to prevent XSSI is to serve JSON responses with a \"non-executable prefix\", commonly `)]}',\\n`. This prefix prevents the JSON response from being interpreted as valid executable JavaScript. When the API is loaded as data, the prefix can be stripped before JSON parsing.\n\n`HttpClient` automatically strips this XSSI prefix (if present) when parsing JSON from a response.\n\n## XSRF/CSRF protection\n\n[Cross-Site Request Forgery (XSRF or CSRF)](https://en.wikipedia.org/wiki/Cross-site_request_forgery) is an attack technique by which the attacker can trick an authenticated user into unknowingly executing actions on your website.\n\n`HttpClient` supports a [common mechanism](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) used to prevent XSRF attacks. When performing HTTP requests, an interceptor reads a token from a cookie, by default `XSRF-TOKEN`, and sets it as an HTTP header, `X-XSRF-TOKEN`. Because only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.\n\nBy default, an interceptor sends this header on all mutating requests (such as `POST`) to relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.\n\n<docs-callout helpful title=\"Why not protect GET requests?\">\nCSRF protection is only needed for requests that can change state on the backend. By their nature, CSRF attacks cross domain boundaries, and the web's [same-origin policy](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) will prevent an attacking page from retrieving the results of authenticated GET requests.\n</docs-callout>\n\nTo take advantage of this, your server needs to set a token in a JavaScript readable session cookie called `XSRF-TOKEN` on either the page load or the first GET request. On subsequent requests the server can verify that the cookie matches the `X-XSRF-TOKEN` HTTP header, and therefore be sure that only code running on your domain could have sent the request. The token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens. Set the token to a digest of your site's authentication cookie with a salt for added security.\n\nTo prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.\n\n<docs-callout important title=\"HttpClient supports only the client half of the XSRF protection scheme\">\n  Your backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests. Failing to do so renders Angular's default protection ineffective.\n</docs-callout>\n\n### Configure custom cookie/header names\n\nIf your backend service uses different names for the XSRF token cookie or header, use `withXsrfConfiguration` to override the defaults.\n\nAdd it to the `provideHttpClient` call as follows:\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withXsrfConfiguration({\n        cookieName: 'CUSTOM_XSRF_TOKEN',\n        headerName: 'X-Custom-Xsrf-Header',\n      }),\n    ),\n  ]\n};\n</docs-code>\n\n### Disabling XSRF protection\n\nIf the built-in XSRF protection mechanism doesn't work for your application, you can disable it using the `withNoXsrfProtection` feature:\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withNoXsrfProtection(),\n    ),\n  ]\n};\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 11175
  },
  {
    "id": 47,
    "file": "setup",
    "fullFileName": "adev/src/content/guide/http/setup.md",
    "startLine": 11179,
    "content": "# Setting up `HttpClient`\n\nBefore you can use `HttpClient` in your app, you must configure it using [dependency injection](guide/di).\n\n## Providing `HttpClient` through dependency injection\n\n`HttpClient` is provided using the `provideHttpClient` helper function, which most apps include in the application `providers` in `app.config.ts`.\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(),\n  ]\n};\n</docs-code>\n\nIf your app is using NgModule-based bootstrap instead, you can include `provideHttpClient` in the providers of your app's NgModule:\n\n<docs-code language=\"ts\">\n@NgModule({\n  providers: [\n    provideHttpClient(),\n  ],\n  // ... other application configuration\n})\nexport class AppModule {}\n</docs-code>\n\nYou can then inject the `HttpClient` service as a dependency of your components, services, or other classes:\n\n<docs-code language=\"ts\">\n@Injectable({providedIn: 'root'})\nexport class ConfigService {\n  private http = inject(HttpClient);\n  // This service can now make HTTP requests via `this.http`.\n}\n</docs-code>\n\n## Configuring features of `HttpClient`\n\n`provideHttpClient` accepts a list of optional feature configurations, to enable or configure the behavior of different aspects of the client. This section details the optional features and their usages.\n\n### `withFetch`\n\n<docs-code language=\"ts\">\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withFetch(),\n    ),\n  ]\n};\n</docs-code>\n\nBy default, `HttpClient` uses the [`XMLHttpRequest`](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest) API to make requests. The `withFetch` feature switches the client to use the [`fetch`](https://developer.mozilla.org/docs/Web/API/Fetch_API) API instead.\n\n`fetch` is a more modern API and is available in a few environments where `XMLHttpRequest` is not supported. It does have a few limitations, such as not producing upload progress events.\n\n### `withInterceptors(...)`\n\n`withInterceptors` configures the set of interceptor functions which will process requests made through `HttpClient`. See the [interceptor guide](guide/http/interceptors) for more information.\n\n### `withInterceptorsFromDi()`\n\n`withInterceptorsFromDi` includes the older style of class-based interceptors in the `HttpClient` configuration. See the [interceptor guide](guide/http/interceptors) for more information.\n\nHELPFUL: Functional interceptors (through `withInterceptors`) have more predictable ordering and we recommend them over DI-based interceptors.\n\n### `withRequestsMadeViaParent()`\n\nBy default, when you configure `HttpClient` using `provideHttpClient` within a given injector, this configuration overrides any configuration for `HttpClient` which may be present in the parent injector.\n\nWhen you add `withRequestsMadeViaParent()`, `HttpClient` is configured to instead pass requests up to the `HttpClient` instance in the parent injector, once they've passed through any configured interceptors at this level. This is useful if you want to _add_ interceptors in a child injector, while still sending the request through the parent injector's interceptors as well.\n\nCRITICAL: You must configure an instance of `HttpClient` above the current injector, or this option is not valid and you'll get a runtime error when you try to use it.\n\n### `withJsonpSupport()`\n\nIncluding `withJsonpSupport` enables the `.jsonp()` method on `HttpClient`, which makes a GET request via the [JSONP convention](https://en.wikipedia.org/wiki/JSONP) for cross-domain loading of data.\n\nHELPFUL: Prefer using [CORS](https://developer.mozilla.org/docs/Web/HTTP/CORS) to make cross-domain requests instead of JSONP when possible.\n\n### `withXsrfConfiguration(...)`\n\nIncluding this option allows for customization of `HttpClient`'s built-in XSRF security functionality. See the [security guide](best-practices/security) for more information.\n\n### `withNoXsrfProtection()`\n\nIncluding this option disables `HttpClient`'s built-in XSRF security functionality. See the [security guide](best-practices/security) for more information.\n\n## `HttpClientModule`-based configuration\n\nSome applications may configure `HttpClient` using the older API based on NgModules.\n\nThis table lists the NgModules available from `@angular/common/http` and how they relate to the provider configuration functions above.\n\n| **NgModule**                            | `provideHttpClient()` equivalent              |\n| --------------------------------------- | --------------------------------------------- |\n| `HttpClientModule`                      | `provideHttpClient(withInterceptorsFromDi())` |\n| `HttpClientJsonpModule`                 | `withJsonpSupport()`                          |\n| `HttpClientXsrfModule.withOptions(...)` | `withXsrfConfiguration(...)`                  |\n| `HttpClientXsrfModule.disable()`        | `withNoXsrfProtection()`                      |\n\n<docs-callout important title=\"Use caution when using HttpClientModule in multiple injectors\">\nWhen `HttpClientModule` is present in multiple injectors, the behavior of interceptors is poorly defined and depends on the exact options and provider/import ordering.\n\nPrefer `provideHttpClient` for multi-injector configurations, as it has more stable behavior. See the `withRequestsMadeViaParent` feature above.\n</docs-callout>\n\n\n\n================================================\n",
    "endLine": 11289
  },
  {
    "id": 48,
    "file": "testing",
    "fullFileName": "adev/src/content/guide/http/testing.md",
    "startLine": 11293,
    "content": "# Test requests\n\nAs for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The `@angular/common/http/testing` library provides tools to capture requests made by the application, make assertions about them, and mock the responses to emulate your backend's behavior.\n\nThe testing library is designed for a pattern in which the app executes code and makes requests first. The test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.\n\nAt the end, tests can verify that the app made no unexpected requests.\n\n## Setup for testing\n\nTo begin testing usage of `HttpClient`, configure `TestBed` and include `provideHttpClient()` and `provideHttpClientTesting()` in your test's setup. This configures `HttpClient` to use a test backend instead of the real network. It also provides `HttpTestingController`, which you'll use to interact with the test backend, set expectations about which requests have been made, and flush responses to those requests. `HttpTestingController` can be injected from `TestBed` once configured.\n\nKeep in mind to provide `provideHttpClient()` **before** `provideHttpClientTesting()`, as `provideHttpClientTesting()` will overwrite parts of `provideHttpCient()`. Doing it the other way around can potentially break your tests.\n\n<docs-code language=\"ts\">\nTestBed.configureTestingModule({\n  providers: [\n    // ... other test providers\n    provideHttpClient(),\n    provideHttpClientTesting(),\n  ],\n});\n\nconst httpTesting = TestBed.inject(HttpTestingController);\n</docs-code>\n\nNow when your tests make requests, they will hit the testing backend instead of the normal one. You can use `httpTesting` to make assertions about those requests.\n\n## Expecting and answering requests\n\nFor example, you can write a test that expects a GET request to occur and provides a mock response:\n\n<docs-code language=\"ts\">\nTestBed.configureTestingModule({\n  providers: [\n    ConfigService,\n    provideHttpClient(),\n    provideHttpClientTesting(),\n  ],\n});\n\nconst httpTesting = TestBed.inject(HttpTestingController);\n\n// Load `ConfigService` and request the current configuration.\nconst service = TestBed.inject(ConfigService);\nconst config$ = this.configService.getConfig<Config>();\n\n// `firstValueFrom` subscribes to the `Observable`, which makes the HTTP request,\n// and creates a `Promise` of the response.\nconst configPromise = firstValueFrom(config$);\n\n// At this point, the request is pending, and we can assert it was made\n// via the `HttpTestingController`:\nconst req = httpTesting.expectOne('/api/config', 'Request to load the configuration');\n\n// We can assert various properties of the request if desired.\nexpect(req.request.method).toBe('GET');\n\n// Flushing the request causes it to complete, delivering the result.\nreq.flush(DEFAULT_CONFIG);\n\n// We can then assert that the response was successfully delivered by the `ConfigService`:\nexpect(await configPromise).toEqual(DEFAULT_CONFIG);\n\n// Finally, we can assert that no other requests were made.\nhttpTesting.verify();\n</docs-code>\n\nNOTE: `expectOne` will fail if the test has made more than one request which matches the given criteria.\n\nAs an alternative to asserting on `req.method`, you could instead use an expanded form of `expectOne` to also match the request method:\n\n<docs-code language=\"ts\">\nconst req = httpTesting.expectOne({\n  method: 'GET',\n  url: '/api/config',\n}, 'Request to load the configuration');\n</docs-code>\n\nHELPFUL: The expectation APIs match against the full URL of requests, including any query parameters.\n\nThe last step, verifying that no requests remain outstanding, is common enough for you to move it into an `afterEach()` step:\n\n<docs-code language=\"ts\">\nafterEach(() => {\n  // Verify that none of the tests make any extra HTTP requests.\n  TestBed.inject(HttpTestingController).verify();\n});\n</docs-code>\n\n## Handling more than one request at once\n\nIf you need to respond to duplicate requests in your test, use the `match()` API instead of `expectOne()`. It takes the same arguments but returns an array of matching requests. Once returned, these requests are removed from future matching and you are responsible for flushing and verifying them.\n\n<docs-code language=\"ts\">\nconst allGetRequests = httpTesting.match({method: 'GET'});\nfor (const req of allGetRequests) {\n  // Handle responding to each request.\n}\n</docs-code>\n\n## Advanced matching\n\nAll matching functions accept a predicate function for custom matching logic:\n\n<docs-code language=\"ts\">\n// Look for one request that has a request body.\nconst requestsWithBody = httpTesting.expectOne(req => req.body !== null);\n</docs-code>\n\nThe `expectNone` function asserts that no requests match the given criteria.\n\n<docs-code language=\"ts\">\n// Assert that no mutation requests have been issued.\nhttpTesting.expectNone(req => req.method !== 'GET');\n</docs-code>\n\n## Testing error handling\n\nYou should test your app's responses when HTTP requests fail.\n\n### Backend errors\n\nTo test handling of backend errors (when the server returns a non-successful status code), flush requests with an error response that emulates what your backend would return when a request fails.\n\n<docs-code language=\"ts\">\nconst req = httpTesting.expectOne('/api/config');\nreq.flush('Failed!', {status: 500, statusText: 'Internal Server Error'});\n\n// Assert that the application successfully handled the backend error.\n</docs-code>\n\n### Network errors\n\nRequests can also fail due to network errors, which surface as `ProgressEvent` errors. These can be delivered with the `error()` method:\n\n<docs-code language=\"ts\">\nconst req = httpTesting.expectOne('/api/config');\nreq.error(new ProgressEvent('network error!'));\n\n// Assert that the application successfully handled the network error.\n</docs-code>\n\n## Testing an Interceptor\n\nYou should test that your interceptors work under the desired circumstances.\n\nFor example, an application may be required to add an authentication token generated by a service to each outgoing request.\nThis behavior can be enforced with the use of an interceptor:\n\n<docs-code language=\"ts\">\nexport function authInterceptor(request: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {\n  const authService = inject(AuthService);\n\n  const clonedRequest = request.clone({\n    headers: request.headers.append('X-Authentication-Token', authService.getAuthToken()),\n  });\n  return next(clonedRequest);\n}\n</docs-code>\n\nThe `TestBed` configuration for this interceptor should rely on the `withInterceptors` feature.\n\n<docs-code language=\"ts\">\nTestBed.configureTestingModule({\n  providers: [\n    AuthService,\n    // Testing one interceptor at a time is recommended.\n    provideHttpClient(withInterceptors([authInterceptor])),\n    provideHttpClientTesting(),\n  ],\n});\n</docs-code>\n\nThe `HttpTestingController` can retrieve the request instance which can then be inspected to ensure that the request was modified.\n\n<docs-code language=\"ts\">\nconst service = TestBed.inject(AuthService);\nconst req = httpTesting.expectOne('/api/config');\n\nexpect(req.request.headers.get('X-Authentication-Token')).toEqual(service.getAuthToken());\n</docs-code>\n\nA similar interceptor could be implemented with class based interceptors:\n\n<docs-code language=\"ts\">\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  private authService = inject(AuthService);\n\n  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n    const clonedRequest = request.clone({\n      headers: request.headers.append('X-Authentication-Token', this.authService.getAuthToken()),\n    });\n    return next.handle(clonedRequest);\n  }\n}\n</docs-code>\n\nIn order to test it, the `TestBed` configuration should instead be:\n\n<docs-code language=\"ts\">\nTestBed.configureTestingModule({\n  providers: [\n    AuthService,\n    provideHttpClient(withInterceptorsFromDi()),\n    provideHttpClientTesting(),\n    // We rely on the HTTP_INTERCEPTORS token to register the AuthInterceptor as an HttpInterceptor\n    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n  ],\n});\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 11507
  },
  {
    "id": 49,
    "file": "add-package",
    "fullFileName": "adev/src/content/guide/i18n/add-package.md",
    "startLine": 11511,
    "content": "# Add the localize package\n\nTo take advantage of the localization features of Angular, use the [Angular CLI][CliMain] to add the `@angular/localize` package to your project.\n\nTo add the `@angular/localize` package, use the following command to update the `package.json` and TypeScript configuration files in your project.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"add-localize\"/>\n\nIt adds `types: [\"@angular/localize\"]` in the TypeScript configuration files.\nIt also adds line `/// <reference types=\"@angular/localize\" />` at the top of the `main.ts` file which is the reference to the type definition.\n\nHELPFUL: For more information about `package.json` and `tsconfig.json` files, see [Workspace npm dependencies][GuideNpmPackages] and [TypeScript Configuration][GuideTsConfig]. To learn about Triple-slash Directives visit [Typescript Handbook](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-).\n\nIf `@angular/localize` is not installed and you try to build a localized version of your project (for example, while using the `i18n` attributes in templates), the [Angular CLI][CliMain] will generate an error, which would contain the steps that you can take to enable i18n for your project.\n\n## Options\n\n| OPTION           | DESCRIPTION | VALUE TYPE | DEFAULT VALUE\n|:---              |:---    |:------     |:------\n| `--project`      | The name of the project. | `string` |\n| `--use-at-runtime` | If set, then `$localize` can be used at runtime. Also `@angular/localize` gets included in the `dependencies` section of `package.json`, rather than `devDependencies`, which is the default.  | `boolean` | `false`\n\nFor more available options, see `ng add` in [Angular CLI][CliMain].\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/locale-id\" title=\"Refer to locales by ID\"/>\n</docs-pill-row>\n\n[CliMain]: cli \"CLI Overview and Command Reference | Angular\"\n\n[GuideNpmPackages]: reference/configs/npm-packages \"Workspace npm dependencies | Angular\"\n\n[GuideTsConfig]: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html \"TypeScript Configuration\"\n\n\n\n================================================\nFILE: adev/src/content/guide/i18n/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"i18n\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 11566
  },
  {
    "id": 50,
    "file": "deploy",
    "fullFileName": "adev/src/content/guide/i18n/deploy.md",
    "startLine": 11570,
    "content": "# Deploy multiple locales\n\nIf `myapp` is the directory that contains the distributable files of your project, you typically make different versions available for different locales in locale directories.\nFor example, your French version is located in the `myapp/fr` directory and the Spanish version is located in the `myapp/es` directory.\n\nThe HTML `base` tag with the `href` attribute specifies the base URI, or URL, for relative links.\nIf you set the `\"localize\"` option in [`angular.json`][GuideWorkspaceConfig] workspace build configuration file to `true` or to an array of locale IDs, the CLI adjusts the base `href` for each version of the application.\nTo adjust the base `href` for each version of the application, the CLI adds the locale to the configured `\"subPath\"`.\nSpecify the `\"subPath\"` for each locale in your [`angular.json`][GuideWorkspaceConfig] workspace build configuration file.\nThe following example displays `\"subPath\"` set to an empty string.\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"i18n-subPath\"/>\n\n## Configure a server\n\nTypical deployment of multiple languages serve each language from a different subdirectory.\nUsers are redirected to the preferred language defined in the browser using the `Accept-Language` HTTP header.\nIf the user has not defined a preferred language, or if the preferred language is not available, then the server falls back to the default language.\nTo change the language, change your current location to another subdirectory.\nThe change of subdirectory often occurs using a menu implemented in the application.\n\nFor more information on how to deploy apps to a remote server, see [Deployment][GuideDeployment].\n\nIMPORTANT: If you are using [Server rendering](guide/ssr) with `outputMode` set to `server`, Angular automatically handles redirection dynamically based on the `Accept-Language` HTTP header. This simplifies deployment by eliminating the need for manual server or configuration adjustments.\n\n### Nginx example\n\nThe following example displays an Nginx configuration.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/nginx.conf\" language=\"nginx\"/>\n\n### Apache example\n\nThe following example displays an Apache configuration.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/apache2.conf\" language=\"apache\"/>\n\n[CliBuild]: cli/build \"ng build | CLI | Angular\"\n\n[GuideDeployment]: tools/cli/deployment \"Deployment | Angular\"\n\n[GuideWorkspaceConfig]: reference/configs/workspace-config \"Angular workspace configuration | Angular\"\n\n\n\n================================================\n",
    "endLine": 11614
  },
  {
    "id": 51,
    "file": "example",
    "fullFileName": "adev/src/content/guide/i18n/example.md",
    "startLine": 11618,
    "content": "# Example Angular Internationalization application\n\n<!-- ## Explore the translated example application -->\n\n<!-- Explore the sample application with French translations used in the [Angular Internationalization][GuideI18nOverview] guide: -->\n<!-- TODO: link to GitHub -->\n<!-- <docs-code live path=\"adev/src/content/examples/i18n\" title=\"live example\"/> -->\n\n## `fr-CA` and `en-US` example\n\nThe following tabs display the example application and the associated translation files.\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\"/>\n    <docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/i18n/src/app/app.component.ts\"/>\n    <docs-code header=\"src/main.ts\" path=\"adev/src/content/examples/i18n/doc-files/main.1.ts\"/>\n    <docs-code header=\"src/locale/messages.fr.xlf\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\"/>\n</docs-code-multifile>\n\n\n\n================================================\n",
    "endLine": 11638
  },
  {
    "id": 52,
    "file": "format-data-locale",
    "fullFileName": "adev/src/content/guide/i18n/format-data-locale.md",
    "startLine": 11642,
    "content": "# Format data based on locale\n\nAngular provides the following built-in data transformation [pipes](guide/templates/pipes).\nThe data transformation pipes use the [`LOCALE_ID`][ApiCoreLocaleId] token to format data based on rules of each locale.\n\n| Data transformation pipe                   | Details |\n|:---                                        |:---     |\n| [`DatePipe`][ApiCommonDatepipe]         | Formats a date value.                             |\n| [`CurrencyPipe`][ApiCommonCurrencypipe] | Transforms a number into a currency string.       |\n| [`DecimalPipe`][ApiCommonDecimalpipe]   | Transforms a number into a decimal number string. |\n| [`PercentPipe`][ApiCommonPercentpipe]   | Transforms a number into a percentage string.     |\n\n## Use DatePipe to display the current date\n\nTo display the current date in the format for the current locale, use the following format for the `DatePipe`.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n\n{{ today | date }}\n\n</docs-code>\n\n## Override current locale for CurrencyPipe\n\nAdd the `locale` parameter to the pipe to override the current value of `LOCALE_ID` token.\n\nTo force the currency to use American English \\(`en-US`\\), use the following format for the `CurrencyPipe`\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n\n{{ amount | currency : 'en-US' }}\n\n</docs-code>\n\nHELPFUL: The locale specified for the `CurrencyPipe` overrides the global `LOCALE_ID` token of your application.\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/prepare\" title=\"Prepare component for translation\"/>\n</docs-pill-row>\n\n[ApiCommonCurrencypipe]: api/common/CurrencyPipe \"CurrencyPipe | Common - API | Angular\"\n\n[ApiCommonDatepipe]: api/common/DatePipe \"DatePipe | Common - API | Angular\"\n[ApiCommonDecimalpipe]: api/common/DecimalPipe \"DecimalPipe | Common - API | Angular\"\n[ApiCommonPercentpipe]: api/common/PercentPipe \"PercentPipe | Common - API | Angular\"\n[ApiCoreLocaleId]: api/core/LOCALE_ID \"LOCALE_ID | Core - API | Angular\"\n\n\n\n================================================\n",
    "endLine": 11696
  },
  {
    "id": 53,
    "file": "import-global-variants",
    "fullFileName": "adev/src/content/guide/i18n/import-global-variants.md",
    "startLine": 11700,
    "content": "# Import global variants of the locale data\n\nThe [Angular CLI][CliMain] automatically includes locale data if you run the [`ng build`][CliBuild] command with the `--localize` option.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"shell\">\n\nng build --localize\n\n</docs-code>\n\nHELPFUL: The initial installation of Angular already contains locale data for English in the United States \\(`en-US`\\).\nThe [Angular CLI][CliMain] automatically includes the locale data and sets the `LOCALE_ID` value when you use the `--localize` option with [`ng build`][CliBuild] command.\n\nThe `@angular/common` package on npm contains the locale data files.\nGlobal variants of the locale data are available in `@angular/common/locales/global`.\n\n## `import` example for French\n\nFor example, you could import the global variants for French \\(`fr`\\) in `main.ts` where you bootstrap the application.\n\n<docs-code header=\"src/main.ts (import locale)\" path=\"adev/src/content/examples/i18n/src/main.ts\" visibleRegion=\"global-locale\"/>\n\nHELPFUL: In an `NgModules` application, you would import it in your `app.module`.\n\n[CliMain]: cli \"CLI Overview and Command Reference | Angular\"\n[CliBuild]: cli/build \"ng build | CLI | Angular\"\n\n\n\n================================================\n",
    "endLine": 11730
  },
  {
    "id": 54,
    "file": "locale-id",
    "fullFileName": "adev/src/content/guide/i18n/locale-id.md",
    "startLine": 11734,
    "content": "# Refer to locales by ID\n\nAngular uses the Unicode *locale identifier* \\(Unicode locale ID\\) to find the correct locale data for internationalization of text strings.\n\n<docs-callout title=\"Unicode locale ID\">\n\n* A locale ID conforms to the [Unicode Common Locale Data Repository (CLDR) core specification][UnicodeCldrDevelopmentCoreSpecification].\n    For more information about locale IDs, see [Unicode Language and Locale Identifiers][UnicodeCldrDevelopmentCoreSpecificationLocaleIDs].\n\n* CLDR and Angular use [BCP 47 tags][RfcEditorInfoBcp47] as the base for the locale ID\n\n</docs-callout>\n\nA locale ID specifies the language, country, and an optional code for further variants or subdivisions.\nA locale ID consists of the language identifier, a hyphen \\(`-`\\) character, and the locale extension.\n\n<docs-code language=\"html\">\n{language_id}-{locale_extension}\n</docs-code>\n\nHELPFUL: To accurately translate your Angular project, you must decide which languages and locales you are targeting for internationalization.\n\nMany countries share the same language, but differ in usage.\nThe differences include grammar, punctuation, formats for currency, decimal numbers, dates, and so on.\n\nFor the examples in this guide, use the following languages and locales.\n\n| Language | Locale                   | Unicode locale ID |\n|:---      |:---                      |:---               |\n| English  | Canada                   | `en-CA`           |\n| English  | United States of America | `en-US`           |\n| French   | Canada                   | `fr-CA`           |\n| French   | France                   | `fr-FR`           |\n\nThe [Angular repository][GithubAngularAngularTreeMasterPackagesCommonLocales] includes common locales.\n\n<docs-callout>\nFor a list of language codes, see [ISO 639-2](https://www.loc.gov/standards/iso639-2).\n</docs-callout>\n\n## Set the source locale ID\n\nUse the Angular CLI to set the source language in which you are writing the component template and code.\n\nBy default, Angular uses `en-US` as the source locale of your project.\n\nTo change the source locale of your project for the build, complete the following actions.\n\n1. Open the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file.\n2. Add or modify the `sourceLocale` field inside the `i18n` section:\n```json\n{\n  \"projects\": {\n    \"your-project\": {\n      \"i18n\": {\n        \"sourceLocale\": \"ca\"  // Use your desired locale code\n      }\n    }\n  }\n}\n```\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/format-data-locale\" title=\"Format data based on locale\"/>\n</docs-pill-row>\n\n[GuideWorkspaceConfig]: reference/configs/workspace-config \"Angular workspace configuration | Angular\"\n\n[GithubAngularAngularTreeMasterPackagesCommonLocales]: <https://github.com/angular/angular/tree/main/packages/common/locales> \"angular/packages/common/locales | angular/angular | GitHub\"\n\n[RfcEditorInfoBcp47]: https://www.rfc-editor.org/info/bcp47 \"BCP 47 | RFC Editor\"\n\n[UnicodeCldrDevelopmentCoreSpecification]: https://cldr.unicode.org/index/cldr-spec \"Core Specification | Unicode CLDR Project\"\n\n[UnicodeCldrDevelopmentCoreSpecificationLocaleID]: https://cldr.unicode.org/index/cldr-spec/picking-the-right-language-code \"Unicode Language and Locale Identifiers - Core Specification | Unicode CLDR Project\"\n\n\n\n================================================\n",
    "endLine": 11813
  },
  {
    "id": 55,
    "file": "manage-marked-text",
    "fullFileName": "adev/src/content/guide/i18n/manage-marked-text.md",
    "startLine": 11817,
    "content": "# Manage marked text with custom IDs\n\nThe Angular extractor generates a file with a translation unit entry each of the following instances.\n\n* Each `i18n` attribute in a component template\n* Each [`$localize`][ApiLocalizeInitLocalize] tagged message string in component code\n\nAs described in [How meanings control text extraction and merges][GuideI18nCommonPrepareHowMeaningsControlTextExtractionAndMerges], Angular assigns each translation unit a unique ID.\n\nThe following example displays translation units with unique IDs.\n\n<docs-code header=\"messages.fr.xlf.html\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"generated-id\"/>\n\nWhen you change the translatable text, the extractor generates a new ID for that translation unit.\nIn most cases, changes in the source text also require a change to the translation.\nTherefore, using a new ID keeps the text change in sync with translations.\n\nHowever, some translation systems require a specific form or syntax for the ID.\nTo address the requirement, use a custom ID to mark text.\nMost developers don't need to use a custom ID.\nIf you want to use a unique syntax to convey additional metadata, use a custom ID.\nAdditional metadata may include the library, component, or area of the application in which the text appears.\n\nTo specify a custom ID in the `i18n` attribute or [`$localize`][ApiLocalizeInitLocalize] tagged message string, use the `@@` prefix.\nThe following example defines the `introductionHeader` custom ID in a heading element.\n\n<docs-code header=\"app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute-solo-id\"/>\n\nThe following example defines the `introductionHeader` custom ID for a variable.\n\n<!--todo: replace with code example -->\n\n<docs-code language=\"typescript\">\n\nvariableText1 = $localize`:@@introductionHeader:Hello i18n!`;\n\n</docs-code>\n\nWhen you specify a custom ID, the extractor generates a translation unit with the custom ID.\n\n<docs-code header=\"messages.fr.xlf.html\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"custom-id\"/>\n\nIf you change the text, the extractor does not change the ID.\nAs a result, you don't have to take the extra step to update the translation.\nThe drawback of using custom IDs is that if you change the text, your translation may be out-of-sync with the newly changed source text.\n\n## Use a custom ID with a description\n\nUse a custom ID in combination with a description and a meaning to further help the translator.\n\nThe following example includes a description, followed by the custom ID.\n\n<docs-code header=\"app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute-id\"/>\n\nThe following example defines the `introductionHeader` custom ID and description for a variable.\n\n<!--todo: replace with code example -->\n\n<docs-code language=\"typescript\">\n\nvariableText2 = $localize`:An introduction header for this sample@@introductionHeader:Hello i18n!`;\n\n</docs-code>\n\nThe following example adds a meaning.\n\n<docs-code header=\"app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute-meaning-and-id\"/>\n\nThe following example defines the `introductionHeader` custom ID for a variable.\n\n<!--todo: replace with code example -->\n\n<docs-code language=\"typescript\">\n\nvariableText3 = $localize`:site header|An introduction header for this sample@@introductionHeader:Hello i18n!`;\n\n</docs-code>\n\n### Define unique custom IDs\n\nBe sure to define custom IDs that are unique.\nIf you use the same ID for two different text elements, the extraction tool extracts only the first one, and Angular uses the translation in place of both original text elements.\n\nFor example, in the following code snippet the same `myId` custom ID is defined for two different text elements.\n\n<docs-code header=\"app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-duplicate-custom-id\"/>\n\nThe following displays the translation in French.\n\n<docs-code header=\"src/locale/messages.fr.xlf\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"i18n-duplicate-custom-id\"/>\n\nBoth elements now use the same translation \\(`Bonjour`\\), because both were defined with the same custom ID.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/rendered-output.html\"/>\n\n[ApiLocalizeInitLocalize]: api/localize/init/$localize \"$localize | init - localize - API | Angular\"\n\n[GuideI18nCommonPrepareHowMeaningsControlTextExtractionAndMerges]: guide/i18n/prepare#h1-example \"How meanings control text extraction and merges - Prepare components for translations | Angular\"\n\n\n\n================================================\n",
    "endLine": 11917
  },
  {
    "id": 56,
    "file": "merge",
    "fullFileName": "adev/src/content/guide/i18n/merge.md",
    "startLine": 11921,
    "content": "# Merge translations into the application\n\nTo merge the completed translations into your project, complete the following actions\n\n1. Use the [Angular CLI][CliMain] to build a copy of the distributable files of your project\n1. Use the `\"localize\"` option to replace all of the i18n messages with the valid translations and build a localized variant application.\n    A variant application is a complete a copy of the distributable files of your application translated for a single locale.\n\nAfter you merge the translations, serve each distributable copy of the application using server-side language detection or different subdirectories.\n\nHELPFUL: For more information about how to serve each distributable copy of the application, see [deploying multiple locales](guide/i18n/deploy).\n\nFor a compile-time translation of the application, the build process uses ahead-of-time (AOT) compilation to produce a small, fast, ready-to-run application.\n\nHELPFUL: For a detailed explanation of the build process, see [Building and serving Angular apps][GuideBuild].\nThe build process works for translation files in the `.xlf` format or in another format that Angular understands, such as `.xtb`.\nFor more information about translation file formats used by Angular, see [Change the source language file format][GuideI18nCommonTranslationFilesChangeTheSourceLanguageFileFormat]\n\nTo build a separate distributable copy of the application for each locale, [define the locales in the build configuration][GuideI18nCommonMergeDefineLocalesInTheBuildConfiguration] in the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file of your project.\n\nThis method shortens the build process by removing the requirement to perform a full application build for each locale.\n\nTo [generate application variants for each locale][GuideI18nCommonMergeGenerateApplicationVariantsForEachLocale], use the `\"localize\"` option in the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file.\nAlso, to [build from the command line][GuideI18nCommonMergeBuildFromTheCommandLine], use the [`build`][CliBuild] [Angular CLI][CliMain] command with the `--localize` option.\n\nHELPFUL: Optionally, [apply specific build options for just one locale][GuideI18nCommonMergeApplySpecificBuildOptionsForJustOneLocale] for a custom locale configuration.\n\n## Define locales in the build configuration\n\nUse the `i18n` project option in the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file of your project to define locales for a project.\n\nThe following sub-options identify the source language and tell the compiler where to find supported translations for the project.\n\n| Suboption      | Details |\n|:---            |:--- |\n| `sourceLocale` | The locale you use within the application source code \\(`en-US` by default\\) |\n| `locales`      | A map of locale identifiers to translation files                             |\n\n### `angular.json` for `en-US` and `fr` example\n\nFor example, the following excerpt of an [`angular.json`][GuideWorkspaceConfig] workspace build configuration file sets the source locale to `en-US` and provides the path to the French \\(`fr`\\) locale translation file.\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"locale-config\"/>\n\n## Generate application variants for each locale\n\nTo use your locale definition in the build configuration, use the `\"localize\"` option in the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file to tell the CLI which locales to generate for the build configuration.\n\n* Set `\"localize\"` to `true` for all the locales previously defined in the build configuration.\n* Set `\"localize\"` to an array of a subset of the previously defined locale identifiers to build only those locale versions.\n* Set `\"localize\"` to `false` to disable localization and not generate any locale-specific versions.\n\nHELPFUL: Ahead-of-time (AOT) compilation is required to localize component templates.\n\nIf you changed this setting, set `\"aot\"` to `true` in order to use AOT.\n\nHELPFUL: Due to the deployment complexities of i18n and the need to minimize rebuild time, the development server only supports localizing a single locale at a time.\nIf you set the `\"localize\"` option to `true`, define more than one locale, and use `ng serve`; then an error occurs.\nIf you want to develop against a specific locale, set the `\"localize\"` option to a specific locale.\nFor example, for French \\(`fr`\\), specify `\"localize\": [\"fr\"]`.\n\nThe CLI loads and registers the locale data, places each generated version in a locale-specific directory to keep it separate from other locale versions, and puts the directories within the configured `outputPath` for the project.\nFor each application variant the `lang` attribute of the `html` element is set to the locale.\nThe CLI also adjusts the HTML base HREF for each version of the application by adding the locale to the configured `baseHref`.\n\nSet the `\"localize\"` property as a shared configuration to effectively inherit for all the configurations.\nAlso, set the property to override other configurations.\n\n### `angular.json` include all locales from build example\n\nThe following example displays the `\"localize\"` option set to `true` in the [`angular.json`][GuideWorkspaceConfig] workspace build configuration file, so that all locales defined in the build configuration are built.\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"build-localize-true\"/>\n\n## Build from the command line\n\nAlso, use the `--localize` option with the [`ng build`][CliBuild] command and your existing `production` configuration.\nThe CLI builds all locales defined in the build configuration.\nIf you set the locales in build configuration, it is similar to when you set the `\"localize\"` option to `true`.\n\nHELPFUL: For more information about how to set the locales, see [Generate application variants for each locale][GuideI18nCommonMergeGenerateApplicationVariantsForEachLocale].\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"build-localize\"/>\n\n## Apply specific build options for just one locale\n\nTo apply specific build options to only one locale, specify a single locale to create a custom locale-specific configuration.\n\nIMPORTANT: Use the [Angular CLI][CliMain] development server \\(`ng serve`\\) with only a single locale.\n\n### build for French example\n\nThe following example displays a custom locale-specific configuration using a single locale.\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"build-single-locale\"/>\n\nPass this configuration to the `ng serve` or `ng build` commands.\nThe following code example displays how to serve the French language file.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"serve-french\"/>\n\nFor production builds, use configuration composition to run both configurations.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"build-production-french\"/>\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"build-production-french\" />\n\n## Report missing translations\n\nWhen a translation is missing, the build succeeds but generates a warning such as `Missing translation for message \"{translation_text}\"`.\nTo configure the level of warning that is generated by the Angular compiler, specify one of the following levels.\n\n| Warning level | Details                                              | Output |\n|:---           |:---                                                  |:---    |\n| `error`       | Throw an error and the build fails                   | n/a                                                    |\n| `ignore`      | Do nothing                                           | n/a                                                    |\n| `warning`     | Displays the default warning in the console or shell | `Missing translation for message \"{translation_text}\"` |\n\nSpecify the warning level in the `options` section for the `build` target of your [`angular.json`][GuideWorkspaceConfig] workspace build configuration file.\n\n### `angular.json` `error` warning example\n\nThe following example displays how to set the warning level to `error`.\n\n<docs-code header=\"angular.json\" path=\"adev/src/content/examples/i18n/angular.json\" visibleRegion=\"missing-translation-error\" />\n\nHELPFUL: When you compile your Angular project into an Angular application, the instances of the `i18n` attribute are replaced with instances of the [`$localize`][ApiLocalizeInitLocalize] tagged message string.\nThis means that your Angular application is translated after compilation.\nThis also means that you can create localized versions of your Angular application without re-compiling your entire Angular project for each locale.\n\nWhen you translate your Angular application, the *translation transformation* replaces and reorders the parts \\(static strings and expressions\\) of the template literal string with strings from a collection of translations.\nFor more information, see [`$localize`][ApiLocalizeInitLocalize].\n\nTLDR: Compile once, then translate for each locale.\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/deploy\" title=\"Deploy multiple locales\"/>\n</docs-pill-row>\n\n[ApiLocalizeInitLocalize]: api/localize/init/$localize \"$localize | init - localize - API | Angular\"\n\n[CliMain]: cli \"CLI Overview and Command Reference | Angular\"\n[CliBuild]: cli/build \"ng build | CLI | Angular\"\n\n[GuideBuild]: tools/cli/build \"Building and serving Angular apps | Angular\"\n\n[GuideI18nCommonMergeApplySpecificBuildOptionsForJustOneLocale]: guide/i18n/merge#apply-specific-build-options-for-just-one-locale \"Apply specific build options for just one locale - Merge translations into the application | Angular\"\n[GuideI18nCommonMergeBuildFromTheCommandLine]: guide/i18n/merge#build-from-the-command-line \"Build from the command line - Merge translations into the application | Angular\"\n[GuideI18nCommonMergeDefineLocalesInTheBuildConfiguration]: guide/i18n/merge#define-locales-in-the-build-configuration \"Define locales in the build configuration - Merge translations into the application | Angular\"\n[GuideI18nCommonMergeGenerateApplicationVariantsForEachLocale]: guide/i18n/merge#generate-application-variants-for-each-locale \"Generate application variants for each locale - Merge translations into the application | Angular\"\n\n[GuideI18nCommonTranslationFilesChangeTheSourceLanguageFileFormat]: guide/i18n/translation-files#change-the-source-language-file-format \"Change the source language file format - Work with translation files | Angular\"\n\n[GuideWorkspaceConfig]: reference/configs/workspace-config \"Angular workspace configuration | Angular\"\n\n\n\n================================================\n",
    "endLine": 12079
  },
  {
    "id": 57,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/i18n/overview.md",
    "startLine": 12083,
    "content": "# Angular Internationalization\n\n*Internationalization*, sometimes referenced as i18n, is the process of designing and preparing your project for use in different locales around the world.\n*Localization* is the process of building versions of your project for different locales.\nThe localization process includes the following actions.\n\n* Extract text for translation into different languages\n* Format data for a specific locale\n\nA *locale* identifies a region in which people speak a particular language or language variant.\nPossible regions include countries and geographical regions.\nA locale determines the formatting and parsing of the following details.\n\n* Measurement units including date and time, numbers, and currencies\n* Translated names including time zones, languages, and countries\n\nFor a quick introduction to localization and internationalization watch this video:\n\n<docs-video src=\"https://www.youtube.com/embed/KNTN-nsbV7M\"/>\n\n## Learn about Angular internationalization\n\n<docs-card-container>\n  <docs-card title=\"Add the localize package\" href=\"guide/i18n/add-package\">\n    Learn how to add the Angular Localize package to your project\n  </docs-card>\n  <docs-card title=\"Refer to locales by ID\" href=\"guide/i18n/locale-id\">\n    Learn how to identify and specify a locale identifier for your project\n  </docs-card>\n  <docs-card title=\"Format data based on locale\" href=\"guide/i18n/format-data-locale\">\n    Learn how to implement localized data pipes and override the locale for your project\n  </docs-card>\n  <docs-card title=\"Prepare component for translation\" href=\"guide/i18n/prepare\">\n    Learn how to specify source text for translation\n  </docs-card>\n  <docs-card title=\"Work with translation files\" href=\"guide/i18n/translation-files\">\n    Learn how to review and process translation text\n  </docs-card>\n  <docs-card title=\"Merge translations into the application\" href=\"guide/i18n/merge\">\n    Learn how to merge translations and build your translated application\n  </docs-card>\n  <docs-card title=\"Deploy multiple locales\" href=\"guide/i18n/deploy\">\n    Learn how to deploy multiple locales for your application\n  </docs-card>\n  <docs-card title=\"Import global variants of the locale data\" href=\"guide/i18n/import-global-variants\">\n    Learn how to import locale data for language variants\n  </docs-card>\n  <docs-card title=\"Manage marked text with custom IDs\" href=\"guide/i18n/manage-marked-text\">\n    Learn how to implement custom IDs to help you manage your marked text\n  </docs-card>\n  <docs-card title=\"Internationalization example\" href=\"guide/i18n/example\">\n    Review an example of Angular internationalization.\n  </docs-card>\n</docs-card-container>\n\n\n\n================================================\n",
    "endLine": 12139
  },
  {
    "id": 58,
    "file": "prepare",
    "fullFileName": "adev/src/content/guide/i18n/prepare.md",
    "startLine": 12143,
    "content": "# Prepare component for translation\n\nTo prepare your project for translation, complete the following actions.\n\n- Use the `i18n` attribute to mark text in component templates\n- Use the `i18n-` attribute to mark attribute text strings in component templates\n- Use the `$localize` tagged message string to mark text strings in component code\n\n## Mark text in component template\n\nIn a component template, the i18n metadata is the value of the `i18n` attribute.\n\n<docs-code language=\"html\">\n<element i18n=\"{i18n_metadata}\">{string_to_translate}</element>\n</docs-code>\n\nUse the `i18n` attribute to mark a static text message in your component templates for translation.\nPlace it on every element tag that contains fixed text you want to translate.\n\nHELPFUL: The `i18n` attribute is a custom attribute that the Angular tools and compilers recognize.\n\n### `i18n` example\n\nThe following `<h1>` tag displays a simple English language greeting, \"Hello i18n!\".\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"greeting\"/>\n\nTo mark the greeting for translation, add the `i18n` attribute to the `<h1>` tag.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute\"/>\n\n\n### using conditional statement with `i18n`\n\nThe following `<div>` tag will display translated text as part of `div` and `aria-label` based on toggle status \n\n<docs-code-multifile>\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\"  visibleRegion=\"i18n-conditional\"/>\n    <docs-code header=\"src/app/app.component.ts\" path=\"adev/src/content/examples/i18n/src/app/app.component.ts\" visibleLines=\"[[14,21],[33,37]]\"/>\n</docs-code-multifile>\n\n### Translate inline text without HTML element\n\nUse the `<ng-container>` element to associate a translation behavior for specific text without changing the way text is displayed.\n\nHELPFUL: Each HTML element creates a new DOM element.\nTo avoid creating a new DOM element, wrap the text in an `<ng-container>` element.\nThe following example shows the `<ng-container>` element transformed into a non-displayed HTML comment.\n\n<docs-code path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-ng-container\"/>\n\n## Mark element attributes for translations\n\nIn a component template, the i18n metadata is the value of the `i18n-{attribute_name}` attribute.\n\n<docs-code language=\"html\">\n<element i18n-{attribute_name}=\"{i18n_metadata}\" {attribute_name}=\"{attribute_value}\" />\n</docs-code>\n\nThe attributes of HTML elements include text that should be translated along with the rest of the displayed text in the component template.\n\nUse `i18n-{attribute_name}` with any attribute of any element and replace `{attribute_name}` with the name of the attribute.\nUse the following syntax to assign a meaning, description, and custom ID.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\ni18n-{attribute_name}=\"{meaning}|{description}@@{id}\"\n</docs-code>\n\n### `i18n-title` example\n\nTo translate the title of an image, review this example.\nThe following example displays an image with a `title` attribute.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-title\"/>\n\nTo mark the title attribute for translation, complete the following action.\n\n1. Add the `i18n-title` attribute\n\n   The following example displays how to mark the `title` attribute on the `img` tag by adding `i18n-title`.\n\n   <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-title-translate\"/>\n\n## Mark text in component code\n\nIn component code, the translation source text and the metadata are surrounded by backtick \\(<code>&#96;</code>\\) characters.\n\nUse the [`$localize`][ApiLocalizeInitLocalize] tagged message string to mark a string in your code for translation.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n$localize`string_to_translate`;\n</docs-code>\n\nThe i18n metadata is surrounded by colon \\(`:`\\) characters and prepends the translation source text.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n$localize`:{i18n_metadata}:string_to_translate`\n</docs-code>\n\n### Include interpolated text\n\nInclude [interpolations](guide/templates/binding#render-dynamic-text-with-text-interpolation) in a [`$localize`][ApiLocalizeInitLocalize] tagged message string.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n$localize`string_to_translate ${variable_name}`;\n</docs-code>\n\n### Name the interpolation placeholder\n\n<docs-code language=\"typescript\">\n$localize`string_to_translate ${variable_name}:placeholder_name:`;\n</docs-code>\n\n### Conditional syntax for translations\n\n<docs-code language=\"typescript\">\nreturn this.show ? $localize`Show Tabs` : $localize`Hide tabs`;\n</docs-code>\n\n\n\n## i18n metadata for translation\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n{meaning}|{description}@@{custom_id}\n</docs-code>\n\nThe following parameters provide context and additional information to reduce confusion for your translator.\n\n| Metadata parameter | Details                                                               |\n| :----------------- | :-------------------------------------------------------------------- |\n| Custom ID          | Provide a custom identifier                                           |\n| Description        | Provide additional information or context                             |\n| Meaning            | Provide the meaning or intent of the text within the specific context |\n\nFor additional information about custom IDs, see [Manage marked text with custom IDs][GuideI18nOptionalManageMarkedText].\n\n### Add helpful descriptions and meanings\n\nTo translate a text message accurately, provide additional information or context for the translator.\n\nAdd a _description_ of the text message as the value of the `i18n` attribute or [`$localize`][ApiLocalizeInitLocalize] tagged message string.\n\nThe following example shows the value of the `i18n` attribute.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute-desc\"/>\n\nThe following example shows the value of the [`$localize`][ApiLocalizeInitLocalize] tagged message string with a description.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n\n$localize`:An introduction header for this sample:Hello i18n!`;\n\n</docs-code>\n\nThe translator may also need to know the meaning or intent of the text message within this particular application context, in order to translate it the same way as other text with the same meaning.\nStart the `i18n` attribute value with the _meaning_ and separate it from the _description_ with the `|` character: `{meaning}|{description}`.\n\n#### `h1` example\n\nFor example, you may want to specify that the `<h1>` tag is a site header that you need translated the same way, whether it is used as a header or referenced in another section of text.\n\nThe following example shows how to specify that the `<h1>` tag must be translated as a header or referenced elsewhere.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/doc-files/app.component.html\" visibleRegion=\"i18n-attribute-meaning\"/>\n\nThe result is any text marked with `site header`, as the _meaning_ is translated exactly the same way.\n\nThe following code example shows the value of the [`$localize`][ApiLocalizeInitLocalize] tagged message string with a meaning and a description.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"typescript\">\n\n$localize`:site header|An introduction header for this sample:Hello i18n!`;\n\n</docs-code>\n\n<docs-callout title=\"How meanings control text extraction and merges\">\n\nThe Angular extraction tool generates a translation unit entry for each `i18n` attribute in a template.\nThe Angular extraction tool assigns each translation unit a unique ID based on the _meaning_ and _description_.\n\nHELPFUL: For more information about the Angular extraction tool, see [Work with translation files](guide/i18n/translation-files).\n\nThe same text elements with different _meanings_ are extracted with different IDs.\nFor example, if the word \"right\" uses the following two definitions in two different locations, the word is translated differently and merged back into the application as different translation entries.\n\n- `correct` as in \"you are right\"\n- `direction` as in \"turn right\"\n\nIf the same text elements meet the following conditions, the text elements are extracted only once and use the same ID.\n\n- Same meaning or definition\n- Different descriptions\n\nThat one translation entry is merged back into the application wherever the same text elements appear.\n\n</docs-callout>\n\n## ICU expressions\n\nICU expressions help you mark alternate text in component templates to meet conditions.\nAn ICU expression includes a component property, an ICU clause, and the case statements surrounded by open curly brace \\(`{`\\) and close curly brace \\(`}`\\) characters.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\n{ component_property, icu_clause, case_statements }\n\n</docs-code>\n\nThe component property defines the variable\nAn ICU clause defines the type of conditional text.\n\n| ICU clause                                                           | Details                                                             |\n| :------------------------------------------------------------------- | :------------------------------------------------------------------ |\n| [`plural`][GuideI18nCommonPrepareMarkPlurals]                        | Mark the use of plural numbers                                      |\n| [`select`][GuideI18nCommonPrepareMarkAlternatesAndNestedExpressions] | Mark choices for alternate text based on your defined string values |\n\nTo simplify translation, use International Components for Unicode clauses \\(ICU clauses\\) with regular expressions.\n\nHELPFUL: The ICU clauses adhere to the [ICU Message Format][GithubUnicodeOrgIcuUserguideFormatParseMessages] specified in the [CLDR pluralization rules][UnicodeCldrIndexCldrSpecPluralRules].\n\n### Mark plurals\n\nDifferent languages have different pluralization rules that increase the difficulty of translation.\nBecause other locales express cardinality differently, you may need to set pluralization categories that do not align with English.\nUse the `plural` clause to mark expressions that may not be meaningful if translated word-for-word.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\n{ component_property, plural, pluralization_categories }\n\n</docs-code>\n\nAfter the pluralization category, enter the default text \\(English\\) surrounded by open curly brace \\(`{`\\) and close curly brace \\(`}`\\) characters.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\npluralization_category { }\n\n</docs-code>\n\nThe following pluralization categories are available for English and may change based on the locale.\n\n| Pluralization category | Details                    | Example                    |\n| :--------------------- | :------------------------- | :------------------------- |\n| `zero`                 | Quantity is zero           | `=0 { }` <br /> `zero { }` |\n| `one`                  | Quantity is 1              | `=1 { }` <br /> `one { }`  |\n| `two`                  | Quantity is 2              | `=2 { }` <br /> `two { }`  |\n| `few`                  | Quantity is 2 or more      | `few { }`                  |\n| `many`                 | Quantity is a large number | `many { }`                 |\n| `other`                | The default quantity       | `other { }`                |\n\nIf none of the pluralization categories match, Angular uses `other` to match the standard fallback for a missing category.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\nother { default_quantity }\n\n</docs-code>\n\nHELPFUL: For more information about pluralization categories, see [Choosing plural category names][UnicodeCldrIndexCldrSpecPluralRulesTocChoosingPluralCategoryNames] in the [CLDR - Unicode Common Locale Data Repository][UnicodeCldrMain].\n\n<docs-callout header='Background: Locales may not support some pluralization categories'>\n\nMany locales don't support some of the pluralization categories.\nThe default locale \\(`en-US`\\) uses a very simple `plural()` function that doesn't support the `few` pluralization category.\nAnother locale with a simple `plural()` function is `es`.\nThe following code example shows the [en-US `plural()`][GithubAngularAngularBlobEcffc3557fe1bff9718c01277498e877ca44588dPackagesCoreSrcI18nLocaleEnTsL14L18] function.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/locale_plural_function.ts\" class=\"no-box\" hideCopy/>\n\nThe `plural()` function only returns 1 \\(`one`\\) or 5 \\(`other`\\).\nThe `few` category never matches.\n\n</docs-callout>\n\n#### `minutes` example\n\nIf you want to display the following phrase in English, where `x` is a number.\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nupdated x minutes ago\n\n</docs-code>\n\nAnd you also want to display the following phrases based on the cardinality of `x`.\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nupdated just now\n\n</docs-code>\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nupdated one minute ago\n\n</docs-code>\n\nUse HTML markup and [interpolations](guide/templates/binding#render-dynamic-text-with-text-interpolation).\nThe following code example shows how to use the `plural` clause to express the previous three situations in a `<span>` element.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-plural\"/>\n\nReview the following details in the previous code example.\n\n| Parameters                        | Details                                                                                                               |\n| :-------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| `minutes`                         | The first parameter specifies the component property is `minutes` and determines the number of minutes.               |\n| `plural`                          | The second parameter specifies the ICU clause is `plural`.                                                            |\n| `=0 {just now}`                   | For zero minutes, the pluralization category is `=0`. The value is `just now`.                                        |\n| `=1 {one minute}`                 | For one minute, the pluralization category is `=1`. The value is `one minute`.                                        |\n| `other {{{minutes}} minutes ago}` | For any unmatched cardinality, the default pluralization category is `other`. The value is `{{minutes}} minutes ago`. |\n\n`{{minutes}}` is an [interpolation](guide/templates/binding#render-dynamic-text-with-text-interpolation).\n\n### Mark alternates and nested expressions\n\nThe `select` clause marks choices for alternate text based on your defined string values.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\n{ component_property, select, selection_categories }\n\n</docs-code>\n\nTranslate all of the alternates to display alternate text based on the value of a variable.\n\nAfter the selection category, enter the text \\(English\\) surrounded by open curly brace \\(`{`\\) and close curly brace \\(`}`\\) characters.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\nselection_category { text }\n\n</docs-code>\n\nDifferent locales have different grammatical constructions that increase the difficulty of translation.\nUse HTML markup.\nIf none of the selection categories match, Angular uses `other` to match the standard fallback for a missing category.\n\n<!--todo: replace with docs-code -->\n\n<docs-code language=\"html\">\n\nother { default_value }\n\n</docs-code>\n\n#### `gender` example\n\nIf you want to display the following phrase in English.\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nThe author is other\n\n</docs-code>\n\nAnd you also want to display the following phrases based on the `gender` property of the component.\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nThe author is female\n\n</docs-code>\n\n<!--todo: replace output docs-code with screen capture image --->\n\n<docs-code language=\"html\">\n\nThe author is male\n\n</docs-code>\n\nThe following code example shows how to bind the `gender` property of the component and use the `select` clause to express the previous three situations in a `<span>` element.\n\nThe `gender` property binds the outputs to each of following string values.\n\n| Value  | English value |\n| :----- | :------------ |\n| female | `female`      |\n| male   | `male`        |\n| other  | `other`       |\n\nThe `select` clause maps the values to the appropriate translations.\nThe following code example shows `gender` property used with the select clause.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-select\"/>\n\n#### `gender` and `minutes` example\n\nCombine different clauses together, such as the `plural` and `select` clauses.\nThe following code example shows nested clauses based on the `gender` and `minutes` examples.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-nested\"/>\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/translation-files\" title=\"Work with translation files\"/>\n</docs-pill-row>\n\n[ApiLocalizeInitLocalize]: api/localize/init/$localize '$localize | init - localize - API  | Angular'\n[GuideI18nCommonPrepareMarkAlternatesAndNestedExpressions]: guide/i18n/prepare#mark-alternates-and-nested-expressions 'Mark alternates and nested expressions - Prepare templates for translation | Angular'\n[GuideI18nCommonPrepareMarkPlurals]: guide/i18n/prepare#mark-plurals 'Mark plurals - Prepare component for translation | Angular'\n[GuideI18nOptionalManageMarkedText]: guide/i18n/manage-marked-text 'Manage marked text with custom IDs | Angular'\n[GithubAngularAngularBlobEcffc3557fe1bff9718c01277498e877ca44588dPackagesCoreSrcI18nLocaleEnTsL14L18]: https://github.com/angular/angular/blob/ecffc3557fe1bff9718c01277498e877ca44588d/packages/core/src/i18n/locale_en.ts#L14-L18 'Line 14 to 18 - angular/packages/core/src/i18n/locale_en.ts | angular/angular | GitHub'\n[GithubUnicodeOrgIcuUserguideFormatParseMessages]: https://unicode-org.github.io/icu/userguide/format_parse/messages 'ICU Message Format - ICU Documentation | Unicode | GitHub'\n[UnicodeCldrMain]: https://cldr.unicode.org 'Unicode CLDR Project'\n[UnicodeCldrIndexCldrSpecPluralRules]: http://cldr.unicode.org/index/cldr-spec/plural-rules 'Plural Rules | CLDR - Unicode Common Locale Data Repository | Unicode'\n[UnicodeCldrIndexCldrSpecPluralRulesTocChoosingPluralCategoryNames]: http://cldr.unicode.org/index/cldr-spec/plural-rules#TOC-Choosing-Plural-Category-Names 'Choosing Plural Category Names - Plural Rules | CLDR - Unicode Common Locale Data Repository | Unicode'\n\n\n\n================================================\n",
    "endLine": 12593
  },
  {
    "id": 59,
    "file": "translation-files",
    "fullFileName": "adev/src/content/guide/i18n/translation-files.md",
    "startLine": 12597,
    "content": "# Work with translation files\n\nAfter you prepare a component for translation, use the [`extract-i18n`][CliExtractI18n] [Angular CLI][CliMain] command to extract the marked text in the component into a *source language* file.\n\nThe marked text includes text marked with `i18n`, attributes marked with `i18n-`*attribute*, and text tagged with `$localize` as described in [Prepare component for translation][GuideI18nCommonPrepare].\n\nComplete the following steps to create and update translation files for your project.\n\n1. [Extract the source language file][GuideI18nCommonTranslationFilesExtractTheSourceLanguageFile].\n    1. Optionally, change the location, format, and name.\n1. Copy the source language file to [create a translation file for each language][GuideI18nCommonTranslationFilesCreateATranslationFileForEachLanguage].\n1. [Translate each translation file][GuideI18nCommonTranslationFilesTranslateEachTranslationFile].\n1. Translate plurals and alternate expressions separately.\n    1. [Translate plurals][GuideI18nCommonTranslationFilesTranslatePlurals].\n    1. [Translate alternate expressions][GuideI18nCommonTranslationFilesTranslateAlternateExpressions].\n    1. [Translate nested expressions][GuideI18nCommonTranslationFilesTranslateNestedExpressions].\n\n## Extract the source language file\n\nTo extract the source language file, complete the following actions.\n\n1. Open a terminal window.\n1. Change to the root directory of your project.\n1. Run the following CLI command.\n\n    <docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"extract-i18n-default\"/>\n\nThe `extract-i18n` command creates a source language file named `messages.xlf` in the root directory of your project.\nFor more information about the XML Localization Interchange File Format \\(XLIFF, version 1.2\\), see [XLIFF][WikipediaWikiXliff].\n\nUse the following [`extract-i18n`][CliExtractI18n] command options to change the source language file location, format, and file name.\n\n| Command option  | Details |\n|:---             |:---     |\n| `--format`      | Set the format of the output file    |\n| `--out-file`     | Set the name of the output file      |\n| `--output-path` | Set the path of the output directory |\n\n### Change the source language file location\n\nTo create a file in the `src/locale` directory, specify the output path as an option.\n\n#### `extract-i18n --output-path` example\n\nThe following example specifies the output path as an option.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"extract-i18n-output-path\"/>\n\n### Change the source language file format\n\nThe `extract-i18n` command creates files in the following translation formats.\n\n| Translation format | Details                                                                                                          | File extension |\n|:---                |:---                                                                                                              |:---            |\n| ARB                | [Application Resource Bundle][GithubGoogleAppResourceBundleWikiApplicationresourcebundlespecification]           | `.arb`            |\n| JSON               | [JavaScript Object Notation][JsonMain]                                                                           | `.json`           |\n| XLIFF 1.2          | [XML Localization Interchange File Format, version 1.2][OasisOpenDocsXliffXliffCoreXliffCoreHtml]                | `.xlf`            |\n| XLIFF 2            | [XML Localization Interchange File Format, version 2][OasisOpenDocsXliffXliffCoreV20Cos01XliffCoreV20Cose01Html] | `.xlf`            |\n| XMB                | [XML Message Bundle][UnicodeCldrDevelopmentDevelopmentProcessDesignProposalsXmb]                                 | `.xmb` \\(`.xtb`\\) |\n\nSpecify the translation format explicitly with the `--format` command option.\n\nHELPFUL: The XMB format generates `.xmb` source language files, but uses`.xtb` translation files.\n\n#### `extract-i18n --format` example\n\nThe following example demonstrates several translation formats.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"extract-i18n-formats\"/>\n\n### Change the source language file name\n\nTo change the name of the source language file generated by the extraction tool, use the `--out-file` command option.\n\n#### `extract-i18n --out-file` example\n\nThe following example demonstrates naming the output file.\n\n<docs-code path=\"adev/src/content/examples/i18n/doc-files/commands.sh\" visibleRegion=\"extract-i18n-out-file\"/>\n\n## Create a translation file for each language\n\nTo create a translation file for a locale or language, complete the following actions.\n\n1. [Extract the source language file][GuideI18nCommonTranslationFilesExtractTheSourceLanguageFile].\n1. Make a copy of the source language file to create a *translation* file for each language.\n1. Rename the *translation* file to add the locale.\n\n    <docs-code language=\"file\">\n\n    messages.xlf --> messages.{locale}.xlf\n\n    </docs-code>\n\n1. Create a new directory at your project root named `locale`.\n\n    <docs-code language=\"file\">\n\n    src/locale\n\n    </docs-code>\n\n1. Move the *translation* file to the new directory.\n1. Send the *translation* file to your translator.\n1. Repeat the above steps for each language you want to add to your application.\n\n### `extract-i18n` example for French\n\nFor example, to create a French translation file, complete the following actions.\n\n1. Run the `extract-i18n` command.\n1. Make a copy of the `messages.xlf` source language file.\n1. Rename the copy to `messages.fr.xlf` for the French language \\(`fr`\\) translation.\n1. Move the `fr` translation file to the `src/locale` directory.\n1. Send the `fr` translation file to the translator.\n\n## Translate each translation file\n\nUnless you are fluent in the language and have the time to edit translations, you will likely complete the following steps.\n\n1. Send each translation file to a translator.\n1. The translator uses an XLIFF file editor to complete the following actions.\n    1. Create the translation.\n    1. Edit the translation.\n\n### Translation process example for French\n\nTo demonstrate the process, review the `messages.fr.xlf` file in the [Example Angular Internationalization application][GuideI18nExample].  The [Example Angular Internationalization application][GuideI18nExample] includes a French translation for you to edit without a special XLIFF editor or knowledge of French.\n\nThe following actions describe the translation process for French.\n\n1. Open `messages.fr.xlf` and find the first `<trans-unit>` element.\n    This is a *translation unit*, also known as a *text node*, that represents the translation of the `<h1>` greeting tag that was previously marked with the `i18n` attribute.\n\n    <docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translated-hello-before\"/>\n\n    The `id=\"introductionHeader\"` is a [custom ID][GuideI18nOptionalManageMarkedText], but without the `@@` prefix required in the source HTML.\n\n1. Duplicate the `<source>... </source>` element in the text node, rename it to `target`, and then replace the content with the French text.\n\n    <docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>, after translation)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translated-hello\"/>\n\n    In a more complex translation, the information and context in the [description and meaning elements][GuideI18nCommonPrepareAddHelpfulDescriptionsAndMeanings] help you choose the right words for translation.\n\n1. Translate the other text nodes.\n    The following example displays the way to translate.\n\n    <docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translated-other-nodes\"/>\n\nIMPORTANT: Don't change the IDs for translation units.\nEach `id` attribute is generated by Angular and depends on the content of the component text and the assigned meaning.\n\nIf you change either the text or the meaning, then the `id` attribute changes.\nFor more about managing text updates and IDs, see [custom IDs][GuideI18nOptionalManageMarkedText].\n\n## Translate plurals\n\nAdd or remove plural cases as needed for each language.\n\nHELPFUL: For language plural rules, see [CLDR plural rules][GithubUnicodeOrgCldrStagingChartsLatestSupplementalLanguagePluralRulesHtml].\n\n### `minute` `plural` example\n\nTo translate a `plural`, translate the ICU format match values.\n\n* `just now`\n* `one minute ago`\n* `<x id=\"INTERPOLATION\" equiv-text=\"{{minutes}}\"/> minutes ago`\n\nThe following example displays the way to translate.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translated-plural\"/>\n\n## Translate alternate expressions\n\nAngular also extracts alternate `select` ICU expressions as separate translation units.\n\n### `gender` `select` example\n\nThe following example displays a `select` ICU expression in the component template.\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/i18n/src/app/app.component.html\" visibleRegion=\"i18n-select\"/>\n\nIn this example, Angular extracts the expression into two translation units.\nThe first contains the text outside of the `select` clause, and uses a placeholder for `select` \\(`<x id=\"ICU\">`\\):\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translate-select-1\"/>\n\nIMPORTANT: When you translate the text, move the placeholder if necessary, but don't remove it.\nIf you remove the placeholder, the ICU expression is removed from your translated application.\n\nThe following example displays the second translation unit that contains the `select` clause.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translate-select-2\"/>\n\nThe following example displays both translation units after translation is complete.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translated-select\"/>\n\n## Translate nested expressions\n\nAngular treats a nested expression in the same manner as an alternate expression.\nAngular extracts the expression into two translation units.\n\n### Nested `plural` example\n\nThe following example displays the first translation unit that contains the text outside of the nested expression.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translate-nested-1\"/>\n\nThe following example displays the second translation unit that contains the complete nested expression.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translate-nested-2\"/>\n\nThe following example displays both translation units after translating.\n\n<docs-code header=\"src/locale/messages.fr.xlf (<trans-unit>)\" path=\"adev/src/content/examples/i18n/doc-files/messages.fr.xlf.html\" visibleRegion=\"translate-nested\"/>\n\n## What's next\n\n<docs-pill-row>\n  <docs-pill href=\"guide/i18n/merge\" title=\"Merge translations into the app\"/>\n</docs-pill-row>\n\n[CliMain]: cli \"CLI Overview and Command Reference | Angular\"\n[CliExtractI18n]: cli/extract-i18n \"ng extract-i18n | CLI | Angular\"\n\n[GuideI18nCommonPrepare]: guide/i18n/prepare \"Prepare component for translation | Angular\"\n[GuideI18nCommonPrepareAddHelpfulDescriptionsAndMeanings]: guide/i18n/prepare#add-helpful-descriptions-and-meanings \"Add helpful descriptions and meanings - Prepare component for translation | Angular\"\n\n[GuideI18nCommonTranslationFilesCreateATranslationFileForEachLanguage]: guide/i18n/translation-files#create-a-translation-file-for-each-language \"Create a translation file for each language - Work with translation files | Angular\"\n[GuideI18nCommonTranslationFilesExtractTheSourceLanguageFile]: guide/i18n/translation-files#extract-the-source-language-file \"Extract the source language file - Work with translation files | Angular\"\n[GuideI18nCommonTranslationFilesTranslateAlternateExpressions]: guide/i18n/translation-files#translate-alternate-expressions \"Translate alternate expressions - Work with translation files | Angular\"\n[GuideI18nCommonTranslationFilesTranslateEachTranslationFile]: guide/i18n/translation-files#translate-each-translation-file \"Translate each translation file - Work with translation files | Angular\"\n[GuideI18nCommonTranslationFilesTranslateNestedExpressions]: guide/i18n/translation-files#translate-nested-expressions \"Translate nested expressions - Work with translation files | Angular\"\n[GuideI18nCommonTranslationFilesTranslatePlurals]: guide/i18n/translation-files#translate-plurals \"Translate plurals - Work with translation files | Angular\"\n\n[GuideI18nExample]: guide/i18n/example \"Example Angular Internationalization application | Angular\"\n\n[GuideI18nOptionalManageMarkedText]: guide/i18n/manage-marked-text \"Manage marked text with custom IDs | Angular\"\n\n[GithubGoogleAppResourceBundleWikiApplicationresourcebundlespecification]: https://github.com/google/app-resource-bundle/wiki/ApplicationResourceBundleSpecification \"ApplicationResourceBundleSpecification | google/app-resource-bundle | GitHub\"\n\n[GithubUnicodeOrgCldrStagingChartsLatestSupplementalLanguagePluralRulesHtml]: https://cldr.unicode.org/index/cldr-spec/plural-rules \"Language Plural Rules - CLDR Charts | Unicode | GitHub\"\n\n[JsonMain]: https://www.json.org \"Introducing JSON | JSON\"\n\n[OasisOpenDocsXliffXliffCoreXliffCoreHtml]: http://docs.oasis-open.org/xliff/xliff-core/xliff-core.html \"XLIFF Version 1.2 Specification | Oasis Open Docs\"\n[OasisOpenDocsXliffXliffCoreV20Cos01XliffCoreV20Cose01Html]: http://docs.oasis-open.org/xliff/xliff-core/v2.0/cos01/xliff-core-v2.0-cos01.html \"XLIFF Version 2.0 | Oasis Open Docs\"\n\n[UnicodeCldrDevelopmentDevelopmentProcessDesignProposalsXmb]: http://cldr.unicode.org/development/development-process/design-proposals/xmb \"XMB | CLDR - Unicode Common Locale Data Repository | Unicode\"\n\n[WikipediaWikiXliff]: https://en.wikipedia.org/wiki/XLIFF \"XLIFF | Wikipedia\"\n\n\n\n================================================\nFILE: adev/src/content/guide/ngmodules/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"ngmodules\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 12869
  },
  {
    "id": 60,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/ngmodules/overview.md",
    "startLine": 12873,
    "content": "# NgModules\n\nIMPORTANT: The Angular team recommends using [standalone components](guide/components/anatomy-of-components#-imports-in-the-component-decorator) instead of `NgModule` for all new code. Use this guide to understand existing code built with `@NgModule`.\n\nAn NgModule is a class marked by the `@NgModule` decorator. This decorator accepts *metadata* that tells Angular how to compile component templates and configure dependency injection.\n\n```typescript\nimport {NgModule} from '@angular/core';\n\n@NgModule({\n  // Metadata goes here\n})\nexport class CustomMenuModule { }\n```\n\nAn NgModule has two main responsibilities:\n* Declaring components, directives, and pipes that belong to the NgModule\n* Add providers to the injector for components, directives, and pipes that import the NgModule\n\n## Declarations\n\nThe `declarations` property of the `@NgModule` metadata declares the components, directives, and pipes that belong to the NgModule.\n\n```typescript\n@NgModule({\n  /* ... */\n  // CustomMenu and CustomMenuItem are components.\n  declarations: [CustomMenu, CustomMenuItem],\n})\nexport class CustomMenuModule { }\n```\n\nIn the example above, the components `CustomMenu` and `CustomMenuItem` belong to `CustomMenuModule`.\n\nThe `declarations` property additionally accepts _arrays_ of components, directives, and pipes. These arrays, in turn, may also contain other arrays.\n\n```typescript\nconst MENU_COMPONENTS = [CustomMenu, CustomMenuItem];\nconst WIDGETS = [MENU_COMPONENTS, CustomSlider];\n\n@NgModule({\n  /* ... */\n  // This NgModule declares all of CustomMenu, CustomMenuItem,\n  // CustomSlider, and CustomCheckbox.\n  declarations: [WIDGETS, CustomCheckbox],\n})\nexport class CustomMenuModule { }\n```\n\nIf Angular discovers any components, directives, or pipes declared in more than one NgModule, it reports an error.\n\nAny components, directives, or pipes must be explicitly marked as `standalone: false` in order to be declared in an NgModule.\n\n```typescript\n@Component({\n  // Mark this component as `standalone: false` so that it can be declared in an NgModule.\n  standalone: false,\n  /* ... */\n})\nexport class CustomMenu { /* ... */ }\n```\n\n### imports\n\nComponents declared in an NgModule may depend on other components, directives, and pipes. Add these dependencies to the `imports` property of the `@NgModule` metadata.\n\n```typescript\n@NgModule({\n  /* ... */\n  // CustomMenu and CustomMenuItem depend on the PopupTrigger and SelectorIndicator components.\n  imports: [PopupTrigger, SelectionIndicator],\n  declarations: [CustomMenu, CustomMenuItem],\n})\nexport class CustomMenuModule { }\n```\n\nThe `imports` array accepts other NgModules, as well as standalone components, directives, and pipes.\n\n### exports\n\nAn NgModule can _export_ its declared components, directives, and pipes such that they're available to other components and NgModules.\n\n ```typescript\n@NgModule({\n  imports: [PopupTrigger, SelectionIndicator],\n  declarations: [CustomMenu, CustomMenuItem],\n\n  // Make CustomMenu and CustomMenuItem available to\n  // components and NgModules that import CustomMenuModule.\n  exports: [CustomMenu, CustomMenuItem],\n})\nexport class CustomMenuModule { }\n```\n\nThe `exports` property is not limited to declarations, however. An NgModule can also export any other components, directives, pipes, and NgModules that it imports.\n\n ```typescript\n@NgModule({\n  imports: [PopupTrigger, SelectionIndicator],\n  declarations: [CustomMenu, CustomMenuItem],\n\n  // Also make PopupTrigger available to any component or NgModule that imports CustomMenuModule.\n  exports: [CustomMenu, CustomMenuItem, PopupTrigger],\n})\nexport class CustomMenuModule { }\n```\n\n## `NgModule` providers\n\nTIP: See the [Dependency Injection guide](guide/di) for information on dependency injection and providers.\n\nAn `NgModule` can specify `providers` for injected dependencies. These providers are available to:\n* Any standalone component, directive, or pipe that imports the NgModule, and\n* The `declarations` and `providers` of any _other_ NgModule that imports the NgModule.\n\n```typescript\n@NgModule({\n  imports: [PopupTrigger, SelectionIndicator],\n  declarations: [CustomMenu, CustomMenuItem],\n\n  // Provide the OverlayManager service\n  providers: [OverlayManager],\n  /* ... */\n})\nexport class CustomMenuModule { }\n\n@NgModule({\n  imports: [CustomMenuModule],\n  declarations: [UserProfile],\n  providers: [UserDataClient],\n})\nexport class UserProfileModule { }\n```\n\nIn the example above:\n* The `CustomMenuModule` provides `OverlayManager`.\n* The `CustomMenu` and `CustomMenuItem` components can inject `OverlayManager` because they're declared in `CustomMenuModule`.\n* `UserProfile` can inject `OverlayManager` because its NgModule imports `CustomMenuModule`.\n* `UserDataClient` can inject `OverlayManager` because its NgModule imports `CustomMenuModule`.\n\n### The `forRoot` and `forChild` pattern\n\nSome NgModules define a static `forRoot` method that accepts some configuration and returns an array of providers. The name \"`forRoot`\" is a convention that indicates that these providers are intended to be added exclusively to the _root_ of your application during bootstrap.\n\nAny providers included in this way are eagerly loaded, increasing the JavaScript bundle size of your initial page load.\n\n```typescript\nboorstrapApplication(MyApplicationRoot, {\n  providers: [\n    CustomMenuModule.forRoot(/* some config */),\n  ],\n});\n```\n\nSimilarly, some NgModules may define a static `forChild` that indicates the providers are intended to be added to components within your application hierarchy.\n\n```typescript\n@Component({\n  /* ... */\n  providers: [\n    CustomMenuModule.forChild(/* some config */),\n  ],\n})\nexport class UserProfile { /* ... */ }\n```\n\n## Bootstrapping an application\n\nIMPORTANT: The Angular team recommends using [bootstrapApplication](api/platform-browser/bootstrapApplication) instead of `bootstrapModule` for all new code. Use this guide to understand existing applications bootstrapped with `@NgModule`.\n\nThe `@NgModule` decorator accepts an optional `bootstrap` array that may contain one or more components.\n\nYou can use the [`bootstrapModule`](https://angular.dev/api/core/PlatformRef#bootstrapModule) method from either [`platformBrowser`](api/platform-browser/platformBrowser) or [`platformServer`](api/platform-server/platformServer) to start an Angular application. When run, this function locates any elements on the page with a CSS selector that matches the listed componet(s) and renders those components on the page.\n\n```typescript\nimport {platformBrowser} from '@angular/platform-browser';\n\n@NgModule({\n  bootstrap: [MyApplication],\n})\nexport class MyApplicationModule { }\n\nplatformBrowser().bootstrapModule(MyApplicationModule);\n```\n\nComponents listed in `bootstrap` are automatically included in the NgModule's declarations.\n\nWhen you bootstrap an application from an NgModule, the collected `providers` of this module and all of the `providers` of its `imports` are eagerly loaded and available to inject for the entire application.\n\n\n\n================================================\nFILE: adev/src/content/guide/performance/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"performance\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:overview.svg\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 13081
  },
  {
    "id": 61,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/performance/overview.md",
    "startLine": 13085,
    "content": "<docs-decorative-header title=\"Server-side & hybrid rendering\" imgSrc=\"adev/src/assets/images/overview.svg\"> <!-- markdownlint-disable-line -->\nLearn about different ways you can optimize the performance of your application with different rendering strategies.\n</docs-decorative-header>\n\nOne of the top priorities of any developer is ensuring that their application is as performant as possible. These guides are here to help you follow best practices for building performant applications by taking advantage of different rendering strategies.\n\n| Guides Types                              | Description                                                                                                |\n| :---------------------------------------- | :--------------------------------------------------------------------------------------------------------- |\n| [Server and hybrid rendering](/guide/ssr) | Learn how to leverage rendering pages on the server to improve load times.                                 |\n| [Hydration](/guide/hydration)             | A process to improve application performance by restoring its state after server-side rendering and reusing existing DOM structure as much as possible. |\n| [Incremental Hydration](/guide/incremental-hydration) | Incremental hydration is an advanced type of hydration that can leave sections of your application dehydrated and incrementally trigger hydration of those sections as they are needed. |\n\n\n\n================================================\nFILE: adev/src/content/guide/pipes/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"pipes\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 13116
  },
  {
    "id": 62,
    "file": "change-detection",
    "fullFileName": "adev/src/content/guide/pipes/change-detection.md",
    "startLine": 13120,
    "content": "# Change detection with pipes\n\nPipes are often used with data-bound values that might change based on user actions.\nIf the data is a primitive input value, such as `String` or `Number`, or an object reference as input, such as `Date` or `Array`, Angular executes the pipe whenever it detects a change for the value.\n\n<docs-code-multifile path=\"adev/src/content/examples/pipes/src/app/power-booster.component.ts\">\n  <docs-code header=\"src/app/exponential-strength.pipe.ts\" path=\"adev/src/content/examples/pipes/src/app/exponential-strength.pipe.ts\"\n             highlight=\"[16]\" visibleRegion=\"pipe-class\" />\n  <docs-code header=\"src/app/power-booster.component.ts\" path=\"adev/src/content/examples/pipes/src/app/power-booster.component.ts\"/>\n</docs-code-multifile>\n\nThe `exponentialStrength` pipe executes every time the user changes the value or the exponent. See the highlighted line above.\n\nAngular detects each change and immediately runs the pipe.\nThis is fine for primitive input values.\nHowever, if you change something *inside* a composite object (such as the month of a date, an element of an array, or an object property), you need to understand how change detection works, and how to use an `impure` pipe.\n\n## How change detection works\n\nAngular looks for changes to data-bound values in a change detection process that runs after every DOM event: every keystroke, mouse move, timer tick, and server response.\nThe following example, which doesn't use a pipe, demonstrates how Angular uses its default change detection strategy to monitor and update its display of every hero in the `heroes` array.\nThe example tabs show the following:\n\n| Files                               | Details |\n|:---                                 |:---     |\n| `flying-heroes.component.html (v1)` | The `*ngFor` repeater displays the hero names.                     |\n| `flying-heroes.component.ts (v1)`   | Provides heroes, adds heroes into the array, and resets the array. |\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/flying-heroes.component.html (v1)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.component.html\" visibleRegion=\"template-1\"/>\n    <docs-code header=\"src/app/flying-heroes.component.ts (v1)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.component.ts\" visibleRegion=\"v1\"/>\n</docs-code-multifile>\n\nAngular updates the display every time the user adds a hero.\nIf the user clicks the **Reset** button, Angular replaces `heroes` with a new array of the original heroes and updates the display.\nIf you add the ability to remove or change a hero, Angular would detect those changes and update the display as well.\n\nHowever, executing a pipe to update the display with every change would slow down your application's performance.\nSo Angular uses a faster change-detection algorithm for executing a pipe, as described in the next section.\n\n## Detecting pure changes to primitives and object references\n\nBy default, pipes are defined as *pure* so that Angular executes the pipe only when it detects a *pure change* to the input value or parameters.\nA pure change is either a change to a primitive input value \\(such as `String`, `Number`, `Boolean`, or `Symbol`\\), or a changed object reference \\(such as `Date`, `Array`, `Function`, or `Object`\\).\n\nA pure pipe must use a pure function, which is one that processes inputs and returns values without side effects.\nIn other words, given the same input, a pure function should always return the same output.\n\nWith a pure pipe, Angular ignores changes within objects and arrays because checking a primitive value or object reference is much faster than performing a deep check for differences within objects.\nAngular can quickly determine if it can skip executing the pipe and updating the view.\n\nHowever, a pure pipe with an array as input might not work the way you want.\nTo demonstrate this issue, change the previous example to filter the list of heroes to just those heroes who can fly.\n\nFor this, consider we use the `FlyingHeroesPipe` in the `*ngFor` repeater as shown in the following code.\nThe tabs for the example show the following:\n\n| Files                          | Details |\n|:---                            |:---     |\n| flying-heroes.component.html   | Template with the new pipe used. |\n| flying-heroes.pipe.ts          | File with custom pipe that filters flying heroes. |\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/flying-heroes.component.html\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.component.html\" visibleRegion=\"template-flying-heroes\"/>\n    <docs-code header=\"src/app/flying-heroes.pipe.ts\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.pipe.ts\" visibleRegion=\"pure\"/>\n</docs-code-multifile>\n\nThe application now shows unexpected behavior: When the user adds flying heroes, none of them appear under \"Heroes who fly.\"\nThis happens because the code that adds a hero does so by pushing it onto the `heroes` array that is used as input for the `flyingHeroes` pipe.\n\n<docs-code header=\"src/app/flying-heroes.component.ts\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.component.ts\" visibleRegion=\"push\"/>\n\nThe change detector ignores changes within elements of an array, so the pipe doesn't run.\nThe reason Angular ignores the changed array element is that the *reference* to the array hasn't changed.\nBecause the array is the same, Angular does not update the display.\n\nOne way to get the behavior you want is to change the object reference itself.\nReplace the array with a new array containing the newly changed elements, and then input the new array to the pipe.\nIn the preceding example, create an array with the new hero appended, and assign that to `heroes`.\nAngular detects the change in the array reference and executes the pipe.\n\nTo summarize, if you mutate the input array, the pure pipe doesn't execute.\nIf you *replace* the input array, the pipe executes and the display is updated.\nAs an alternative, use an *impure* pipe to detect changes within composite objects such as arrays, as described in the next section.\n\n## Detecting impure changes within composite objects\n\nTo execute a custom pipe after a change *within* a composite object, such as a change to an element of an array, you need to define your pipe as `impure` to detect impure changes.\nAngular executes an impure pipe every time it detects a change (e.g. every keystroke or mouse event).\n\nIMPORTANT: While an impure pipe can be useful, be careful using one.\nA long-running impure pipe could dramatically slow down your application.\n\nMake a pipe impure by setting its `pure` flag to `false`:\n\n<docs-code header=\"src/app/flying-heroes.pipe.ts\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.pipe.ts\"\n           visibleRegion=\"pipe-decorator\" highlight=\"[19]\"/>\n\nThe following code shows the complete implementation of `FlyingHeroesImpurePipe`, which extends `FlyingHeroesPipe` to inherit its characteristics.\nThe example shows that you don't have to change anything else—the only difference is setting the `pure` flag as `false` in the pipe metadata.\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/flying-heroes.pipe.ts (FlyingHeroesImpurePipe)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.pipe.ts\" visibleRegion=\"impure\"/>\n    <docs-code header=\"src/app/flying-heroes.pipe.ts (FlyingHeroesPipe)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.pipe.ts\" visibleRegion=\"pure\"/>\n</docs-code-multifile>\n\n`FlyingHeroesImpurePipe` is a reasonable candidate for an impure pipe because the `transform` function is trivial and fast:\n\n<docs-code header=\"src/app/flying-heroes.pipe.ts (filter)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes.pipe.ts\" visibleRegion=\"filter\"/>\n\nYou can derive a `FlyingHeroesImpureComponent` from `FlyingHeroesComponent`.\nAs shown in the following code, only the pipe in the template changes.\n\n<docs-code header=\"src/app/flying-heroes-impure.component.html (excerpt)\" path=\"adev/src/content/examples/pipes/src/app/flying-heroes-impure.component.html\" visibleRegion=\"template-flying-heroes\"/>\n\n\n\n================================================\n",
    "endLine": 13236
  },
  {
    "id": 63,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/pipes/overview.md",
    "startLine": 13240,
    "content": "# Understanding Pipes\n\nUse pipes to transform strings, currency amounts, dates, and other data for display.\n\n## What is a pipe\n\nPipes are simple functions to use in templates to accept an input value and return a transformed value. Pipes are useful because you can use them throughout your application, while only declaring each pipe once.\nFor example, you would use a pipe to show a date as **April 15, 1988** rather than the raw string format.\n\nYou can create your own custom pipes to expose reusable transformations in templates.\n\n## Built-in pipes\n\nAngular provides built-in pipes for typical data transformations, including transformations for internationalization (i18n), which use locale information to format data.\nThe following are commonly used built-in pipes for data formatting:\n\n- [`DatePipe`](api/common/DatePipe): Formats a date value according to locale rules.\n- [`UpperCasePipe`](api/common/UpperCasePipe): Transforms text to all upper case.\n- [`LowerCasePipe`](api/common/LowerCasePipe): Transforms text to all lower case.\n- [`CurrencyPipe`](api/common/CurrencyPipe): Transforms a number to a currency string, formatted according to locale rules.\n- [`DecimalPipe`](/api/common/DecimalPipe): Transforms a number into a string with a decimal point, formatted according to locale rules.\n- [`PercentPipe`](api/common/PercentPipe): Transforms a number to a percentage string, formatted according to locale rules.\n- [`AsyncPipe`](api/common/AsyncPipe): Subscribe and unsubscribe to an asynchronous source such as an observable.\n- [`JsonPipe`](api/common/JsonPipe): Display a component object property to the screen as JSON for debugging.\n\nNOTE: For a complete list of built-in pipes, see the [pipes API documentation](/api?type=pipe \"Pipes API reference summary\").\nTo learn more about using pipes for internationalization (i18n) efforts, see [formatting data based on locale](guide/i18n/format-data-locale).\n\n\n\n================================================\n",
    "endLine": 13269
  },
  {
    "id": 64,
    "file": "precedence",
    "fullFileName": "adev/src/content/guide/pipes/precedence.md",
    "startLine": 13273,
    "content": "# Pipe precedence in template expressions\n\nSometimes you want to choose between two values, based on some condition, before passing the choice to the pipe.\nYou could use the JavaScript ternary operator (`?:`) in the template to make that choice.\n\nBeware! The pipe operator has a higher precedence than the JavaScript ternary operator (`?:`).\n\nIf you simply write the expression as if it were evaluated left-to-right, you might be surprised by the result. For example,\n\n```ts\ncondition ? a : b | pipe\n```\n\nis parsed as\n\n```ts\ncondition ? a : (b | pipe)\n```\n\nThe value of `b` passes through `pipe`; the value of `a` *will not*.\n\nIf you want the pipe to apply to the result of the ternary expression, wrap the entire expression in parentheses. For example,\n\n```ts\n(condition ? a : b) | pipe\n```\n\nIn general, you should always use parentheses to be sure Angular evaluates the expression as you intend.\n\n\n\n================================================\n",
    "endLine": 13303
  },
  {
    "id": 65,
    "file": "template",
    "fullFileName": "adev/src/content/guide/pipes/template.md",
    "startLine": 13307,
    "content": "# Using a pipe in a template\n\nTo apply a pipe, use the pipe operator (`|`) within a template expression as shown in the following code example.\n\n<docs-code language=\"angular-html\" header=\"app.component.html\">\n<p>The hero's birthday is {{ birthday | date }}</p>\n</docs-code>\n\nThe component's `birthday` value flows through the pipe operator (`|`) to the [`DatePipe`](api/common/DatePipe) whose pipe name is `date`.\nThe pipe renders the date in the default format like **Apr 07, 2023**.\n\n<docs-code header=\"app.component.ts\" preview>\nimport { Component } from '@angular/core';\nimport { DatePipe } from '@angular/common';\n\n@Component({\n  templateUrl: './app.component.html',\n  imports: [DatePipe],\n})\nexport class AppComponent {\n  birthday = new Date();\n}\n</docs-code>\n\n## Additional parameters for pipes\n\nPipes can take additional parameters that configure the transformation. Parameters can be optional or required.\n\nFor example, the `date` pipe takes optional parameters that control the date's display format.\nTo specify the parameter, follow the pipe name with a colon (`:`) and the parameter value (the format).\n\n<docs-code language=\"angular-html\" header=\"app.component.html\">\n<p>The hero's birthday is in {{ birthday | date:'yyyy' }}</p>\n</docs-code>\n\nPipes can also take multiple parameters. You can pass multiple parameters by separating these via colons (`:`).\nFor example, the `date` pipe accepts a second optional parameter for controlling the timezone.\n\n<docs-code header=\"app.component.html\">\n<p>The current time is: {{ currentTime | date:'hh:mm':'UTC' }}</p>\n</docs-code>\n\nThis will display the current time (like `10:53`) in the `UTC` timezone.\n\n## Chaining pipes\n\nYou can connect multiple pipes so that the output of one pipe becomes the input to the next.\n\nThe following example passes a date to the `DatePipe` and then forwards the result to the [`UpperCasePipe`](api/common/UpperCasePipe 'API reference') pipe.\n\n<docs-code language=\"angular-html\" header=\"app.component.html\">\n<p>The hero's birthday is {{ birthday | date }}</p>\n<p>The hero's birthday is in {{ birthday | date:'yyyy' | uppercase }}</p>\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 13363
  },
  {
    "id": 66,
    "file": "transform-data",
    "fullFileName": "adev/src/content/guide/pipes/transform-data.md",
    "startLine": 13367,
    "content": "# Custom pipes for new transforms\n\nCreate custom pipes to encapsulate transformations that are not provided with the built-in pipes.\nThen, use your custom pipe in template expressions, the same way you use built-in pipes—to transform input values to output values for display.\n\n## Marking a class as a pipe\n\nTo mark a class as a pipe and supply configuration metadata, apply the `@Pipe` to the class.\n\nUse UpperCamelCase (the general convention for class names) for the pipe class name, and camelCase for the corresponding `name` string.\nDo not use hyphens in the `name`.\n\nFor details and more examples, see [Pipe names](/style-guide#pipe-names \"Pipe names in the Angular coding style guide\").\n\nUse `name` in template expressions as you would for a built-in pipe.\n\n```ts\nimport { Pipe } from '@angular/core';\n\n@Pipe({\n  name: 'greet',\n})\nexport class GreetPipe {}\n```\n\n## Using the PipeTransform interface\n\nImplement the [`PipeTransform`](/api/core/PipeTransform \"API reference for PipeTransform\") interface in your custom pipe class to perform the transformation.\n\nAngular invokes the `transform` method with the value of a binding as the first argument, and any parameters as the second argument in list form, and returns the transformed value.\n\n```ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'greet',\n})\nexport class GreetPipe implements PipeTransform {\n  transform(value: string, param1: boolean, param2: boolean): string {\n    return `Hello ${value}`;\n  }\n}\n```\n\n## Example: Transforming a value exponentially\n\nIn a game, you might want to implement a transformation that raises a value exponentially to increase a hero's power.\nFor example, if the hero's score is 2, boosting the hero's power exponentially by 10 produces a score of 1024 (`2**10`).\nUse a custom pipe for this transformation.\n\nThe following code example shows two component definitions:\n\n| Files                          | Details |\n|:---                            |:---     |\n| `exponential-strength.pipe.ts` | Defines a custom pipe named `exponentialStrength` with the `transform` method that performs the transformation. It defines an argument to the `transform` method \\(`exponent`\\) for a parameter passed to the pipe. |\n| `power-booster.component.ts`   | Demonstrates how to use the pipe, specifying a value \\(`2`\\) and the exponent parameter \\(`10`\\).                                                                                                                   |\n\n<docs-code-multifile>\n  <docs-code header=\"src/app/exponential-strength.pipe.ts\" language=\"ts\" path=\"adev/src/content/examples/pipes/src/app/exponential-strength.pipe.ts\"/>\n  <docs-code header=\"src/app/power-booster.component.ts\" language=\"ts\" path=\"adev/src/content/examples/pipes/src/app/power-booster.component.ts\"/>\n</docs-code-multifile>\n\n\n\n================================================\n",
    "endLine": 13430
  },
  {
    "id": 67,
    "file": "unwrapping-data-observables",
    "fullFileName": "adev/src/content/guide/pipes/unwrapping-data-observables.md",
    "startLine": 13434,
    "content": "# Unwrapping data from an observable\n\nObservables let you pass messages between parts of your application.\nYou can use observables for event handling, asynchronous programming, and handling multiple values.\nObservables can deliver single or multiple values of any type, either synchronously (as a function delivers a value to its caller) or asynchronously on a schedule.\n\nUse the built-in [`AsyncPipe`](api/common/AsyncPipe \"API description of AsyncPipe\") to accept an observable as input and subscribe to the input automatically.\nWithout this pipe, your component code would have to subscribe to the observable to consume its values, extract the resolved values, expose them for binding, and unsubscribe when the observable is destroyed in order to prevent memory leaks.\n`AsyncPipe` is a pipe that saves boilerplate code in your component to maintain the subscription and keep delivering values from that observable as they arrive.\n\nThe following code example binds an observable of message strings (`message$`) to a view with the `async` pipe.\n\n<!-- TODO: Enable preview if this example does not depend on Zone/ or if we run the example with Zone. -->\n<docs-code header=\"src/app/hero-async-message.component.ts\"\n           path=\"adev/src/content/examples/pipes/src/app/hero-async-message.component.ts\" />\n\n\n\n================================================\nFILE: adev/src/content/guide/routing/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"routing\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:routing.svg\",\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 13470
  },
  {
    "id": 68,
    "file": "common-router-tasks",
    "fullFileName": "adev/src/content/guide/routing/common-router-tasks.md",
    "startLine": 13474,
    "content": "# Common Routing Tasks\n\nThis topic describes how to implement many of the common tasks associated with adding the Angular router to your application.\n\n## Generate an application with routing enabled\n\nThe following command uses the Angular CLI to generate a basic Angular application with application routes. The application name in the following example is `routing-app`.\n\n```shell\nng new routing-app\n```\n\n### Adding components for routing\n\nTo use the Angular router, an application needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where `first` is the name of your component:\n\n```shell\nng generate component first\n```\n\nRepeat this step for a second component but give it a different name. Here, the new name is `second`.\n\n<docs-code language=\"shell\">\n\nng generate component second\n\n</docs-code>\n\nThe CLI automatically appends `Component`, so if you were to write `first-component`, your component would be `FirstComponentComponent`.\n\n<docs-callout title=\"`base href`\">\n\nThis guide works with a CLI-generated Angular application. If you are working manually, make sure that you have `<base href=\"/\">` in the `<head>` of your index.html file.\nThis assumes that the `app` folder is the application root, and uses `\"/\"`.\n\n</docs-callout>\n\n### Importing your new components\n\nTo use your new components, import them into `app.routes.ts` at the top of the file, as follows:\n\n<docs-code language=\"ts\">\n\nimport {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';\n\n</docs-code>\n\n## Defining a basic route\n\nThere are three fundamental building blocks to creating a route.\n\nImport the routes into `app.config.ts` and add it to the `provideRouter` function. The following is the default `ApplicationConfig` using the CLI.\n\n<docs-code language=\"ts\">\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};\n\n</docs-code>\n\nThe Angular CLI performs this step for you. However, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct.\n\n<docs-workflow>\n\n<docs-step title=\"Set up a `Routes` array for your routes\">\n\nThe Angular CLI performs this step automatically.\n\n```ts\nimport { Routes } from '@angular/router';\n\nexport const routes: Routes = [];\n```\n\n</docs-step>\n\n<docs-step title=\"Define your routes in your `Routes` array\">\n\nEach route in this array is a JavaScript object that contains two properties. The first property, `path`, defines the URL path for the route. The second property, `component`, defines the component Angular should use for the corresponding path.\n\n```ts\nconst routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];\n```\n\n</docs-step>\n\n<docs-step title=\"Add your routes to your application\">\n\nNow that you have defined your routes, add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the `routerLink` attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include `<router-outlet>`. This element informs Angular to update the application view with the component for the selected route.\n\n```angular-html\n<h1>Angular Router App</h1>\n<nav>\n  <ul>\n    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>\n    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>\n  </ul>\n</nav>\n<!-- The routed views render in the <router-outlet>-->\n<router-outlet />\n```\n\nYou also need to add the `RouterLink`, `RouterLinkActive`, and `RouterOutlet` to the `imports` array of `AppComponent`.\n\n```ts\n@Component({\n  selector: 'app-root',\n  imports: [RouterOutlet, RouterLink, RouterLinkActive],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}\n```\n\n</docs-step>\n\n</docs-workflow>\n\n### Route order\n\nThe order of routes is important because the `Router` uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes.\nList routes with a static path first, followed by an empty path route, which matches the default route.\nThe [wildcard route](guide/routing/common-router-tasks#setting-up-wildcard-routes) comes last because it matches every URL and the `Router` selects it only if no other routes match first.\n\n## Getting route information\n\nOften, as a user navigates your application, you want to pass information from one component to another.\nFor example, consider an application that displays a shopping list of grocery items.\nEach item in the list has a unique `id`.\nTo edit an item, users click an Edit button, which opens an `EditGroceryItem` component.\nYou want that component to retrieve the `id` for the grocery item so it can display the right information to the user.\n\nUse a route to pass this type of information to your application components.\nTo do so, you use the [withComponentInputBinding](api/router/withComponentInputBinding) feature with `provideRouter` or the `bindToComponentInputs` option of `RouterModule.forRoot`.\n\nTo get information from a route:\n\n<docs-workflow>\n\n<docs-step title=\"Add `withComponentInputBinding`\">\n\nAdd the `withComponentInputBinding` feature to the `provideRouter` method.\n\n```ts\nproviders: [\n  provideRouter(appRoutes, withComponentInputBinding()),\n]\n```\n\n</docs-step>\n\n<docs-step title=\"Add an `Input` to the component\">\n\nUpdate the component to have an `Input` matching the name of the parameter.\n\n```ts\n@Input()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}\n```\n\nNOTE: You can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters.\nIf you want to use the parent components route info you will need to set the router `paramsInheritanceStrategy` option:\n`withRouterConfig({paramsInheritanceStrategy: 'always'})`\n\n</docs-step>\n\n</docs-workflow>\n\n## Setting up wildcard routes\n\nA well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist.\nTo add this functionality to your application, you set up a wildcard route.\nThe Angular router selects this route any time the requested URL doesn't match any router paths.\n\nTo set up a wildcard route, add the following code to your `routes` definition.\n\n<docs-code>\n\n{ path: '**', component: <component-name> }\n\n</docs-code>\n\nThe two asterisks, `**`, indicate to Angular that this `routes` definition is a wildcard route.\nFor the component property, you can define any component in your application.\nCommon choices include an application-specific `PageNotFoundComponent`, which you can define to [display a 404 page](guide/routing/common-router-tasks#displaying-a-404-page) to your users; or a redirect to your application's main component.\nA wildcard route is the last route because it matches any URL.\nFor more detail on why order matters for routes, see [Route order](guide/routing/common-router-tasks#route-order).\n\n## Displaying a 404 page\n\nTo display a 404 page, set up a [wildcard route](guide/routing/common-router-tasks#setting-up-wildcard-routes) with the `component` property set to the component you'd like to use for your 404 page as follows:\n\n```ts\nconst routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n```\n\nThe last route with the `path` of `**` is a wildcard route.\nThe router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the `PageNotFoundComponent`.\n\n## Setting up redirects\n\nTo set up a redirect, configure a route with the `path` you want to redirect from, the `component` you want to redirect to, and a `pathMatch` value that tells the router how to match the URL.\n\n```ts\nconst routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n```\n\nIn this example, the third route is a redirect so that the router defaults to the `first-component` route.\nNotice that this redirect precedes the wildcard route.\nHere, `path: ''` means to use the initial relative URL \\(`''`\\).\n\nSometimes a redirect is not a simple, static redirect. The `redirectTo` property can also be a function\nwith more complex logic that returns a string or `UrlTree`.\n\n```ts\nconst routes: Routes = [\n  { path: \"first-component\", component: FirstComponent },\n  {\n    path: \"old-user-page\",\n    redirectTo: ({ queryParams }) => {\n      const errorHandler = inject(ErrorHandler);\n      const userIdParam = queryParams['userId'];\n      if (userIdParam !== undefined) {\n        return `/user/${userIdParam}`;\n      } else {\n        errorHandler.handleError(new Error('Attempted navigation to user page without user ID.'));\n        return `/not-found`;\n      }\n    },\n  },\n  { path: \"user/:userId\", component: OtherComponent },\n];\n```\n\n## Nesting routes\n\nAs your application grows more complex, you might want to create routes that are relative to a component other than your root component.\nThese types of nested routes are called child routes.\nThis means you're adding a second `<router-outlet>` to your app, because it is in addition to the `<router-outlet>` in `AppComponent`.\n\nIn this example, there are two additional child components, `child-a`, and `child-b`.\nHere, `FirstComponent` has its own `<nav>` and a second `<router-outlet>` in addition to the one in `AppComponent`.\n\n```angular-html\n<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"child-a\">Child A</a></li>\n    <li><a routerLink=\"child-b\">Child B</a></li>\n  </ul>\n</nav>\n\n<router-outlet />\n```\n\nA child route is like any other route, in that it needs both a `path` and a `component`.\nThe one difference is that you place child routes in a `children` array within the parent route.\n\n```ts\nconst routes: Routes = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];\n```\n\n## Setting the page title\n\nEach page in your application should have a unique title so that they can be identified in the browser history.\nThe `Router` sets the document's title using the `title` property from the `Route` config.\n\n```ts\nconst routes: Routes = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');\n```\n\nHELPFUL: The `title` property follows the same rules as static route `data` and dynamic values that implement `ResolveFn`.\n\nYou can also provide a custom title strategy by extending the `TitleStrategy`.\n\n```ts\n@Injectable({ providedIn: 'root' })\nexport class TemplatePageTitleStrategy extends TitleStrategy {\n  private readonly title = inject(Title);\n\n  override updateTitle(routerState: RouterStateSnapshot) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    { provide: TitleStrategy, useClass: TemplatePageTitleStrategy },\n  ]\n};\n```\n\n## Using relative paths\n\nRelative paths let you define paths that are relative to the current URL segment.\nThe following example shows a relative route to another component, `second-component`.\n`FirstComponent` and `SecondComponent` are at the same level in the tree, however, the link to `SecondComponent` is situated within the `FirstComponent`, meaning that the router has to go up a level and then into the second directory to find the `SecondComponent`.\nRather than writing out the whole path to get to `SecondComponent`, use the `../` notation to go up a level.\n\n```angular-html\n<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>\n  </ul>\n</nav>\n<router-outlet />\n```\n\nIn addition to `../`, use `./` or no leading slash to specify the current level.\n\n### Specifying a relative route\n\nTo specify a relative route, use the `NavigationExtras` `relativeTo` property.\nIn the component class, import `NavigationExtras` from the `@angular/router`.\n\nThen use `relativeTo` in your navigation method.\nAfter the link parameters array, which here contains `items`, add an object with the `relativeTo` property set to the `ActivatedRoute`, which is `this.route`.\n\n```ts\ngoToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}\n```\n\nThe `navigate()` arguments configure the router to use the current route as a basis upon which to append `items`.\n\nThe `goToItems()` method interprets the destination URI as relative to the activated route and navigates to the `items` route.\n\n## Accessing query parameters and fragments\n\nSometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment.\nIn this example, the route contains an `id` parameter we can use to target a specific hero page.\n\n```ts\nimport { ApplicationConfig } from \"@angular/core\";\nimport { Routes } from '@angular/router';\nimport { HeroListComponent } from './hero-list.component';\n\nexport const routes: Routes = [\n  { path: 'hero/:id', component: HeroDetailComponent }\n];\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)],\n};\n```\n\nFirst, import the following members in the component you want to navigate from.\n\n```ts\nimport { inject } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { Observable, switchMap } from 'rxjs';\n```\n\nNext inject the activated route service:\n\n```ts\nprivate readonly route = inject(ActivatedRoute);\n```\n\nConfigure the class so that you have an observable, `heroes$`, a `selectedId` to hold the `id` number of the hero, and the heroes in the `ngOnInit()`, add the following code to get the `id` of the selected hero.\nThis code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.\n\n```ts\nheroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n```\n\nNext, in the component that you want to navigate to, import the following members.\n\n```ts\nimport { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';\n```\n\nInject `ActivatedRoute` and `Router` in the constructor of the component class so they are available to this component:\n\n```ts\nprivate readonly route = inject(ActivatedRoute);\nprivate readonly router = inject(Router);\n\nhero$: Observable<Hero>;\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}\n```\n\n## Lazy loading\n\nYou can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the application launches.\nAdditionally, preload parts of your application in the background to improve the user experience.\n\nAny route can lazily load its routed, standalone component by using `loadComponent:`\n\n<docs-code header=\"Lazy loading a standalone component\" language=\"typescript\">\n\nconst routes: Routes = [\n  {\n    path: 'lazy',\n    loadComponent: () => import('./lazy.component').then(c => c.LazyComponent)\n  }\n];\n</docs-code>\nThis works as long as the loaded component is standalone.\n\n## Preventing unauthorized access\n\nUse route guards to prevent users from navigating to parts of an application without authorization.\nThe following route guards are available in Angular:\n\n<docs-pill-row>\n  <docs-pill href=\"api/router/CanActivateFn\" title=\"`canActivate`\"/>\n  <docs-pill href=\"api/router/CanActivateChildFn\" title=\"`canActivateChild`\"/>\n  <docs-pill href=\"api/router/CanDeactivateFn\" title=\"`canDeactivate`\"/>\n  <docs-pill href=\"api/router/CanMatchFn\" title=\"`canMatch`\"/>\n  <docs-pill href=\"api/router/ResolveFn\" title=\"`resolve`\"/>\n  <docs-pill href=\"api/router/CanLoadFn\" title=\"`canLoad`\"/>\n</docs-pill-row>\n\nTo use route guards, consider using [component-less routes](api/router/Route#componentless-routes) as this facilitates guarding child routes.\n\nCreate a file for your guard:\n\n```bash\nng generate guard your-guard\n```\n\nIn your guard file, add the guard functions you want to use.\nThe following example uses `canActivateFn` to guard the route.\n\n```ts\nexport const yourGuardFunction: CanActivateFn = (\n  next: ActivatedRouteSnapshot,\n  state: RouterStateSnapshot\n) => {\n  // your  logic goes here\n}\n```\n\nIn your routing module, use the appropriate property in your `routes` configuration.\nHere, `canActivate` tells the router to mediate navigation to this particular route.\n\n```ts\n{\n  path: '/your-path',\n  component: YourComponent,\n  canActivate: [yourGuardFunction],\n}\n```\n\n## Link parameters array\n\nA link parameters array holds the following ingredients for router navigation:\n\n- The path of the route to the destination component\n- Required and optional route parameters that go into the route URL\n\nBind the `RouterLink` directive to such an array like this:\n\n```angular-html\n<a [routerLink]=\"['/heroes']\">Heroes</a>\n```\n\nThe following is a two-element array when specifying a route parameter:\n\n```angular-html\n<a [routerLink]=\"['/hero', hero.id]\">\n  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}\n</a>\n```\n\nProvide optional route parameters in an object, as in `{ foo: 'foo' }`:\n\n```angular-html\n<a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>\n```\n\nThese three examples cover the needs of an application with one level of routing.\nHowever, with a child router, such as in the crisis center, you create new link array possibilities.\n\nThe following minimal `RouterLink` example builds upon a specified default child route for the crisis center.\n\n```angular-html\n<a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n```\n\nReview the following:\n\n- The first item in the array identifies the parent route \\(`/crisis-center`\\)\n- There are no parameters for this parent route\n- There is no default for the child route so you need to pick one\n- You're navigating to the `CrisisListComponent`, whose route path is `/`, but you don't need to explicitly add the slash\n\nConsider the following router link that navigates from the root of the application down to the Dragon Crisis:\n\n```angular-html\n<a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>\n```\n\n- The first item in the array identifies the parent route \\(`/crisis-center`\\)\n- There are no parameters for this parent route\n- The second item identifies the child route details about a particular crisis \\(`/:id`\\)\n- The details child route requires an `id` route parameter\n- You added the `id` of the Dragon Crisis as the second item in the array \\(`1`\\)\n- The resulting path is `/crisis-center/1`\n\nYou could also redefine the `AppComponent` template with Crisis Center routes exclusively:\n\n```angular-ts\n@Component({\n  template: `\n    <h1 class=\"title\">Angular Router</h1>\n    <nav>\n      <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n      <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>\n      <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>\n    </nav>\n    <router-outlet />\n  `\n})\nexport class AppComponent {}\n```\n\nIn summary, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, \\(required\\) router parameters, and \\(optional\\) route parameter objects.\n\n## `LocationStrategy` and browser URL styles\n\nWhen the router navigates to a new component view, it updates the browser's location and history with a URL for that view.\n\nModern HTML5 browsers support [history.pushState](https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries 'HTML5 browser history push-state'), a technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load.\n\nHere's the Crisis Center URL in this \"HTML5 pushState\" style:\n\n```text\nlocalhost:3002/crisis-center\n```\n\nOlder browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" \\(called the \"hash\"\\).\nRouters can take advantage of this exception by composing in-application route URLs with hashes.\nHere's a \"hash URL\" that routes to the Crisis Center.\n\n```text\nlocalhost:3002/src/#/crisis-center\n```\n\nThe router supports both styles with two `LocationStrategy` providers:\n\n| Providers              | Details                              |\n| :--------------------- | :----------------------------------- |\n| `PathLocationStrategy` | The default \"HTML5 pushState\" style. |\n| `HashLocationStrategy` | The \"hash URL\" style.                |\n\nThe `RouterModule.forRoot()` function sets the `LocationStrategy` to the `PathLocationStrategy`, which makes it the default strategy.\nYou also have the option of switching to the `HashLocationStrategy` with an override during the bootstrapping process.\n\nHELPFUL: For more information on providers and the bootstrap process, see [Dependency Injection](guide/di/dependency-injection-providers).\n\n## Choosing a routing strategy\n\nYou must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references.\n\nAlmost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.\n\nRendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads.\nAn application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.\n\nThis option is only available if application URLs look like normal web URLs without hash \\(`#`\\) characters in the middle.\n\n## `<base href>`\n\nThe router uses the browser's [history.pushState](https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries 'HTML5 browser history push-state') for navigation.\n`pushState` lets you customize in-application URL paths; for example, `localhost:4200/crisis-center`.\nThe in-application URLs can be indistinguishable from server URLs.\n\nModern HTML5 browsers were the first to support `pushState` which is why many people refer to these URLs as \"HTML5 style\" URLs.\n\nHELPFUL: HTML5 style navigation is the router default.\nIn the [LocationStrategy and browser URL styles](#locationstrategy-and-browser-url-styles) section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash \\(`#`\\) style, if necessary.\n\nYou must add a [`<base href>` element](https://developer.mozilla.org/docs/Web/HTML/Element/base 'base href') to the application's `index.html` for `pushState` routing to work.\nThe browser uses the `<base href>` value to prefix relative URLs when referencing CSS files, scripts, and images.\n\nAdd the `<base>` element just after the `<head>` tag.\nIf the `app` folder is the application root, as it is for this application, set the `href` value in `index.html` as shown here.\n\n<docs-code header=\"src/index.html (base-href)\" path=\"adev/src/content/examples/router/src/index.html\" visibleRegion=\"base-href\"/>\n\n### HTML5 URLs and the `<base href>`\n\nThe guidelines that follow will refer to different parts of a URL.\nThis diagram outlines what those parts refer to:\n\n<docs-code hideCopy language=\"text\">\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment\n</docs-code>\n\nWhile the router uses the [HTML5 pushState](https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries 'Browser history push-state') style by default, you must configure that strategy with a `<base href>`.\n\nThe preferred way to configure the strategy is to add a [`<base href>` element](https://developer.mozilla.org/docs/Web/HTML/Element/base 'base href') tag in the `<head>` of the `index.html`.\n\n```angular-html\n<base href=\"/\">\n```\n\nWithout that tag, the browser might not be able to load resources \\(images, CSS, scripts\\) when \"deep linking\" into the application.\n\nSome developers might not be able to add the `<base>` element, perhaps because they don't have access to `<head>` or the `index.html`.\n\nThose developers can still use HTML5 URLs by taking the following two steps:\n\n1. Provide the router with an appropriate `APP_BASE_HREF` value.\n1. Use root URLs \\(URLs with an `authority`\\) for all web resources: CSS, images, scripts, and template HTML files.\n\n   - The `<base href>` `path` should end with a \"/\", as browsers ignore characters in the `path` that follow the right-most \"`/`\"\n   - If the `<base href>` includes a `query` part, the `query` is only used if the `path` of a link in the page is empty and has no `query`.\n     This means that a `query` in the `<base href>` is only included when using `HashLocationStrategy`.\n\n   - If a link in the page is a root URL \\(has an `authority`\\), the `<base href>` is not used.\n     In this way, an `APP_BASE_HREF` with an authority will cause all links created by Angular to ignore the `<base href>` value.\n\n   - A fragment in the `<base href>` is _never_ persisted\n\nFor more complete information on how `<base href>` is used to construct target URIs, see the [RFC](https://tools.ietf.org/html/rfc3986#section-5.2.2) section on transforming references.\n\n### `HashLocationStrategy`\n\nUse `HashLocationStrategy` by providing the `useHash: true` in an object as the second argument of the `RouterModule.forRoot()` in the `AppModule`.\n\n```ts\nproviders: [\n  provideRouter(appRoutes, withHashLocation())\n]\n```\n\nWhen using `RouterModule.forRoot`, this is configured with the `useHash: true` in the second argument: `RouterModule.forRoot(routes, {useHash: true})`.\n\n\n\n================================================\n",
    "endLine": 14197
  },
  {
    "id": 69,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/routing/overview.md",
    "startLine": 14201,
    "content": "<docs-decorative-header title=\"Angular Routing\" imgSrc=\"adev/src/assets/images/routing.svg\"> <!-- markdownlint-disable-line -->\nRouting helps you change what the user sees in a single-page app.\n</docs-decorative-header>\n\nIn a single-page app, you change what the user sees by showing or hiding portions of the display that correspond to particular components, rather than going out to the server to get a new page.\n\nAs users perform application tasks, they need to move between the different views that you have defined.\n\nTo handle the navigation from one view to the next, you use the Angular **`Router`**.\nThe **`Router`** enables navigation by interpreting a browser URL as an instruction to change the view.\n\n## Learn about Angular routing\n\n<docs-card-container>\n  <docs-card title=\"Common routing tasks\" href=\"guide/routing/common-router-tasks\">\n    Learn how to implement many of the common tasks associated with Angular routing.\n  </docs-card>\n  <docs-card title=\"Routing SPA tutorial\" href=\"guide/routing/router-tutorial\">\n    A tutorial that covers patterns associated with Angular routing.\n  </docs-card>\n  <docs-card title=\"Creating custom route matches tutorial\" href=\"guide/routing/routing-with-urlmatcher\">\n    A tutorial that covers how to use custom matching strategy patterns with Angular routing.\n  </docs-card>\n  <docs-card title=\"Router reference\" href=\"guide/routing/router-reference\">\n    Describes some core router API concepts.\n  </docs-card>\n</docs-card-container>\n\n\n\n================================================\n",
    "endLine": 14230
  },
  {
    "id": 70,
    "file": "router-reference",
    "fullFileName": "adev/src/content/guide/routing/router-reference.md",
    "startLine": 14234,
    "content": "# Router reference\n\nThe following sections highlight some core router concepts.\n\n## Router imports\n\nThe Angular Router is an optional service that presents a particular component view for a given URL.\nIt isn't part of the Angular core and thus is in its own library package, `@angular/router`.\n\nImport what you need from it as you would from any other Angular package.\n\n```ts\nimport { provideRouter } from '@angular/router';\n```\n\nHELPFUL: For more on browser URL styles, see [`LocationStrategy` and browser URL styles](guide/routing/common-router-tasks#browser-url-styles).\n\n## Configuration\n\nA routed Angular application has one singleton instance of the `Router` service.\nWhen the browser's URL changes, that router looks for a corresponding `Route` from which it can determine the component to display.\n\nA router has no routes until you configure it.\nThe following example creates five route definitions, configures the router via the `provideRouter` method, and adds the result to the `providers` array of the `ApplicationConfig`'.\n\n```ts\nconst appRoutes: Routes = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'hero/:id',      component: HeroDetailComponent },\n  {\n    path: 'heroes',\n    component: HeroListComponent,\n    data: { title: 'Heroes List' }\n  },\n  { path: '',\n    redirectTo: '/heroes',\n    pathMatch: 'full'\n  },\n  { path: '**', component: PageNotFoundComponent }\n];\nexport const appConfig: ApplicationConfig = {\n    providers: [provideRouter(appRoutes, withDebugTracing())]\n}\n```\n\nThe `routes` array of routes describes how to navigate.\nPass it to the `provideRouter` method in the `ApplicationConfig` `providers` to configure the router.\n\nEach `Route` maps a URL `path` to a component.\nThere are no leading slashes in the path.\nThe router parses and builds the final URL for you, which lets you use both relative and absolute paths when navigating between application views.\n\nThe `:id` in the second route is a token for a route parameter.\nIn a URL such as `/hero/42`, \"42\" is the value of the `id` parameter.\nThe corresponding `HeroDetailComponent` uses that value to find and present the hero whose `id` is 42.\n\nThe `data` property in the third route is a place to store arbitrary data associated with this specific route.\nThe data property is accessible within each activated route.\nUse it to store items such as page titles, breadcrumb text, and other read-only, static data.\nUse the resolve guard to retrieve dynamic data.\n\nThe empty path in the fourth route represents the default path for the application —the place to go when the path in the URL is empty, as it typically is at the start.\nThis default route redirects to the route for the `/heroes` URL and, therefore, displays the `HeroesListComponent`.\n\nIf you need to see what events are happening during the navigation lifecycle, there is the `withDebugTracing` feature.\nThis outputs each router event that took place during each navigation lifecycle to the browser console.\nUse `withDebugTracing` only for debugging purposes.\nYou set the `withDebugTracing` option in the object passed as the second argument to the `provideRouter` method.\n\n## Router outlet\n\nThe `RouterOutlet` is a directive from the router library that is used like a component.\nIt acts as a placeholder that marks the spot in the template where the router should display the components for that outlet.\n\n<docs-code language=\"html\">\n\n<router-outlet></router-outlet>\n<!-- Routed components go here -->\n\n</docs-code>\n\nGiven the preceding configuration, when the browser URL for this application becomes `/heroes`, the router matches that URL to the route path `/heroes` and displays the `HeroListComponent` as a sibling element to the `RouterOutlet` that you've placed in the host component's template.\n\n## Router links\n\nTo navigate as a result of some user action such as the click of an anchor tag, use `RouterLink`.\n\nConsider the following template:\n\n<docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router/src/app/app.component.1.html\"/>\n\nThe `RouterLink` directives on the anchor tags give the router control over those elements.\nThe navigation paths are fixed, so you can assign a string as a one-time binding to the `routerLink`.\n\nHad the navigation path been more dynamic, you could have bound to a template expression that returned an array of route link parameters; that is, the [link parameters array](guide/routing/common-router-tasks#link-parameters-array).\nThe router resolves that array into a complete URL.\n\n## Active router links\n\nThe `RouterLinkActive` directive toggles CSS classes for active `RouterLink` bindings based on the current `RouterState`.\n\nOn each anchor tag, you see a [property binding](guide/templates/property-binding) to the `RouterLinkActive` directive that looks like\n\n<docs-code hideCopy language=\"html\">\n\nrouterLinkActive=\"...\"\n\n</docs-code>\n\nThe template expression to the right of the equal sign, `=`, contains a space-delimited string of CSS classes that the Router adds when this link is active and removes when the link is inactive.\nYou set the `RouterLinkActive` directive to a string of classes such as `routerLinkActive=\"active fluffy\"` or bind it to a component property that returns such a string.\nFor example,\n\n<docs-code hideCopy language=\"typescript\">\n\n[routerLinkActive]=\"someStringProperty\"\n\n</docs-code>\n\nActive route links cascade down through each level of the route tree, so parent and child router links can be active at the same time.\nTo override this behavior, bind to the `[routerLinkActiveOptions]` input binding with the `{ exact: true }` expression.\nBy using `{ exact: true }`, a given `RouterLink` is only active if its URL is an exact match to the current URL.\n\n`RouterLinkActive` also allows you to easily apply the `aria-current` attribute to the active element, thus providing a more accessible experience for all users. For more information see the Accessibility Best Practices [Active links identification section](/best-practices/a11y#active-links-identification).\n\n## Router state\n\nAfter the end of each successful navigation lifecycle, the router builds a tree of `ActivatedRoute` objects that make up the current state of the router.\nYou can access the current `RouterState` from anywhere in the application using the `Router` service and the `routerState` property.\n\nEach `ActivatedRoute` in the `RouterState` provides methods to traverse up and down the route tree to get information from parent, child, and sibling routes.\n\n## Activated route\n\nThe route path and parameters are available through an injected router service called the [ActivatedRoute](api/router/ActivatedRoute).\nIt has a great deal of useful information including:\n\n| Property        | Details |\n|:---             |:---     |\n| `url`           | An `Observable` of the route paths, represented as an array of strings for each part of the route path.                                                                                                                                                        |\n| `data`          | An `Observable` that contains the `data` object provided for the route. Also contains any resolved values from the resolve guard.                                                                                     |\n| `params`        | An `Observable` that contains the required and optional parameters specific to the route.                                                                                                                 |\n| `paramMap`      | An `Observable` that contains a [map](api/router/ParamMap) of the required and optional parameters specific to the route. The map supports retrieving single and multiple values from the same parameter. |\n| `queryParamMap` | An `Observable` that contains a [map](api/router/ParamMap) of the query parameters available to all routes. The map supports retrieving single and multiple values from the query parameter.                       |\n| `queryParams`   | An `Observable` that contains the query parameters available to all routes.                                                                                                                                        |\n| `fragment`      | An `Observable` of the URL fragment available to all routes.                                                                                                                                                               |\n| `outlet`        | The name of the `RouterOutlet` used to render the route. For an unnamed outlet, the outlet name is primary.                                                                                                                                                      |\n| `routeConfig`   | The route configuration used for the route that contains the origin path.                                                                                                                                                                                        |\n| `parent`        | The route's parent `ActivatedRoute` when this route is a child route.                                                                                                                                       |\n| `firstChild`    | Contains the first `ActivatedRoute` in the list of this route's child routes.                                                                                                                                                                                    |\n| `children`      | Contains all the child routes activated under the current route.                                                                                                                                            |\n\n## Router events\n\nDuring each navigation, the `Router` emits navigation events through the `Router.events` property.\nThese events are shown in the following table.\n\n| Router event                                              | Details |\n|:---                                                       |:---     |\n| [`NavigationStart`](api/router/NavigationStart)           | Triggered when navigation starts.                                                                                                                                                     |\n| [`RouteConfigLoadStart`](api/router/RouteConfigLoadStart) | Triggered before the `Router` lazy loads a route configuration.                                                                     |\n| [`RouteConfigLoadEnd`](api/router/RouteConfigLoadEnd)     | Triggered after a route has been lazy loaded.                                                                                                                                         |\n| [`RoutesRecognized`](api/router/RoutesRecognized)         | Triggered when the Router parses the URL and the routes are recognized.                                                                                                               |\n| [`GuardsCheckStart`](api/router/GuardsCheckStart)         | Triggered when the Router begins the Guards phase of routing.                                                                                                                         |\n| [`ChildActivationStart`](api/router/ChildActivationStart) | Triggered when the Router begins activating a route's children.                                                                                                                       |\n| [`ActivationStart`](api/router/ActivationStart)           | Triggered when the Router begins activating a route.                                                                                                                                  |\n| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)             | Triggered when the Router finishes the Guards phase of routing successfully.                                                                                                          |\n| [`ResolveStart`](api/router/ResolveStart)                 | Triggered when the Router begins the Resolve phase of routing.                                                                                                                        |\n| [`ResolveEnd`](api/router/ResolveEnd)                     | Triggered when the Router finishes the Resolve phase of routing successfully.                                                                                                          |\n| [`ChildActivationEnd`](api/router/ChildActivationEnd)     | Triggered when the Router finishes activating a route's children.                                                                                                                     |\n| [`ActivationEnd`](api/router/ActivationEnd)               | Triggered when the Router finishes activating a route.                                                                                                                                |\n| [`NavigationEnd`](api/router/NavigationEnd)               | Triggered when navigation ends successfully.                                                                                                                                          |\n| [`NavigationCancel`](api/router/NavigationCancel)         | Triggered when navigation is canceled. This can happen when a Route Guard returns false during navigation, or redirects by returning a `UrlTree` or `RedirectCommand`. |\n| [`NavigationError`](api/router/NavigationError)           | Triggered when navigation fails due to an unexpected error.                                                                                                                           |\n| [`Scroll`](api/router/Scroll)                             | Represents a scrolling event.                                                                                                                                                         |\n\nWhen you enable the `withDebugTracing` feature, Angular logs these events to the console.\n\n## Router terminology\n\nHere are the key `Router` terms and their meanings:\n\n| Router part           | Details |\n|:---                   |:---     |\n| `Router`              | Displays the application component for the active URL. Manages navigation from one component to the next.                                                                                        |\n| `provideRouter`       | provides the necessary service providers for navigating through application views.                                                                                        |\n| `RouterModule`        | A separate NgModule that provides the necessary service providers and directives for navigating through application views.                                                                       |\n| `Routes`              | Defines an array of Routes, each mapping a URL path to a component.                                                                                                                              |\n| `Route`               | Defines how the router should navigate to a component based on a URL pattern. Most routes consist of a path and a component type.                                                                |\n| `RouterOutlet`        | The directive \\(`<router-outlet>`\\) that marks where the router displays a view.                                                                                                                 |\n| `RouterLink`          | The directive for binding a clickable HTML element to a route. Clicking an element with a `routerLink` directive that's bound to a *string* or a *link parameters array* triggers a navigation. |\n| `RouterLinkActive`    | The directive for adding/removing classes from an HTML element when an associated `routerLink` contained on or inside the element becomes active/inactive. It can also set the `aria-current` of an active link for better accessibility.                                       |\n| `ActivatedRoute`      | A service that's provided to each route component that contains route specific information such as route parameters, static data, resolve data, global query parameters, and the global fragment.   |\n| `RouterState`         | The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.                                              |\n| Link parameters array | An array that the router interprets as a routing instruction. You can bind that array to a `RouterLink` or pass the array as an argument to the `Router.navigate` method.                        |\n| Routing component     | An Angular component with a `RouterOutlet` that displays views based on router navigations.                                                                                                      |\n\n\n\n================================================\n",
    "endLine": 14432
  },
  {
    "id": 71,
    "file": "router-tutorial",
    "fullFileName": "adev/src/content/guide/routing/router-tutorial.md",
    "startLine": 14436,
    "content": "# Using Angular routes in a single-page application\n\nThis tutorial describes how to build a single-page application, SPA that uses multiple Angular routes.\n\nIn a Single Page Application \\(SPA\\), all of your application's functions exist in a single HTML page.\nAs users access your application's features, the browser needs to render only the parts that matter to the user, instead of loading a new page.\nThis pattern can significantly improve your application's user experience.\n\nTo define how users navigate through your application, you use routes.\nAdd routes to define how users navigate from one part of your application to another.\nYou can also configure routes to guard against unexpected or unauthorized behavior.\n\n## Objectives\n\n* Organize a sample application's features into modules.\n* Define how to navigate to a component.\n* Pass information to a component using a parameter.\n* Structure routes by nesting several routes.\n* Check whether users can access a route.\n* Control whether the application can discard unsaved changes.\n* Improve performance by pre-fetching route data and lazy loading feature modules.\n* Require specific criteria to load components.\n\n## Create a sample application\n\nUsing the Angular CLI, create a new application, *angular-router-sample*.\nThis application will have two components: *crisis-list* and *heroes-list*.\n\n1. Create a new Angular project, *angular-router-sample*.\n\n    <docs-code language=\"shell\">\n    ng new angular-router-sample\n    </docs-code>\n\n    When prompted with `Would you like to add Angular routing?`, select `N`.\n\n    When prompted with `Which stylesheet format would you like to use?`, select `CSS`.\n\n    After a few moments, a new project, `angular-router-sample`, is ready.\n\n1. From your terminal, navigate to the `angular-router-sample` directory.\n1. Create a component, *crisis-list*.\n\n    <docs-code language=\"shell\">\n    ng generate component crisis-list\n    </docs-code>\n\n1. In your code editor, locate the file, `crisis-list.component.html` and replace the placeholder content with the following HTML.\n\n    <docs-code header=\"src/app/crisis-list/crisis-list.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/crisis-list/crisis-list.component.html\"/>\n\n1. Create a second component, *heroes-list*.\n\n    <docs-code language=\"shell\">\n    ng generate component heroes-list\n    </docs-code>\n\n1. In your code editor, locate the file, `heroes-list.component.html` and replace the placeholder content with the following HTML.\n\n    <docs-code header=\"src/app/heroes-list/heroes-list.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/heroes-list/heroes-list.component.html\"/>\n\n1. In your code editor, open the file, `app.component.html` and replace its contents with the following HTML.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.html\" visibleRegion=\"setup\"/>\n\n1. Verify that your new application runs as expected by running the `ng serve` command.\n\n    <docs-code language=\"shell\">\n    ng serve\n    </docs-code>\n\n1. Open a browser to `http://localhost:4200`.\n\n    You should see a single web page, consisting of a title and the HTML of your two components.\n\n## Define your routes\n\nIn this section, you'll define two routes:\n\n* The route `/crisis-center` opens the `crisis-center` component.\n* The route `/heroes-list` opens the `heroes-list` component.\n\nA route definition is a JavaScript object.\nEach route typically has two properties.\nThe first property, `path`, is a string that specifies the URL path for the route.\nThe second property, `component`, is a string that specifies what component your application should display for that path.\n\n1. From your code editor, create and open the `app.routes.ts` file.\n1. Create and export a routes list for your application:\n\n    ```ts\n    import {Routes} from '@angular/router';\n\n    export const routes = [];\n    ```\n\n1. Add two routes for your first two components:\n\n    ```ts\n    {path: 'crisis-list', component: CrisisListComponent},\n    {path: 'heroes-list', component: HeroesListComponent},\n    ```\n\nThis routes list is an array of JavaScript objects, with each object defining the properties of a route.\n\n## Import `provideRouter` from `@angular/router`\n\nRouting lets you display specific views of your application depending on the URL path.\nTo add this functionality to your sample application, you need to update the `app.config.ts` file to use the router providers function, `provideRouter`.\nYou import this provider function from `@angular/router`.\n\n1. From your code editor, open the `app.config.ts` file.\n1. Add the following import statements:\n\n    ```ts\n    import { provideRouter } from '@angular/router';\n    import { routes } from './app.routes';\n    ```\n\n1. Update the providers in the `appConfig`:\n\n    ```ts\n    providers: [provideRouter(routes)]\n    ```\n\nFor `NgModule` based applications, put the `provideRouter` in the `providers` list of the `AppModule`, or whichever module is passed to `bootstrapModule` in the application.\n\n## Update your component with `router-outlet`\n\nAt this point, you have defined two routes for your application.\nHowever, your application still has both the `crisis-list` and `heroes-list` components hard-coded in your `app.component.html` template.\nFor your routes to work, you need to update your template to dynamically load a component based on the URL path.\n\nTo implement this functionality, you add the `router-outlet` directive to your template file.\n\n1. From your code editor, open the `app.component.html` file.\n1. Delete the following lines.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.html\" visibleRegion=\"components\"/>\n\n1. Add the `router-outlet` directive.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.html\" visibleRegion=\"router-outlet\"/>\n\n1. Add `RouterOutlet` to the imports of the `AppComponent` in `app.component.ts`\n\n    ```ts\n    imports: [RouterOutlet],\n    ```\n\nView your updated application in your browser.\nYou should see only the application title.\nTo view the `crisis-list` component, add `crisis-list` to the end of the path in your browser's address bar.\nFor example:\n\n<docs-code language=\"http\">\nhttp://localhost:4200/crisis-list\n</docs-code>\n\nNotice that the `crisis-list` component displays.\nAngular is using the route you defined to dynamically load the component.\nYou can load the `heroes-list` component the same way:\n\n<docs-code language=\"http\">\nhttp://localhost:4200/heroes-list\n</docs-code>\n\n## Control navigation with UI elements\n\nCurrently, your application supports two routes.\nHowever, the only way to use those routes is for the user to manually type the path in the browser's address bar.\nIn this section, you'll add two links that users can click to navigate between the `heroes-list` and `crisis-list` components.\nYou'll also add some CSS styles.\nWhile these styles are not required, they make it easier to identify the link for the currently-displayed component.\nYou'll add that functionality in the next section.\n\n1. Open the `app.component.html` file and add the following HTML below the title.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.html\" visibleRegion=\"nav\"/>\n\n    This HTML uses an Angular directive, `routerLink`.\n    This directive connects the routes you defined to your template files.\n\n1. Add the `RouterLink` directive to the imports list of `AppComponent` in `app.component.ts`.\n\n1. Open the `app.component.css` file and add the following styles.\n\n    <docs-code header=\"src/app/app.component.css\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.css\"/>\n\nIf you view your application in the browser, you should see these two links.\nWhen you click on a link, the corresponding component appears.\n\n## Identify the active route\n\nWhile users can navigate your application using the links you added in the previous section, they don't have a straightforward way to identify what the active route is.\nAdd this functionality using Angular's `routerLinkActive` directive.\n\n1. From your code editor, open the `app.component.html` file.\n1. Update the anchor tags to include the `routerLinkActive` directive.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/app.component.html\" visibleRegion=\"routeractivelink\"/>\n1. Add the `RouterLinkActive` directive to the `imports` list of `AppComponent` in `app.component.ts`.\n\nView your application again.\nAs you click one of the buttons, the style for that button updates automatically, identifying the active component to the user.\nBy adding the `routerLinkActive` directive, you inform your application to apply a specific CSS class to the active route.\nIn this tutorial, that CSS class is `activebutton`, but you could use any class that you want.\n\nNote that we are also specifying a value for the `routerLinkActive`'s `ariaCurrentWhenActive`. This makes sure that visually impaired users (which may not perceive the different styling being applied) can also identify the active button. For more information see the Accessibility Best Practices [Active links identification section](/best-practices/a11y#active-links-identification).\n\n## Adding a redirect\n\nIn this step of the tutorial, you add a route that redirects the user to display the `/heroes-list` component.\n\n1. From your code editor, open the `app.routes.ts` file.\n1. Update the `routes` section as follows.\n\n    ```ts\n    {path: '', redirectTo: '/heroes-list', pathMatch: 'full'},\n    ```\n\n    Notice that this new route uses an empty string as its path.\n    In addition, it replaces the `component` property with two new ones:\n\n    | Properties   | Details |\n    |:---        |:---    |\n    | `redirectTo` | This property instructs Angular to redirect from an empty path to the `heroes-list` path.                                                                                                                                                       |\n    | `pathMatch`  | This property instructs Angular on how much of the URL to match. For this tutorial, you should set this property to `full`. This strategy is recommended when you have an empty string for a path. For more information about this property, see the [Route API documentation](api/router/Route). |\n\nNow when you open your application, it displays the `heroes-list` component by default.\n\n## Adding a 404 page\n\nIt is possible for a user to try to access a route that you have not defined.\nTo account for this behavior, the best practice is to display a 404 page.\nIn this section, you'll create a 404 page and update your route configuration to show that page for any unspecified routes.\n\n1. From the terminal, create a new component, `PageNotFound`.\n\n    <docs-code language=\"shell\">\n    ng generate component page-not-found\n    </docs-code>\n\n1. From your code editor, open the `page-not-found.component.html` file and replace its contents with the following HTML.\n\n    <docs-code header=\"src/app/page-not-found/page-not-found.component.html\" path=\"adev/src/content/examples/router-tutorial/src/app/page-not-found/page-not-found.component.html\"/>\n\n1. Open the `app.routes.ts` file and add the following route to the routes list:\n\n    ```ts\n    {path: '**', component: PageNotFoundComponent}\n    ```\n\n    The new route uses a path, `**`.\n    This path is how Angular identifies a wildcard route.\n    Any route that does not match an existing route in your configuration will use this route.\n\nIMPORTANT: Notice that the wildcard route is placed at the end of the array.\nThe order of your routes is important, as Angular applies routes in order and uses the first match it finds.\n\nTry navigating to a non-existing route on your application, such as `http://localhost:4200/powers`.\nThis route doesn't match anything defined in your `app.routes.ts` file.\nHowever, because you defined a wildcard route, the application automatically displays your `PageNotFound` component.\n\n## Next steps\n\nAt this point, you have a basic application that uses Angular's routing feature to change what components the user can see based on the URL address.\nYou have extended these features to include a redirect, as well as a wildcard route to display a custom 404 page.\n\nFor more information about routing, see the following topics:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/routing/common-router-tasks\" title=\"In-app Routing and Navigation\"/>\n  <docs-pill href=\"api/router/Router\" title=\"Router API\"/>\n</docs-pill-row>\n\n\n\n================================================\n",
    "endLine": 14713
  },
  {
    "id": 72,
    "file": "routing-with-urlmatcher",
    "fullFileName": "adev/src/content/guide/routing/routing-with-urlmatcher.md",
    "startLine": 14717,
    "content": "# Creating custom route matches\n\nThe Angular Router supports a powerful matching strategy that you can use to help users navigate your application.\nThis matching strategy supports static routes, variable routes with parameters, wildcard routes, and so on.\nAlso, build your own custom pattern matching for situations in which the URLs are more complicated.\n\nIn this tutorial, you'll build a custom route matcher using Angular's `UrlMatcher`.\nThis matcher looks for a Twitter handle in the URL.\n\n## Objectives\n\nImplement Angular's `UrlMatcher` to create a custom route matcher.\n\n## Create a sample application\n\nUsing the Angular CLI, create a new application, *angular-custom-route-match*.\nIn addition to the default Angular application framework, you will also create a *profile* component.\n\n1. Create a new Angular project, *angular-custom-route-match*.\n\n    ```shell\n    ng new angular-custom-route-match\n    ```\n\n    When prompted with `Would you like to add Angular routing?`, select `Y`.\n\n    When prompted with `Which stylesheet format would you like to use?`, select `CSS`.\n\n    After a few moments, a new project, `angular-custom-route-match`, is ready.\n\n1. From your terminal, navigate to the `angular-custom-route-match` directory.\n1. Create a component, *profile*.\n\n    ```shell\n    ng generate component profile\n    ```\n\n1. In your code editor, locate the file, `profile.component.html` and replace the placeholder content with the following HTML.\n\n    <docs-code header=\"src/app/profile/profile.component.html\" path=\"adev/src/content/examples/routing-with-urlmatcher/src/app/profile/profile.component.html\"/>\n\n1. In your code editor, locate the file, `app.component.html` and replace the placeholder content with the following HTML.\n\n    <docs-code header=\"src/app/app.component.html\" path=\"adev/src/content/examples/routing-with-urlmatcher/src/app/app.component.html\"/>\n\n## Configure your routes for your application\n\nWith your application framework in place, you next need to add routing capabilities to the `app.config.ts` file.\nAs a part of this process, you will create a custom URL matcher that looks for a Twitter handle in the URL.\nThis handle is identified by a preceding `@` symbol.\n\n1. In your code editor, open your `app.config.ts` file.\n1. Add an `import` statement for Angular's `provideRouter` and `withComponentInputBinding` as well as the application routes.\n\n    ```ts\n    import {provideRouter, withComponentInputBinding} from '@angular/router';\n\n    import {routes} from './app.routes';\n    ```\n\n1. In the providers array, add a `provideRouter(routes, withComponentInputBinding())` statement.\n\n1. Define the custom route matcher by adding the following code to the application routes.\n\n    <docs-code header=\"src/app/app.routes.ts\" path=\"adev/src/content/examples/routing-with-urlmatcher/src/app/app.routes.ts\" visibleRegion=\"matcher\"/>\n\nThis custom matcher is a function that performs the following tasks:\n\n* The matcher verifies that the array contains only one segment\n* The matcher employs a regular expression to ensure that the format of the username is a match\n* If there is a match, the function returns the entire URL, defining a `username` route parameter as a substring of the path\n* If there isn't a match, the function returns null and the router continues to look for other routes that match the URL\n\nHELPFUL: A custom URL matcher behaves like any other route definition. Define child routes or lazy loaded routes as you would with any other route.\n\n## Reading the route parameters\n\nWith the custom matcher in place, you can now bind the route parameter in the `profile` component.\n\nIn your code editor, open your `profile.component.ts` file and create an `Input` matching the `username` parameter.\nWe added the `withComponentInputBinding` feature earlier\nin `provideRouter`. This allows the `Router` to bind information directly to the route components.\n\n```ts\n@Input() username!: string;\n```\n\n## Test your custom URL matcher\n\nWith your code in place, you can now test your custom URL matcher.\n\n1. From a terminal window, run the `ng serve` command.\n\n    <docs-code language=\"shell\">\n    ng serve\n    </docs-code>\n\n1. Open a browser to `http://localhost:4200`.\n\n    You should see a single web page, consisting of a sentence that reads `Navigate to my profile`.\n\n1. Click the **my profile** hyperlink.\n\n    A new sentence, reading `Hello, Angular!` appears on the page.\n\n## Next steps\n\nPattern matching with the Angular Router provides you with a lot of flexibility when you have dynamic URLs in your application.\nTo learn more about the Angular Router, see the following topics:\n\n<docs-pill-row>\n  <docs-pill href=\"guide/routing/common-router-tasks\" title=\"In-app Routing and Navigation\"/>\n  <docs-pill href=\"api/router/Router\" title=\"Router API\"/>\n</docs-pill-row>\n\nHELPFUL: This content is based on [Custom Route Matching with the Angular Router](https://medium.com/@brandontroberts/custom-route-matching-with-the-angular-router-fbdd48665483), by [Brandon Roberts](https://twitter.com/brandontroberts).\n\n\n\n================================================\nFILE: adev/src/content/guide/signals/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"signals\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:signals.svg\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 14853
  },
  {
    "id": 73,
    "file": "linked-signal",
    "fullFileName": "adev/src/content/guide/signals/linked-signal.md",
    "startLine": 14857,
    "content": "# Dependent state with `linkedSignal`\n\nYou can use the `signal` function to hold some state in your Angular code. Sometimes, this state depends on some _other_ state. For example, imagine a component that lets the user select a shipping method for an order:\n\n```typescript\n@Component({/* ... */})\nexport class ShippingMethodPicker {\n  shippingOptions: Signal<ShippingMethod[]> = getShippingOptions();\n\n  // Select the first shipping option by default.\n  selectedOption = signal(this.shippingOptions()[0]);\n\n  changeShipping(newOptionIndex: number) {\n    this.selectedOption.set(this.shippingOptions()[newOptionIndex]);\n  }\n}\n```\n\nIn this example, the `selectedOption` defaults to the first option, but changes if the user selects another option. But `shippingOptions` is a signal— its value may change! If `shippingOptions` changes, `selectedOption` may contain a value that is no longer a valid option.\n\n**The `linkedSignal` function lets you create a signal to hold some state that is intrinsically _linked_ to some other state.** Revisiting the example above, `linkedSignal` can replace `signal`:\n\n```typescript\n@Component({/* ... */})\nexport class ShippingMethodPicker {\n  shippingOptions: Signal<ShippingMethod[]> = getShippingOptions();\n\n  // Initialize selectedOption to the first shipping option.\n  selectedOption = linkedSignal(() => this.shippingOptions()[0]);\n\n  changeShipping(index: number) {\n    this.selectedOption.set(this.shippingOptions()[index]);\n  }\n}\n```\n\n`linkedSignal` works similarly to `signal` with one key difference— instead of passing a default value, you pass a _computation function_, just like `computed`. When the value of the computation changes, the value of the `linkedSignal` changes to the computation result. This helps ensure that the `linkedSignal` always has a valid value.\n\nThe following example shows how the value of a `linkedSignal` can change based on its linked state:\n\n```typescript\nconst shippingOptions = signal(['Ground', 'Air', 'Sea']);\nconst selectedOption = linkedSignal(() => shippingOptions()[0]);\nconsole.log(selectedOption()); // 'Ground'\n\nselectedOption.set(shippingOptions()[2]);\nconsole.log(selectedOption()); // 'Sea'\n\nshippingOptions.set(['Email', 'Will Call', 'Postal service']);\nconsole.log(selectedOption()); // 'Email'\n```\n\n## Accounting for previous state\n\nIn some cases, the computation for a `linkedSignal` needs to account for the previous value of the `linkedSignal`.\n\nIn the example above, `selectedOption` always updates back to the first option when `shippingOptions` changes. You may, however, want to preserve the user's selection if their selected option is still somewhere in the list. To accomplish this, you can create a `linkedSignal` with a separate _source_ and _computation_:\n\n```typescript\ninterface ShippingMethod {\n  id: number;\n  name: string;\n}\n\n@Component({/* ... */})\nexport class ShippingMethodPicker {\n  constructor() {\n    this.changeShipping(2);\n    this.changeShippingOptions();\n    console.log(this.selectedOption()); // {\"id\":2,\"name\":\"Postal Service\"}\n  }\n\n  shippingOptions = signal<ShippingMethod[]>([\n    { id: 0, name: 'Ground' },\n    { id: 1, name: 'Air' },\n    { id: 2, name: 'Sea' },\n  ]);\n\n  selectedOption = linkedSignal<ShippingMethod[], ShippingMethod>({\n    // `selectedOption` is set to the `computation` result whenever this `source` changes.\n    source: this.shippingOptions,\n    computation: (newOptions, previous) => {\n      // If the newOptions contain the previously selected option, preserve that selection.\n      // Otherwise, default to the first option.\n      return (\n        newOptions.find((opt) => opt.id === previous?.value.id) ?? newOptions[0]\n      );\n    },\n  });\n\n  changeShipping(index: number) {\n    this.selectedOption.set(this.shippingOptions()[index]);\n  }\n\n  changeShippingOptions() {\n    this.shippingOptions.set([\n      { id: 0, name: 'Email' },\n      { id: 1, name: 'Sea' },\n      { id: 2, name: 'Postal Service' },\n    ]);\n  }\n}\n```\n\nWhen you create a `linkedSignal`, you can pass an object with separate `source` and `computation` properties instead of providing just a computation.\n\nThe `source` can be any signal, such as a `computed` or component `input`. When the value of `source` changes, `linkedSignal` updates its value to the result of the provided `computation`.\n\nThe `computation` is a function that receives the new value of `source` and a `previous` object. The `previous` object has two properties— `previous.source` is the previous value of `source`, and `previous.value` is the previous result of the `computation`. You can use these previous values to decide the new result of the computation.\n\n## Custom equality comparison\n\n`linkedSignal`, as any other signal, can be configured with a custom equality function. This function is used by downstream dependencies to determine if that value of the `linkedSignal` (result of a computation) changed:\n\n```typescript\nconst activeUser = signal({id: 123, name: 'Morgan', isAdmin: true});\n\nconst activeUserEditCopy = linkedSignal(() => activeUser(), {\n  // Consider the user as the same if it's the same `id`.\n  equal: (a, b) => a.id === b.id,\n});\n\n// Or, if separating `source` and `computation`\nconst activeUserEditCopy = linkedSignal({\n  source: activeUser,\n  computation: user => user,\n  equal: (a, b) => a.id === b.id,\n});\n```\n\n\n\n================================================\n",
    "endLine": 14988
  },
  {
    "id": 74,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/signals/overview.md",
    "startLine": 14992,
    "content": "<docs-decorative-header title=\"Angular Signals\" imgSrc=\"adev/src/assets/images/signals.svg\"> <!-- markdownlint-disable-line -->\nAngular Signals is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize rendering updates.\n</docs-decorative-header>\n\nTIP: Check out Angular's [Essentials](essentials/signals) before diving into this comprehensive guide.\n\n## What are signals?\n\nA **signal** is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.\n\nYou read a signal's value by calling its getter function, which allows Angular to track where the signal is used.\n\nSignals may be either _writable_ or _read-only_.\n\n### Writable signals\n\nWritable signals provide an API for updating their values directly. You create writable signals by calling the `signal` function with the signal's initial value:\n\n```ts\nconst count = signal(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n```\n\nTo change the value of a writable signal, either `.set()` it directly:\n\n```ts\ncount.set(3);\n```\n\nor use the `.update()` operation to compute a new value from the previous one:\n\n```ts\n// Increment the count by 1.\ncount.update(value => value + 1);\n```\n\nWritable signals have the type `WritableSignal`.\n\n### Computed signals\n\n**Computed signal** are read-only signals that derive their value from other signals. You define computed signals using the `computed` function and specifying a derivation:\n\n```typescript\nconst count: WritableSignal<number> = signal(0);\nconst doubleCount: Signal<number> = computed(() => count() * 2);\n```\n\nThe `doubleCount` signal depends on the `count` signal. Whenever `count` updates, Angular knows that `doubleCount` needs to update as well.\n\n#### Computed signals are both lazily evaluated and memoized\n\n`doubleCount`'s derivation function does not run to calculate its value until the first time you read `doubleCount`. The calculated value is then cached, and if you read `doubleCount` again, it will return the cached value without recalculating.\n\nIf you then change `count`, Angular knows that `doubleCount`'s cached value is no longer valid, and the next time you read `doubleCount` its new value will be calculated.\n\nAs a result, you can safely perform computationally expensive derivations in computed signals, such as filtering arrays.\n\n#### Computed signals are not writable signals\n\nYou cannot directly assign values to a computed signal. That is,\n\n```ts\ndoubleCount.set(3);\n```\n\nproduces a compilation error, because `doubleCount` is not a `WritableSignal`.\n\n#### Computed signal dependencies are dynamic\n\nOnly the signals actually read during the derivation are tracked. For example, in this `computed` the `count` signal is only read if the `showCount` signal is true:\n\n```ts\nconst showCount = signal(false);\nconst count = signal(0);\nconst conditionalCount = computed(() => {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n```\n\nWhen you read `conditionalCount`, if `showCount` is `false` the \"Nothing to see here!\" message is returned _without_ reading the `count` signal. This means that if you later update `count` it will _not_ result in a recomputation of `conditionalCount`.\n\nIf you set `showCount` to `true` and then read `conditionalCount` again, the derivation will re-execute and take the branch where `showCount` is `true`, returning the message which shows the value of `count`. Changing `count` will then invalidate `conditionalCount`'s cached value.\n\nNote that dependencies can be removed during a derivation as well as added. If you later set `showCount` back to `false`, then `count` will no longer be considered a dependency of `conditionalCount`.\n\n## Reading signals in `OnPush` components\n\nWhen you read a signal within an `OnPush` component's template, Angular tracks the signal as a dependency of that component. When the value of that signal changes, Angular automatically [marks](api/core/ChangeDetectorRef#markforcheck) the component to ensure it gets updated the next time change detection runs. Refer to the [Skipping component subtrees](best-practices/skipping-subtrees) guide for more information about `OnPush` components.\n\n## Effects\n\nSignals are useful because they notify interested consumers when they change. An **effect** is an operation that runs whenever one or more signal values change. You can create an effect with the `effect` function:\n\n```ts\neffect(() => {\n  console.log(`The current count is: ${count()}`);\n});\n```\n\nEffects always run **at least once.** When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals which were read in the most recent execution.\n\nEffects always execute **asynchronously**, during the change detection process.\n\n### Use cases for effects\n\nEffects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an `effect` might be a good solution:\n\n- Logging data being displayed and when it changes, either for analytics or as a debugging tool.\n- Keeping data in sync with `window.localStorage`.\n- Adding custom DOM behavior that can't be expressed with template syntax.\n- Performing custom rendering to a `<canvas>`, charting library, or other third party UI library.\n\n<docs-callout critical title=\"When not to use effects\">\nAvoid using effects for propagation of state changes. This can result in `ExpressionChangedAfterItHasBeenChecked` errors, infinite circular updates, or unnecessary change detection cycles.\n\nInstead, use `computed` signals to model state that depends on other state.\n</docs-callout>\n\n### Injection context\n\nBy default, you can only create an `effect()` within an [injection context](guide/di/dependency-injection-context) (where you have access to the `inject` function). The easiest way to satisfy this requirement is to call `effect` within a component, directive, or service `constructor`:\n\n```ts\n@Component({...})\nexport class EffectiveCounterComponent {\n  readonly count = signal(0);\n  constructor() {\n    // Register a new effect.\n    effect(() => {\n      console.log(`The count is: ${this.count()}`);\n    });\n  }\n}\n```\n\nAlternatively, you can assign the effect to a field (which also gives it a descriptive name).\n\n```ts\n@Component({...})\nexport class EffectiveCounterComponent {\n  readonly count = signal(0);\n\n  private loggingEffect = effect(() => {\n    console.log(`The count is: ${this.count()}`);\n  });\n}\n```\n\nTo create an effect outside the constructor, you can pass an `Injector` to `effect` via its options:\n\n```ts\n@Component({...})\nexport class EffectiveCounterComponent {\n  readonly count = signal(0);\n  private injector = inject(Injector);\n\n  initializeLogging(): void {\n    effect(() => {\n      console.log(`The count is: ${this.count()}`);\n    }, {injector: this.injector});\n  }\n}\n```\n\n### Destroying effects\n\nWhen you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc.\n\nEffects return an `EffectRef` that you can use to destroy them manually, by calling the `.destroy()` method. You can combine this with the `manualCleanup` option to create an effect that lasts until it is manually destroyed. Be careful to actually clean up such effects when they're no longer required.\n\n## Advanced topics\n\n### Signal equality functions\n\nWhen creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one.\n\n```ts\nimport _ from 'lodash';\n\nconst data = signal(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the signal won't\n// trigger any updates.\ndata.set(['test']);\n```\n\nEquality functions can be provided to both writable and computed signals.\n\nHELPFUL: By default, signals use referential equality ([`Object.is()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison).\n\n### Reading without tracking dependencies\n\nRarely, you may want to execute code which may read signals within a reactive function such as `computed` or `effect` _without_ creating a dependency.\n\nFor example, suppose that when `currentUser` changes, the value of a `counter` should be logged. you could create an `effect` which reads both signals:\n\n```ts\neffect(() => {\n  console.log(`User set to ${currentUser()} and the counter is ${counter()}`);\n});\n```\n\nThis example will log a message when _either_ `currentUser` or `counter` changes. However, if the effect should only run when `currentUser` changes, then the read of `counter` is only incidental and changes to `counter` shouldn't log a new message.\n\nYou can prevent a signal read from being tracked by calling its getter with `untracked`:\n\n```ts\neffect(() => {\n  console.log(`User set to ${currentUser()} and the counter is ${untracked(counter)}`);\n});\n```\n\n`untracked` is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency:\n\n```ts\neffect(() => {\n  const user = currentUser();\n  untracked(() => {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n```\n\n### Effect cleanup functions\n\nEffects might start long-running operations, which you should cancel if the effect is destroyed or runs again before the first operation finished. When you create an effect, your function can optionally accept an `onCleanup` function as its first parameter. This `onCleanup` function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed.\n\n```ts\neffect((onCleanup) => {\n  const user = currentUser();\n\n  const timer = setTimeout(() => {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() => {\n    clearTimeout(timer);\n  });\n});\n```\n\n## Using signals with RxJS\n\nSee [RxJS interop with Angular signals](ecosystem/rxjs-interop) for details on interoperability between signals and RxJS.\n\n\n\n================================================\n",
    "endLine": 15247
  },
  {
    "id": 75,
    "file": "resource",
    "fullFileName": "adev/src/content/guide/signals/resource.md",
    "startLine": 15251,
    "content": "# Async reactivity with resources\n\nIMPORTANT: `resource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n\nMost signal APIs are synchronous— `signal`, `computed`, `input`, etc. However, applications often need to deal with data that is available asynchronously. A `Resource` gives you a way to incorporate async data into your application's signal-based code.\n\nYou can use a `Resource` to perform any kind of async operation, but the most common use-case for `Resource` is fetching data from a server. The following example creates a resource to fetch some user data.\n\nThe easiest way to create a `Resource` is the `resource` function.\n\n```typescript\nimport {resource, Signal} from '@angular/core';\n\nconst userId: Signal<string> = getUserId();\n\nconst userResource = resource({\n  // Define a reactive request computation.\n  // The request value recomputes whenever any read signals change.\n  request: () => ({id: userId()}),\n\n  // Define an async loader that retrieves data.\n  // The resource calls this function every time the `request` value changes.\n  loader: ({request}) => fetchUser(request),\n});\n\n// Create a computed signal based on the result of the resource's loader function.\nconst firstName = computed(() => userResource.value().firstName);\n```\n\nThe `resource` function accepts a `ResourceOptions` object with two main properties: `request` and `loader`.\n\nThe `request` property defines a reactive computation that produce a request value. Whenever signals read in this computation change, the resource produces a new request value, similar to `computed`.\n\nThe `loader` property defines a `ResourceLoader`— an async function that retrieves some state. The resource calls the loader every time the `request` computation produces a new value, passing that value to the loader. See [Resource loaders](#resource-loaders) below for more details.\n\n`Resource` has a `value` signal that contains the results of the loader.\n\n## Resource loaders\n\nWhen creating a resource, you specify a `ResourceLoader`. This loader is an async function that accepts a single parameter— a `ResourceLoaderParams` object— and returns a value.\n\nThe `ResourceLoaderParams` object contains three properties: `request`, `previous`, and `abortSignal`.\n\n| Property      | Description                                                                                                                                      |\n| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `request`     | The value of the resource's `request` computation.                                                                                               |\n| `previous`    | An object with a `status` property, containing the previous `ResourceStatus`.                                                                    |\n| `abortSignal` | An [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal). See [Aborting requests](#aborting-requests) below for details. |\n\n\nIf the `request` computation returns `undefined`, the loader function does not run and the resource status becomes `Idle`.\n\n### Aborting requests\n\nA resource aborts an outstanding request if the `request` computation changes while the resource is loading.\n\nYou can use the `abortSignal` in `ResourceLoaderParams` to respond to aborted requests. For example, the native `fetch` function accepts an `AbortSignal`:\n\n```typescript\nconst userId: Signal<string> = getUserId();\n\nconst userResource = resource({\n  request: () => ({id: userId()}),\n  loader: ({request, abortSignal}): Promise<User> => {\n    // fetch cancels any outstanding HTTP requests when the given `AbortSignal`\n    // indicates that the request has been aborted.\n    return fetch(`users/${request.id}`, {signal: abortSignal});\n  },\n});\n```\n\nSee [`AbortSignal` on MDN](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for more details on request cancellation with `AbortSignal`.\n\n### Reloading\n\nYou can programmatically trigger a resource's `loader` by calling the `reload` method.\n\n```typescript\nconst userId: Signal<string> = getUserId();\n\nconst userResource = resource({\n  request: () => ({id: userId()}),\n  loader: ({request}) => fetchUser(request),\n});\n\n// ...\n\nuserResource.reload();\n```\n\n## Resource status\n\nThe resource object has several signal properties for reading the status of the asynchronous loader.\n\n| Property    | Description                                                                                                     |\n| ----------- | --------------------------------------------------------------------------------------------------------------- |\n| `value`     | The most recent value of the resource, or `undefined` if no value has been received.                            |\n| `hasValue`  | Whether the resource has a value.                                                                               |\n| `error`     | The most recent error encountered while running the resource's loader, or `undefined` if no error has occurred. |\n| `isLoading` | Whether the resource loader is currently running.                                                               |\n| `status`    | The resource's specific `ResourceStatus`, as described below.                                                   |\n\nThe `status` signal provides a specific `ResourceStatus` that describes the state of the resource.\n\n| Status      | `value()`         | Description                                                                  |\n| ----------- | :---------------- | ---------------------------------------------------------------------------- |\n| `Idle`      | `undefined`       | The resource has no valid request and the loader has not run.                |\n| `Error`     | `undefined`       | The loader has encountered an error.                                         |\n| `Loading`   | `undefined`       | The loader is running as a result of the `request` value changing.           |\n| `Reloading` | Previous value    | The loader is running as a result calling of the resource's `reload` method. |\n| `Resolved`  | Resolved value    | The loader has completed.                                                    |\n| `Local`     | Locally set value | The resource's value has been set locally via `.set()` or `.update()`        |\n\nYou can use this status information to conditionally display user interface elements, such loading indicators and error messages.\n\n\n\n================================================\n",
    "endLine": 15367
  },
  {
    "id": 76,
    "file": "binding",
    "fullFileName": "adev/src/content/guide/templates/binding.md",
    "startLine": 15371,
    "content": "# Binding dynamic text, properties and attributes\n\nIn Angular, a **binding** creates a dynamic connection between a component's template and its data. This connection ensures that changes to the component's data automatically update the rendered template.\n\n## Render dynamic text with text interpolation\n\nYou can bind dynamic text in templates with double curly braces, which tells Angular that it is responsible for the expression inside and ensuring it is updated correctly. This is called **text interpolation**.\n\n```angular-ts\n@Component({\n  template: `\n    <p>Your color preference is {{ theme }}.</p>\n  `,\n  ...\n})\nexport class AppComponent {\n  theme = 'dark';\n}\n```\n\nIn this example, when the snippet is rendered to the page, Angular will replace `{{ theme }}` with `dark`.\n\n```angular-html\n<!-- Rendered Output -->\n<p>Your color preference is dark.</p>\n```\n\nIn addition to evaluating the expression at first render, Angular also updates the rendered content when the expression's value changes.\n\nContinuing the theme example, if a user clicks on a button that changes the value of `theme` to `'light'` after the page loads, the page updates accordingly to:\n\n```angular-html\n<!-- Rendered Output -->\n<p>Your color preference is light.</p>\n```\n\nYou can use text interpolation anywhere you would normally write text in HTML.\n\nAll expression values are converted to a string. Objects and arrays are converted using the value’s `toString` method.\n\n## Binding dynamic properties and attributes\n\nAngular supports binding dynamic values into object properties and HTML attributes with square brackets.\n\nYou can bind to properties on an HTML element's DOM instance, a [component](guide/components) instance, or a [directive](guide/directives) instance.\n\n### Native element properties\n\nEvery HTML element has a corresponding DOM representation. For example, each `<button>` HTML element corresponds to an instance of `HTMLButtonElement` in the DOM. In Angular, you use property bindings to set values directly to the DOM representation of the element.\n\n```angular-html\n<!-- Bind the `disabled` property on the button element's DOM object -->\n<button [disabled]=\"isFormValid\">Save</button>\n```\n\nIn this example, every time `isFormValid` changes, Angular automatically sets the `disabled` property of the `HTMLButtonElement` instance.\n\n### Component and directive properties\n\nWhen an element is an Angular component, you can use property bindings to set component input properties using the same square bracket syntax.\n\n```angular-html\n<!-- Bind the `value` property on the `MyListbox` component instance. -->\n<my-listbox [value]=\"mySelection\" />\n```\n\nIn this example, every time `mySelection` changes, Angular automatically sets the `value` property of the `MyListbox` instance.\n\nYou can bind to directive properties as well.\n\n```angular-html\n<!-- Bind to the `ngSrc` property of the `NgOptimizedImage` directive  -->\n<img [ngSrc]=\"profilePhotoUrl\" alt=\"The current user's profile photo\">\n```\n\n### Attributes\n\nWhen you need to set HTML attributes that do not have corresponding DOM properties, such as ARIA attributes or SVG attributes, you can bind attributes to elements in your template with the `attr.` prefix.\n\n```angular-html\n<!-- Bind the `role` attribute on the `<ul>` element to the component's `listRole` property. -->\n<ul [attr.role]=\"listRole\">\n```\n\nIn this example, every time `listRole` changes, Angular automatically sets the `role` attribute of the `<ul>` element by calling `setAttribute`.\n\nIf the value of an attribute binding is `null`, Angular removes the attribute by calling `removeAttribute`.\n\n### Text interpolation in properties and attributes\n\nYou can also use text interpolation syntax in properties and attributes by using the double curly brace syntax instead of square braces around the property or attribute name. When using this syntax, Angular treats the assignment as a property binding.\n\n```angular-html\n<!-- Binds a value to the `alt` property of the image element's DOM object. -->\n<img src=\"profile-photo.jpg\" alt=\"Profile photo of {{ firstName }}\" >\n```\n\nTo bind to an attribute with the text interpolation syntax, prefix the attribute name with `attr.`\n\n```angular-html\n<button attr.aria-label=\"Save changes to {{ objectType }}\">\n```\n\n## CSS class and style property bindings\n\nAngular supports additional features for binding CSS classes and CSS style properties to elements.\n\n### CSS classes\n\nYou can create a CSS class binding to conditionally add or remove a CSS class on an element based on whether the bound value is [truthy or falsy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy).\n\n```angular-html\n<!-- When `isExpanded` is truthy, add the `expanded` CSS class. -->\n<ul [class.expanded]=\"isExpanded\">\n```\n\nYou can also bind directly to the `class` property. Angular accepts three types of value:\n\n| Description of `class` value                                                                                                                                      | TypeScript type       |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\n| A string containing one or more CSS classes separated by spaces                                                                                                   | `string`              |\n| An array of CSS class strings                                                                                                                                     | `string[]`            |\n| An object where each property name is a CSS class name and each corresponding value determines whether that class is applied to the element, based on truthiness. | `Record<string, any>` |\n\n```angular-ts\n@Component({\n  template: `\n    <ul [class]=\"listClasses\"> ... </ul>\n    <section [class]=\"sectionClasses\"> ... </section>\n    <button [class]=\"buttonClasses\"> ... </button>\n  `,\n  ...\n})\nexport class UserProfile {\n  listClasses = 'full-width outlined';\n  sectionClasses = ['expandable', 'elevated'];\n  buttonClasses = {\n    highlighted: true,\n    embiggened: false,\n  };\n}\n```\n\nThe above example renders the following DOM:\n\n```angular-html\n<ul class=\"full-width outlined\"> ... </ul>\n<section class=\"expandable elevated\"> ... </section>\n<button class=\"highlighted\"> ... </button>\n```\n\nAngular ignores any string values that are not valid CSS class names.\n\nWhen using static CSS classes, directly binding `class`, and binding specific classes, Angular intelligently combines all of the classes in the rendered result.\n\n```angular-ts\n@Component({\n  template: `<ul class=\"list\" [class]=\"listType\" [class.expanded]=\"isExpanded\"> ...`,\n  ...\n})\nexport class Listbox {\n  listType = 'box';\n  isExpanded = true;\n}\n```\n\nIn the example above, Angular renders the `ul` element with all three CSS classes.\n\n```angular-html\n<ul class=\"list box expanded\">\n```\n\nAngular does not guarantee any specific order of CSS classes on rendered elements.\n\nWhen binding `class` to an array or an object, Angular compares the previous value to the current value with the triple-equals operator (`===`). You must create a new object or array instance when you modify these values in order for Angular to apply any updates.\n\nIf an element has multiple bindings for the same CSS class, Angular resolves collisions by following its style precedence order.\n\n### CSS style properties\n\nYou can also bind to CSS style properties directly on an element.\n\n```angular-html\n<!-- Set the CSS `display` property based on the `isExpanded` property. -->\n<section [style.display]=\"isExpanded ? 'block' : 'none'\">\n```\n\nYou can further specify units for CSS properties that accept units.\n\n```angular-html\n<!-- Set the CSS `height` property to a pixel value based on the `sectionHeightInPixels` property. -->\n<section [style.height.px]=\"sectionHeightInPixels\">\n```\n\nYou can also set multiple style values in one binding. Angular accepts the following types of value:\n\n| Description of `style` value                                                                                              | TypeScript type       |\n| ------------------------------------------------------------------------------------------------------------------------- | --------------------- |\n| A string containing zero or more CSS declarations, such as `\"display: flex; margin: 8px\"`.                                | `string`              |\n| An object where each property name is a CSS property name and each corresponding value is the value of that CSS property. | `Record<string, any>` |\n\n```angular-ts\n@Component({\n  template: `\n    <ul [style]=\"listStyles\"> ... </ul>\n    <section [style]=\"sectionStyles\"> ... </section>\n  `,\n  ...\n})\nexport class UserProfile {\n  listStyles = 'display: flex; padding: 8px';\n  sectionStyles = {\n    border: '1px solid black',\n    'font-weight': 'bold',\n  };\n}\n```\n\nThe above example renders the following DOM.\n\n```angular-html\n<ul style=\"display: flex; padding: 8px\"> ... </ul>\n<section style=\"border: 1px solid black; font-weight: bold\"> ... </section>\n```\n\nWhen binding `style` to an object, Angular compares the previous value to the current value with the triple-equals operator (`===`). You must create a new object instance when you modify these values in order to Angular to apply any updates.\n\nIf an element has multiple bindings for the same style property, Angular resolves collisions by following its style precedence order.\n\n\n\n================================================\nFILE: adev/src/content/guide/templates/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"templates\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/assets/images:templates.svg\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 15619
  },
  {
    "id": 77,
    "file": "control-flow",
    "fullFileName": "adev/src/content/guide/templates/control-flow.md",
    "startLine": 15623,
    "content": "# Control flow\n\nAngular templates support control flow blocks that let you conditionally show, hide, and repeat elements.\n\nNOTE: This was previously accomplished with the *ngIf, *ngFor, and \\*ngSwitch directives.\n\n## Conditionally display content with `@if`, `@else-if` and `@else`\n\nThe `@if` block conditionally displays its content when its condition expression is truthy:\n\n```angular-html\n@if (a > b) {\n  <p>{{a}} is greater than {{b}}</p>\n}\n```\n\nIf you want to display alternative content, you can do so by providing any number of `@else if` blocks and a singular `@else` block.\n\n```angular-html\n@if (a > b) {\n  {{a}} is greater than {{b}}\n} @else if (b > a) {\n  {{a}} is less than {{b}}\n} @else {\n  {{a}} is equal to {{b}}\n}\n```\n\n### Referencing the conditional expression's result\n\nThe `@if` conditional supports saving the result of the conditional expression into a variable for reuse inside of the block.\n\n```angular-html\n@if (user.profile.settings.startDate; as startDate) {\n  {{ startDate }}\n}\n```\n\nThis can be useful for referencing longer expressions that would be easier to read and maintain within the template.\n\n## Repeat content with the `@for` block\n\nThe `@for` block loops through a collection and repeatedly renders the content of a block. The collection can be any JavaScript [iterable](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Iteration_protocols), but Angular has additional performance optimizations for `Array` values.\n\nA typical `@for` loop looks like:\n\n```angular-html\n@for (item of items; track item.id) {\n  {{ item.name }}\n}\n```\n\nAngular's `@for` block does not support flow-modifying statements like JavaScript's `continue` or `break`.\n\n### Why is `track` in `@for` blocks important?\n\nThe `track` expression allows Angular to maintain a relationship between your data and the DOM nodes on the page. This allows Angular to optimize performance by executing the minimum necessary DOM operations when the data changes.\n\nUsing track effectively can significantly improve your application's rendering performance when looping over data collections.\n\nSelect a property that uniquely identifies each item in the `track` expression. If your data model includes a uniquely identifying property, commonly `id` or `uuid`, use this value. If your data does not include a field like this, strongly consider adding one.\n\nFor static collections that never change, you can use `$index` to tell Angular to track each item by its index in the collection.\n\nIf no other option is available, you can specify `identity`. This tells Angular to track the item by its reference identity using the triple-equals operator (`===`). Avoid this option whenever possible as it can lead to significantly slower rendering updates, as Angular has no way to map which data item corresponds to which DOM nodes.\n\n### Contextual variables in `@for` blocks\n\nInside `@for` blocks, several implicit variables are always available:\n\n| Variable | Meaning                                       |\n| -------- | --------------------------------------------- |\n| `$count` | Number of items in a collection iterated over |\n| `$index` | Index of the current row                      |\n| `$first` | Whether the current row is the first row      |\n| `$last`  | Whether the current row is the last row       |\n| `$even`  | Whether the current row index is even         |\n| `$odd`   | Whether the current row index is odd          |\n\nThese variables are always available with these names, but can be aliased via a `let` segment:\n\n```angular-html\n@for (item of items; track item.id; let idx = $index, e = $even) {\n  <p>Item #{{ idx }}: {{ item.name }}</p>\n}\n```\n\nThe aliasing is useful when nesting `@for` blocks, letting you read variables from the outer `@for` block from an inner `@for` block.\n\n### Providing a fallback for `@for` blocks with the `@empty` block\n\nYou can optionally include an `@empty` section immediately after the `@for` block content. The content of the `@empty` block displays when there are no items:\n\n```angular-html\n@for (item of items; track item.name) {\n  <li> {{ item.name }}</li>\n} @empty {\n  <li aria-hidden=\"true\"> There are no items. </li>\n}\n```\n\n## Conditionally display content with the `@switch` block\n\nWhile the `@if` block is great for most scenarios, the `@switch` block provides an alternate syntax to conditionally render data. Its syntax closely resembles JavaScript's `switch` statement.\n\n```angular-html\n@switch (userPermissions) {\n  @case ('admin') {\n    <app-admin-dashboard />\n  }\n  @case ('reviewer') {\n    <app-reviewer-dashboard />\n  }\n  @case ('editor') {\n    <app-editor-dashboard />\n  }\n  @default {\n    <app-viewer-dashboard />\n  }\n}\n```\n\nThe value of the conditional expression is compared to the case expression using the triple-equals (`===`) operator.\n\n**`@switch` does not have a fallthrough**, so you do not need an equivalent to a `break` or `return` statement in the block.\n\nYou can optionally include a `@default` block. The content of the `@default` block displays if none of the preceding case expressions match the switch value.\n\nIf no `@case` matches the expression and there is no `@default` block, nothing is shown.\n\n\n\n================================================\n",
    "endLine": 15754
  },
  {
    "id": 78,
    "file": "defer",
    "fullFileName": "adev/src/content/guide/templates/defer.md",
    "startLine": 15758,
    "content": "# Deferred loading with `@defer`\n\nDeferrable views, also known as `@defer` blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page. This often results in a faster initial load and improvement in Core Web Vitals (CWV), primarily Largest Contentful Paint (LCP) and Time to First Byte (TTFB).\n\nTo use this feature, you can declaratively wrap a section of your template in a @defer block:\n\n```angular-html\n@defer {\n  <large-component />\n}\n```\n\nThe code for any components, directives, and pipes inside the `@defer` block is split into a separate JavaScript file and loaded only when necessary, after the rest of the template has been rendered.\n\nDeferrable views support a variety of triggers, prefetching options, and sub-blocks for placeholder, loading, and error state management.\n\n## Which dependencies are deferred?\n\nComponents, directives, pipes, and any component CSS styles can be deferred when loading an application.\n\nIn order for the dependencies within a `@defer` block to be deferred, they need to meet two conditions:\n\n1. **They must be standalone.** Non-standalone dependencies cannot be deferred and are still eagerly loaded, even if they are inside of `@defer` blocks.\n1. **They cannot be referenced outside of `@defer` blocks within the same file.** If they are referenced outside the `@defer` block or referenced within ViewChild queries, the dependencies will be eagerly loaded.\n\nThe _transitive_ dependencies of the components, directives and pipes used in the `@defer` block do not strictly need to be standalone; transitive dependencies can still be declared in an `NgModule` and participate in deferred loading.\n\nAngular's compiler produces a [dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) statement for each component, directive, and pipe used in the `@defer` block. The main content of the block renders after all the imports resolve. Angular does not guarantee any particular order for these imports.\n\n## How to manage different stages of deferred loading\n\n`@defer` blocks have several sub blocks to allow you to gracefully handle different stages in the deferred loading process.\n\n### `@defer`\n\nThis is the primary block that defines the section of content that is lazily loaded. It is not rendered initially– deferred content loads and renders once the specified [trigger](/guide/defer#triggers) occurs or the `when` condition is met.\n\nBy default, a @defer block is triggered when the browser state becomes [idle](/guide/defer#idle).\n\n```angular-html\n@defer {\n  <large-component />\n}\n```\n\n### Show placeholder content with `@placeholder`\n\nBy default, defer blocks do not render any content before they are triggered.\n\nThe `@placeholder` is an optional block that declares what content to show before the `@defer` block is triggered.\n\n```angular-html\n@defer {\n  <large-component />\n} @placeholder {\n  <p>Placeholder content</p>\n}\n```\n\nWhile optional, certain triggers may require the presence of either a `@placeholder` or a [template reference variable](/guide/templates/variables#template-reference-variables) to function. See the [Triggers](/guide/defer#triggers) section for more details.\n\nAngular replaces placeholder content with the main content once loading is complete. You can use any content in the placeholder section including plain HTML, components, directives, and pipes. Keep in mind the _dependencies of the placeholder block are eagerly loaded_.\n\nThe `@placeholder` block accepts an optional parameter to specify the `minimum` amount of time that this placeholder should be shown after the placeholder content initially renders.\n\n```angular-html\n@defer {\n  <large-component />\n} @placeholder (minimum 500ms) {\n  <p>Placeholder content</p>\n}\n```\n\nThis `minimum` parameter is specified in time increments of milliseconds (ms) or seconds (s). You can use this parameter to prevent fast flickering of placeholder content in the case that the deferred dependencies are fetched quickly.\n\n### Show loading content with `@loading`\n\nThe `@loading` block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the `@placeholder` block once loading is triggered.\n\n```angular-html\n@defer {\n  <large-component />\n} @loading {\n  <img alt=\"loading...\" src=\"loading.gif\" />\n} @placeholder {\n  <p>Placeholder content</p>\n}\n```\n\nIts dependencies are eagerly loaded (similar to `@placeholder`).\n\nThe `@loading` block accepts two optional parameters to help prevent fast flickering of content that may occur when deferred dependencies are fetched quickly,:\n\n- `minimum` - the minimum amount of time that this placeholder should be shown\n- `after` - the amount of time to wait after loading begins before showing the loading template\n\n```angular-html\n@defer {\n  <large-component />\n} @loading (after 100ms; minimum 1s) {\n  <img alt=\"loading...\" src=\"loading.gif\" />\n}\n```\n\nBoth parameters are specified in time increments of milliseconds (ms) or seconds (s). In addition, the timers for both parameters begin immediately after the loading has been triggered.\n\n### Show error state when deferred loading fails with `@error`\n\nThe `@error` block is an optional block that displays if deferred loading fails. Similar to `@placeholder` and `@loading`, the dependencies of the @error block are eagerly loaded.\n\n```angular-html\n@defer {\n  <large-component />\n} @error {\n  <p>Failed to load large component.</p>\n}\n```\n\n## Controlling deferred content loading with triggers\n\nYou can specify **triggers** that control when Angular loads and displays deferred content.\n\nWhen a `@defer` block is triggered, it replaces placeholder content with lazily loaded content.\n\nMultiple event triggers can be defined by separating them with a semicolon, `;` and will be evaluated as OR conditions.\n\nThere are two types of triggers: `on` and `when`.\n\n### `on`\n\n`on` specifies a condition for when the `@defer` block is triggered.\n\nThe available triggers are as follows:\n\n| Trigger                       | Description                                                            |\n| ----------------------------- | ---------------------------------------------------------------------- |\n| [`idle`](#idle)               | Triggers when the browser is idle.                                     |\n| [`viewport`](#viewport)       | Triggers when specified content enters the viewport                    |\n| [`interaction`](#interaction) | Triggers when the user interacts with specified element                |\n| [`hover`](#hover)             | Triggers when the mouse hovers over specified area                     |\n| [`immediate`](#immediate)     | Triggers immediately after non-deferred content has finished rendering |\n| [`timer`](#timer)             | Triggers after a specific duration                                     |\n\n#### `idle`\n\nThe `idle` trigger loads the deferred content once the browser has reached an idle state, based on requestIdleCallback. This is the default behavior with a defer block.\n\n```angular-html\n<!-- @defer (on idle) -->\n@defer {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `viewport`\n\nThe `viewport` trigger loads the deferred content when the specified content enters the viewport using the [Intersection Observer API](https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API). Observed content may be `@placeholder` content or an explicit element reference.\n\nBy default, the `@defer` watches for the placeholder entering the viewport. Placeholders used this way must have a single root element.\n\n```angular-html\n@defer (on viewport) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nAlternatively, you can specify a [template reference variable](/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```angular-html\n<div #greeting>Hello!</div>\n@defer (on viewport(greeting)) {\n  <greetings-cmp />\n}\n```\n\n#### `interaction`\n\nThe `interaction` trigger loads the deferred content when the user interacts with the specified element through `click` or `keydown` events.\n\nBy default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.\n\n```angular-html\n@defer (on interaction) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nAlternatively, you can specify a [template reference variable](/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```angular-html\n<div #greeting>Hello!</div>\n@defer (on interaction(greeting)) {\n  <greetings-cmp />\n}\n```\n\n#### `hover`\n\nThe `hover` trigger loads the deferred content when the mouse has hovered over the triggered area through the `mouseover` and `focusin` events.\n\nBy default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.\n\n```angular-html\n@defer (on hover) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nAlternatively, you can specify a [template reference variable](/guide/templates/variables) in the same template as the `@defer` block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.\n\n```angular-html\n<div #greeting>Hello!</div>\n@defer (on hover(greeting)) {\n  <greetings-cmp />\n}\n```\n\n#### `immediate`\n\nThe `immediate` trigger loads the deferred content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering.\n\n```angular-html\n@defer (on immediate) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n#### `timer`\n\nThe `timer` trigger loads the deferred content after a specified duration.\n\n```angular-html\n@defer (on timer(500ms)) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nThe duration parameter must be specified in milliseconds (`ms`) or seconds (`s`).\n\n### `when`\n\nThe `when` trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy.\n\n```angular-html\n@defer (when condition) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\nThis is a one-time operation– the `@defer` block does not revert back to the placeholder if the condition changes to a falsy value after becoming truthy.\n\n## Prefetching data with `prefetch`\n\nIn addition to specifying a condition that determines when deferred content is shown, you can optionally specify a **prefetch trigger**. This trigger lets you load the JavaScript associated with the `@defer` block before the deferred content is shown.\n\nPrefetching enables more advanced behaviors, such as letting you start to prefetch resources before a user has actually seen or interacted with a defer block, but might interact with it soon, making the resources available faster.\n\nYou can specify a prefetch trigger similarly to the block's main trigger, but prefixed with the `prefetch` keyword. The block's main trigger and prefetch trigger are separated with a semi-colon character (`;`).\n\nIn the example below, the prefetching starts when a browser becomes idle and the contents of the block is rendered only once the user interacts with the placeholder.\n\n```angular-html\n@defer (on interaction; prefetch on idle) {\n  <large-cmp />\n} @placeholder {\n  <div>Large component placeholder</div>\n}\n```\n\n## Testing `@defer` blocks\n\nAngular provides TestBed APIs to simplify the process of testing `@defer` blocks and triggering different states during testing. By default, `@defer` blocks in tests play through like a defer block would behave in a real application. If you want to manually step through states, you can switch the defer block behavior to `Manual` in the TestBed configuration.\n\n```angular-ts\nit('should render a defer block in different states', async () => {\n  // configures the defer block behavior to start in \"paused\" state for manual control.\n  TestBed.configureTestingModule({deferBlockBehavior: DeferBlockBehavior.Manual});\n  @Component({\n    // ...\n    template: `\n      @defer {\n        <large-component />\n      } @placeholder {\n        Placeholder\n      } @loading {\n        Loading...\n      }\n    `\n  })\n  class ComponentA {}\n  // Create component fixture.\n  const componentFixture = TestBed.createComponent(ComponentA);\n  // Retrieve the list of all defer block fixtures and get the first block.\n  const deferBlockFixture = (await componentFixture.getDeferBlocks())[0];\n  // Renders placeholder state by default.\n  expect(componentFixture.nativeElement.innerHTML).toContain('Placeholder');\n  // Render loading state and verify rendered output.\n  await deferBlockFixture.render(DeferBlockState.Loading);\n  expect(componentFixture.nativeElement.innerHTML).toContain('Loading');\n  // Render final state and verify the output.\n  await deferBlockFixture.render(DeferBlockState.Complete);\n  expect(componentFixture.nativeElement.innerHTML).toContain('large works!');\n});\n```\n\n## Does `@defer` work with `NgModule`?\n\n`@defer` blocks are compatible with both standalone and NgModule-based components, directives and pipes. However, **only standalone components, directives and pipes can be deferred**. NgModule-based dependencies are not deferred and are included in the eagerly loaded bundle.\n\n## How does `@defer` work with server-side rendering (SSR) and static-site generation (SSG)?\n\nBy default, when rendering an application on the server (either using SSR or SSG), defer blocks always render their `@placeholder` (or nothing if a placeholder is not specified) and triggers are not invoked. On the client, the content of the `@placeholder` is hydrated and triggers are activated.\n\nTo render the main content of `@defer` blocks on the server (both SSR and SSG), you can enable [the Incremental Hydration feature](/guide/incremental-hydration) and configure `hydrate` triggers for the necessary blocks.\n\n## Best practices for deferring views\n\n### Avoid cascading loads with nested `@defer` blocks\n\nWhen you have nested `@defer` blocks, they should have different triggers in order to avoid loading simultaneously, which causes cascading requests and may negatively impact page load performance.\n\n### Avoid layout shifts\n\nAvoid deferring components that are visible in the user’s viewport on initial load. Doing this may negatively affect Core Web Vitals by causing an increase in cumulative layout shift (CLS).\n\nIn the event this is necessary, avoid `immediate`, `timer`, `viewport`, and custom `when` triggers that cause the content to load during the initial page render.\n\n\n\n================================================\n",
    "endLine": 16100
  },
  {
    "id": 79,
    "file": "event-listeners",
    "fullFileName": "adev/src/content/guide/templates/event-listeners.md",
    "startLine": 16104,
    "content": "# Adding event listeners\n\nAngular supports defining event listeners on an element in your template by specifying the event name inside parentheses along with a statement that runs every time the event occurs.\n\n## Listening to native events\n\nWhen you want to add event listeners to an HTML element, you wrap the event with parentheses, `()`, which allows you to specify a listener statement.\n\n```angular-ts\n@Component({\n  template: `\n    <input type=\"text\" (keyup)=\"updateField()\" />\n  `,\n  ...\n})\nexport class AppComponent{\n  updateField(): void {\n    console.log('Field is updated!');\n  }\n}\n```\n\nIn this example, Angular calls `updateField` every time the `<input>` element emits a `keyup` event.\n\nYou can add listeners for any native events, such as: `click`, `keydown`, `mouseover`, etc. To learn more, check out the [all available events on elements on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element#events).\n\n## Accessing the event argument\n\nIn every template event listener, Angular provides a variable named `$event` that contains a reference to the event object.\n\n```angular-ts\n@Component({\n  template: `\n    <input type=\"text\" (keyup)=\"updateField($event)\" />\n  `,\n  ...\n})\nexport class AppComponent {\n  updateField(event: KeyboardEvent): void {\n    console.log(`The user pressed: ${event.key}`);\n  }\n}\n```\n\n## Using key modifiers\n\nWhen you want to capture specific keyboard events for a specific key, you might write some code like the following:\n\n```angular-ts\n@Component({\n  template: `\n    <input type=\"text\" (keyup)=\"updateField($event)\" />\n  `,\n  ...\n})\nexport class AppComponent {\n  updateField(event: KeyboardEvent): void {\n    if (event.key === 'Enter') {\n      console.log('The user pressed enter in the text field.');\n    }\n  }\n}\n```\n\nHowever, since this is a common scenario, Angular lets you filter the events by specifying a specific key using the period (`.`) character. By doing so, code can be simplified to:\n\n```angular-ts\n@Component({\n  template: `\n    <input type=\"text\" (keyup.enter)=\"updateField($event)\" />\n  `,\n  ...\n})\nexport class AppComponent{\n  updateField(event: KeyboardEvent): void {\n    console.log('The user pressed enter in the text field.');\n  }\n}\n```\n\nYou can also add additional key modifiers:\n\n```angular-html\n<!-- Matches shift and enter -->\n<input type=\"text\" (keyup.shift.enter)=\"updateField($event)\" />\n```\n\nAngular supports the modifiers `alt`, `control`, `meta`, and `shift`.\n\nYou can specify the key or code that you would like to bind to keyboard events. The key and code fields are a native part of the browser keyboard event object. By default, event binding assumes you want to use the [Key values for keyboard events](https://developer.mozilla.org/docs/Web/API/UI_Events/Keyboard_event_key_values).\n\nAngular also allows you to specify [Code values for keyboard events](https://developer.mozilla.org/docs/Web/API/UI_Events/Keyboard_event_code_values) by providing a built-in `code` suffix.\n\n```angular-html\n<!-- Matches alt and left shift -->\n<input type=\"text\" (keydown.code.alt.shiftleft)=\"updateField($event)\" />\n```\n\nThis can be useful for handling keyboard events consistently across different operating systems. For example, when using the Alt key on MacOS devices, the `key` property reports the key based on the character already modified by the Alt key. This means that a combination like Alt + S reports a `key` value of `'ß'`. The `code` property, however, corresponds to the physical or virtual button pressed rather than the character produced.\n\n\n\n================================================\n",
    "endLine": 16205
  },
  {
    "id": 80,
    "file": "expression-syntax",
    "fullFileName": "adev/src/content/guide/templates/expression-syntax.md",
    "startLine": 16209,
    "content": "# Expression Syntax\n\nAngular expressions are based on JavaScript, but differ in some key ways. This guide walks through the similarities and differences between Angular expressions and standard JavaScript.\n\n## Value literals\n\nAngular supports a subset of [literal values](https://developer.mozilla.org/en-US/docs/Glossary/Literal) from JavaScript.\n\n### Supported value literals\n\n| Literal type           | Example values                  |\n| ---------------------- | ------------------------------- |\n| String                 | `'Hello'`, `\"World\"`            |\n| Boolean                | `true`, `false`                 |\n| Number                 | `123`, `3.14`                   |\n| Object                 | `{name: 'Alice'}`               |\n| Array                  | `['Onion', 'Cheese', 'Garlic']` |\n| null                   | `null`                          |\n| Template string        | `` `Hello ${name}` ``           |\n| Tagged template string | `` tag`Hello ${name}` ``        |\n\n### Unsupported literals\n\n| Literal type           | Example value            |\n| ---------------------- | ------------------------ |\n| RegExp                 | `/\\d+/`                  |\n| Tagged template string | `` tag`Hello ${name}` `` |\n\n## Globals\n\nAngular expressions support the following [globals](https://developer.mozilla.org/en-US/docs/Glossary/Global_object):\n\n- [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n- [$any](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any)\n\nNo other JavaScript globals are supported. Common JavaScript globals include `Number`, `Boolean`, `NaN`, `Infinity`, `parseInt`, and more.\n\n## Local variables\n\nAngular automatically makes special local variables available for use in expressions in specific contexts. These special variables always start with the dollar sign character (`$`).\n\nFor example, `@for` blocks make several local variables corresponding to information about the loop, such as `$index`.\n\n## What operators are supported?\n\n### Supported operators\n\nAngular supports the following operators from standard JavaScript.\n\n| Operator              | Example(s)                               |\n| --------------------- | ---------------------------------------- |\n| Add / Concatenate     | `1 + 2`                                  |\n| Subtract              | `52 - 3`                                 |\n| Multiply              | `41 * 6`                                 |\n| Divide                | `20 / 4`                                 |\n| Remainder (Modulo)    | `17 % 5`                                 |\n| Exponentiation        | `10 ** 3`                                |\n| Parenthesis           | `9 * (8 + 4)`                            |\n| Conditional (Ternary) | `a > b ? true : false`                   |\n| And (Logical)         | `&&`                                     |\n| Or (Logical)          | `\\|\\|`                                   |\n| Not (Logical)         | `!`                                      |\n| Nullish Coalescing    | `possiblyNullValue ?? 'default'`         |\n| Comparison Operators  | `<`, `<=`, `>`, `>=`, `==`, `===`, `!==` |\n| Unary Negation        | `-x`                                     |\n| Unary Plus            | `+y`                                     |\n| Property Accessor     | `person['name']`                         |\n| typeof                | `typeof 42`                              |\n| void                  | `void 1`                                 |\n\nAngular expressions additionally also support the following non-standard operators:\n\n| Operator                        | Example(s)                     |\n| ------------------------------- | ------------------------------ |\n| [Pipe](/guide/templates/pipes) | `{{ total \\| currency }}`      |\n| Optional chaining\\*             | `someObj.someProp?.nestedProp` |\n| Non-null assertion (TypeScript) | `someObj!.someProp`            |\n\n\\*NOTE: Optional chaining behaves differently from the standard JavaScript version in that if the left side of Angular’s optional chaining operator is `null` or `undefined`, it returns `null` instead of `undefined`.\n\n### Unsupported operators\n\n| Operator              | Example(s)                        |\n| --------------------- | --------------------------------- |\n| All bitwise operators | `&`, `&=`, `~`, `\\|=`, `^=`, etc. |\n| Assignment operators  | `=`                               |\n| Object destructuring  | `const { name } = person`         |\n| Array destructuring   | `const [firstItem] = items`       |\n| Comma operator        | `x = (x++, x)`                    |\n| in                    | `'model' in car`                  |\n| instanceof            | `car instanceof Automobile`       |\n| new                   | `new Car()`                       |\n\n## Lexical context for expressions\n\nAngular expressions are evaluated within the context of the component class as well as any relevant [template variables](/guide/templates/variables), locals, and globals.\n\nWhen referring to class members, `this` is always implied.\n\n## Declarations\n\nGenerally speaking, declarations are not supported in Angular expressions. This includes, but is not limited to:\n\n| Declarations    | Example(s)                                  |\n| --------------- | ------------------------------------------- |\n| Variables       | `let label = 'abc'`, `const item = 'apple'` |\n| Functions       | `function myCustomFunction() { }`           |\n| Arrow Functions | `() => { }`                                 |\n| Classes         | `class Rectangle { }`                       |\n\n# Event listener statements\n\nEvent handlers are **statements** rather than expressions. While they support all of the same syntax as Angular expressions, the are two key differences:\n\n1. Statements **do support** assignment operators (but not destructing assignments)\n1. Statements **do not support** pipes\n\n\n\n================================================\n",
    "endLine": 16327
  },
  {
    "id": 81,
    "file": "ng-container",
    "fullFileName": "adev/src/content/guide/templates/ng-container.md",
    "startLine": 16331,
    "content": "# Grouping elements with ng-container\n\n`<ng-container>` is a special element in Angular that groups multiple elements together or marks a location in a template without rendering a real element in the DOM.\n\n```angular-html\n<!-- Component template -->\n<section>\n  <ng-container>\n    <h3>User bio</h3>\n    <p>Here's some info about the user</p>\n  </ng-container>\n</section>\n```\n\n```angular-html\n<!-- Rendered DOM -->\n<section>\n  <h3>User bio</h3>\n  <p>Here's some info about the user</p>\n</section>\n```\n\nYou can apply directives to `<ng-container>` to add behaviors or configuration to a part of your template.\n\nAngular ignores all attribute bindings and event listeners applied to `<ng-container>`, including those applied via directive.\n\n## Using `<ng-container>` to display dynamic contents\n\n`<ng-container>` can act as a placeholder for rendering dynamic content.\n\n### Rendering components\n\nYou can use Angular's built-in `NgComponentOutlet` directive to dynamically render a component to the location of the `<ng-container>`.\n\n```angular-ts\n@Component({\n  template: `\n    <h2>Your profile</h2>\n    <ng-container [ngComponentOutlet]=\"profileComponent()\" />\n  `\n})\nexport class UserProfile {\n  isAdmin = input(false);\n  profileComponent = computed(() => this.isAdmin() ? AdminProfile : BasicUserProfile);\n}\n```\n\nIn the example above, the `NgComponentOutlet` directive dynamically renders either `AdminProfile` or `BasicUserProfile` in the location of the `<ng-container>` element.\n\n### Rendering template fragments\n\nYou can use Angular's built-in `NgTemplateOutlet` directive to dynamically render a template fragment to the location of the `<ng-container>`.\n\n```angular-ts\n@Component({\n  template: `\n    <h2>Your profile</h2>\n    <ng-container [ngTemplateOutlet]=\"profileTemplate()\" />\n\n    <ng-template #admin>This is the admin profile</ng-template>\n    <ng-template #basic>This is the basic profile</ng-template>\n  `\n})\nexport class UserProfile {\n  isAdmin = input(false);\n  adminTemplate = viewChild('admin', {read: TemplateRef});\n  basicTemplate = viewChild('basic', {read: TemplateRef});\n  profileTemplate = computed(() => this.isAdmin() ? this.adminTemplate() : this.basicTemplate());\n}\n```\n\nIn the example above, the `ngTemplateOutlet` directive dynamically renders one of two template fragments in the location of the `<ng-container>` element.\n\nFor more information regarding NgTemplateOutlet, see the [NgTemplateOutlets API documentation page](/api/common/NgTemplateOutlet).\n\n## Using `<ng-container>` with structural directives\n\nYou can also apply structural directives to `<ng-container>` elements. Common examples of this include `ngIf`and `ngFor`.\n\n```angular-html\n<ng-container *ngIf=\"permissions == 'admin'\">\n  <h1>Admin Dashboard</h1>\n  <admin-infographic></admin-infographic>\n</ng-container>\n\n<ng-container *ngFor=\"let item of items; index as i; trackBy: trackByFn\">\n  <h2>{{ item.title }}</h2>\n  <p>{{ item.description }}</p>\n</ng-container>\n```\n\n## Using `<ng-container>` for injection\n\nSee the Dependency Injection guide for more information on Angular's dependency injection system.\n\nWhen you apply a directive to `<ng-container>`, descendant elements can inject the directive or anything that the directive provides. Use this when you want to declaratively provide a value to a specific part of your template.\n\n```angular-ts\n@Directive({\n  selector: '[theme]',\n})\nexport class Theme {\n  // Create an input that accepts 'light' or 'dark`, defaulting to 'light'.\n  mode = input<'light' | 'dark'>('light');\n}\n```\n\n```angular-html\n<ng-container theme=\"dark\">\n  <profile-pic />\n  <user-bio />\n</ng-container>\n```\n\nIn the example above, the `ProfilePic` and `UserBio` components can inject the `Theme` directive and apply styles based on its `mode`.\n\n\n\n================================================\n",
    "endLine": 16448
  },
  {
    "id": 82,
    "file": "ng-content",
    "fullFileName": "adev/src/content/guide/templates/ng-content.md",
    "startLine": 16452,
    "content": "# Render templates from a parent component with `ng-content`\n\n`<ng-content>` is a special element that accepts markup or a template fragment and controls how components render content. It does not render a real DOM element.\n\nHere is an example of a `BaseButton` component that accepts any markup from its parent.\n\n```angular-ts\n// ./base-button/base-button.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'button[baseButton]',\n  template: `\n      <ng-content />\n  `,\n})\nexport class BaseButton {}\n```\n\n```angular-ts\n// ./app.component.ts\nimport { Component } from '@angular/core';\nimport { BaseButton } from './base-button/base-button.component.ts';\n\n@Component({\n  selector: 'app-root',\n  imports: [BaseButton],\n  template: `\n    <button baseButton>\n      Next <span class=\"icon arrow-right\" />\n    </button>\n  `,\n})\nexport class AppComponent {}\n```\n\nFor more detail, check out the [`<ng-content>` in-depth guide](/guide/components/content-projection) for other ways you can leverage this pattern.\n\n\n\n================================================\n",
    "endLine": 16491
  },
  {
    "id": 83,
    "file": "ng-template",
    "fullFileName": "adev/src/content/guide/templates/ng-template.md",
    "startLine": 16495,
    "content": "# Create template fragments with ng-template\n\nInspired by the [native `<template>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template), the `<ng-template>` element lets you declare a **template fragment** – a section of content that you can dynamically or programmatically render.\n\n## Creating a template fragment\n\nYou can create a template fragment inside of any component template with the `<ng-template>` element:\n\n```angular-html\n<p>This is a normal element</p>\n\n<ng-template>\n  <p>This is a template fragment</p>\n</ng-template>\n```\n\nWhen the above is rendered, the content of the `<ng-template>` element is not rendered on the page. Instead, you can get a reference to the template fragment and write code to dynamically render it.\n\n### Binding context for fragments\n\nTemplate fragments may contain bindings with dynamic expressions:\n\n```angular-ts\n@Component({\n  /* ... */,\n  template: `<ng-template>You've selected {{count}} items.</ng-template>`,\n})\nexport class ItemCounter {\n  count: number = 0;\n}\n```\n\nExpressions or statements in a template fragment are evaluated against the component in which the fragment is declared, regardless of where the fragment is rendered.\n\n## Getting a reference to a template fragment\n\nYou can get a reference to a template fragment in one of three ways:\n\n- By declaring a [template reference variable](/guide/templates/variables#template-reference-variables) on the `<ng-template>` element\n- By querying for the fragment with [a component or directive query](/guide/components/queries)\n- By injecting the fragment in a directive that's applied directly to an `<ng-template>` element.\n\nIn all three cases, the fragment is represented by a [TemplateRef](/api/core/TemplateRef) object.\n\n### Referencing a template fragment with a template reference variable\n\nYou can add a template reference variable to an `<ng-template>` element to reference that template fragment in other parts of the same template file:\n\n```angular-html\n<p>This is a normal element</p>\n\n<ng-template #myFragment>\n  <p>This is a template fragment</p>\n</ng-template>\n```\n\nYou can then reference this fragment anywhere else in the template via the `myFragment` variable.\n\n### Referencing a template fragment with queries\n\nYou can get a reference to a template fragment using any [component or directive query API](/guide/components/queries).\n\nFor example, if your template has exactly one template fragment, you can query directly for the `TemplateRef` object with a `@ViewChild` query:\n\n```angular-ts\n@Component({\n  /* ... */,\n  template: `\n    <p>This is a normal element</p>\n\n    <ng-template>\n      <p>This is a template fragment</p>\n    </ng-template>\n  `,\n})\nexport class ComponentWithFragment {\n  @ViewChild(TemplateRef) myFragment: TemplateRef<unknown> | undefined;\n}\n```\n\nYou can then reference this fragment in your component code or the component's template like any other class member.\n\nIf a template contains multiple fragments, you can assign a name to each fragment by adding a template reference variable to each `<ng-template>` element and querying for the fragments based on that name:\n\n```angular-ts\n@Component({\n  /* ... */,\n  template: `\n    <p>This is a normal element</p>\n\n    <ng-template #fragmentOne>\n      <p>This is one template fragment</p>\n    </ng-template>\n\n    <ng-template #fragmentTwo>\n      <p>This is another template fragment</p>\n    </ng-template>\n  `,\n})\nexport class ComponentWithFragment {\n  // When querying by name, you can use the `read` option to specify that you want to get the\n  // TemplateRef object associated with the element.\n  @ViewChild('fragmentOne', {read: TemplateRef}) fragmentOne: TemplateRef<unknown> | undefined;\n  @ViewChild('fragmentTwo', {read: TemplateRef}) fragmentTwo: TemplateRef<unknown> | undefined;\n}\n```\n\nAgain, you can then reference these fragments in your component code or the component's template like any other class members.\n\n### Injecting a template fragment\n\nA directive can inject a `TemplateRef` if that directive is applied directly to an `<ng-template>` element:\n\n```angular-ts\n@Directive({\n  selector: '[myDirective]'\n})\nexport class MyDirective {\n  private fragment = inject(TemplateRef);\n}\n```\n\n```angular-html\n<ng-template myDirective>\n  <p>This is one template fragment</p>\n</ng-template>\n```\n\nYou can then reference this fragment in your directive code like any other class member.\n\n## Rendering a template fragment\n\nOnce you have a reference to a template fragment's `TemplateRef` object, you can render a fragment in one of two ways: in your template with the `NgTemplateOutlet` directive or in your TypeScript code with `ViewContainerRef`.\n\n### Using `NgTemplateOutlet`\n\nThe `NgTemplateOutlet` directive from `@angular/common` accepts a `TemplateRef` and renders the fragment as a **sibling** to the element with the outlet. You should generally use `NgTemplateOutlet` on an [`<ng-container>` element](/guide/templates/ng-container).\n\nFirst, import `NgTemplateOutlet`:\n```typescript\nimport { NgTemplateOutlet } from '@angular/common';\n```\n\nThe following example declares a template fragment and renders that fragment to a `<ng-container>` element with `NgTemplateOutlet`:\n\n```angular-html\n<p>This is a normal element</p>\n\n<ng-template #myFragment>\n  <p>This is a fragment</p>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"myFragment\"></ng-container>\n```\n\nThis example produces the following rendered DOM:\n\n```angular-html\n<p>This is a normal element</p>\n<p>This is a fragment</p>\n```\n\n### Using `ViewContainerRef`\n\nA **view container** is a node in Angular's component tree that can contain content. Any component or directive can inject `ViewContainerRef` to get a reference to a view container corresponding to that component or directive's location in the DOM.\n\nYou can use the `createEmbeddedView` method on `ViewContainerRef` to dynamically render a template fragment. When you render a fragment with a `ViewContainerRef`, Angular appends it into the DOM as the next sibling of the component or directive that injected the `ViewContainerRef`.\n\nThe following example shows a component that accepts a reference to a template fragment as an input and renders that fragment into the DOM on a button click.\n\n```angular-ts\n@Component({\n  /* ... */,\n  selector: 'component-with-fragment',\n  template: `\n    <h2>Component with a fragment</h2>\n    <ng-template #myFragment>\n      <p>This is the fragment</p>\n    </ng-template>\n    <my-outlet [fragment]=\"myFragment\" />\n  `,\n})\nexport class ComponentWithFragment { }\n\n@Component({\n  /* ... */,\n  selector: 'my-outlet',\n  template: `<button (click)=\"showFragment()\">Show</button>`,\n})\nexport class MyOutlet {\n  private viewContainer = inject(ViewContainerRef);\n  @Input() fragment: TemplateRef<unknown> | undefined;\n\n  showFragment() {\n    if (this.fragment) {\n      this.viewContainer.createEmbeddedView(this.fragment);\n    }\n  }\n}\n```\n\nIn the example above, clicking the \"Show\" button results in the following output:\n\n```angular-html\n<component-with-fragment>\n  <h2>Component with a fragment>\n  <my-outlet>\n    <button>Show</button>\n  </my-outlet>\n  <p>This is the fragment</p>\n</component-with-fragment>\n```\n\n## Passing parameters when rendering a template fragment\n\nWhen declaring a template fragment with `<ng-template>`, you can additionally declare parameters accepted by the fragment. When you render a fragment, you can optimally pass a `context` object corresponding to these parameters. You can use data from this context object in binding expressions and statements, in addition to referencing data from the component in which the fragment is declared.\n\nEach parameter is written as an attribute prefixed with `let-` with a value matching a property name in the context object:\n\n```angular-html\n<ng-template let-pizzaTopping=\"topping\">\n  <p>You selected: {{pizzaTopping}}</p>\n</ng-template>\n```\n\n### Using `NgTemplateOutlet`\n\nYou can bind a context object to the `ngTemplateOutletContext` input:\n\n```angular-html\n<ng-template #myFragment let-pizzaTopping=\"topping\">\n  <p>You selected: {{pizzaTopping}}</p>\n</ng-template>\n\n<ng-container\n  [ngTemplateOutlet]=\"myFragment\"\n  [ngTemplateOutletContext]=\"{topping: 'onion'}\"\n/>\n```\n\n### Using `ViewContainerRef`\n\nYou can pass a context object as the second argument to `createEmbeddedView`:\n\n```angular-ts\nthis.viewContainer.createEmbeddedView(this.myFragment, {topping: 'onion'});\n```\n\n## Structural directives\n\nA **structural directive** is any directive that:\n\n- Injects `TemplateRef`\n- Injects `ViewContainerRef` and programmatically renders the injected `TemplateRef`\n\nAngular supports a special convenience syntax for structural directives. If you apply the directive to an element and prefix the directive's selector with an asterisk (`*`) character, Angular interprets the entire element and all of its content as a template fragment:\n\n```angular-html\n<section *myDirective>\n  <p>This is a fragment</p>\n</section>\n```\n\nThis is equivalent to:\n\n```angular-html\n<ng-template myDirective>\n  <section>\n    <p>This is a fragment</p>\n  </section>\n</ng-template>\n```\n\nDevelopers typically use structural directives to conditionally render fragments or render fragments multiple times.\n\nFor more details, see [Structural Directives](/guide/directives/structural-directives).\n\n## Additional resources\n\nFor examples of how `ng-template` is used in other libraries, check out:\n\n- [Tabs from Angular Material](https://material.angular.io/components/tabs/overview) - nothing gets rendered into the DOM until the tab is activated\n- [Table from Angular Material](https://material.angular.io/components/table/overview) - allows developers to define different ways to render data\n\n\n\n================================================\n",
    "endLine": 16780
  },
  {
    "id": 84,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/templates/overview.md",
    "startLine": 16784,
    "content": "<docs-decorative-header title=\"Template syntax\" imgSrc=\"adev/src/assets/images/templates.svg\"> <!-- markdownlint-disable-line -->\nIn Angular, a template is a chunk of HTML.\nUse special syntax within a template to leverage many of Angular's features.\n</docs-decorative-header>\n\nTIP: Check out Angular's [Essentials](essentials/templates) before diving into this comprehensive guide.\n\nEvery Angular component has a **template** that defines the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) that the component renders onto the page. By using templates, Angular is able to automatically keep your page up-to-date as data changes.\n\nTemplates are usually found within either the `template` property of a `*.component.ts` file or the `*.component.html` file. To learn more, check out the [in-depth components guide](/guide/components).\n\n## How do templates work?\n\nTemplates are based on [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML) syntax, with additional features such as built-in template functions, data binding, event listening, variables, and more.\n\nAngular compiles templates into JavaScript in order to build up an internal understanding of your application. One of the benefits of this are built-in rendering optimizations that Angular applies to your application automatically.\n\n### Differences from standard HTML\n\nSome differences between templates and standard HTML syntax include:\n\n- Comments in the template source code are not included in the rendered output\n- Component and directive elements can be self-closed (e.g., `<UserProfile />`)\n- Attributes with certain characters (i.e., `[]`, `()`, etc.) have special meaning to Angular. See [binding docs](guide/templates/binding) and [adding event listeners docs](guide/templates/event-listeners) for more information.\n- The `@` character has a special meaning to Angular for adding dynamic behavior, such as [control flow](guide/templates/control-flow), to templates. You can include a literal `@` character by escaping it as an HTML entity code (`&commat;` or `&#64;`).\n- Angular ignores and collapses unnecessary whitespace characters. See [whitespace in templates](guide/templates/whitespace) for more details.\n- Angular may add comment nodes to a page as placeholders for dynamic content, but developers can ignore these.\n\nIn addition, while most HTML syntax is valid template syntax, Angular does not support `<script>` element in templates. For more information, see the [Security](best-practices/security) page.\n\n## What's next?\n\nYou might also be interested in the following:\n\n| Topics                                                                      | Details                                                                                 |\n| :-------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------- |\n| [Binding dynamic text, properties, and attributes](guide/templates/binding) | Bind dynamic data to text, properties and attributes.                                   |\n| [Adding event listeners](guide/templates/event-listeners)                   | Respond to events in your templates.                                                    |\n| [Two-way binding](guide/templates/two-way-binding)                          | Simultaneously binds a value and propagate changes.                                     |\n| [Control flow](guide/templates/control-flow)                                | Conditionally show, hide and repeat elements.                                           |\n| [Pipes](guide/templates/pipes)                                              | Transform data declaratively.                                                           |\n| [Slotting child content with ng-content](guide/templates/ng-content)        | Control how components render content.                                                  |\n| [Create template fragments with ng-template](guide/templates/ng-template)   | Declare a template fragment.                                                            |\n| [Grouping elements with ng-container](guide/templates/ng-container)         | Group multiple elements together or mark a location for rendering.                      |\n| [Variables in templates](guide/templates/variables)                         | Learn about variable declarations.                                                      |\n| [Deferred loading with @defer](guide/templates/defer)                       | Create deferrable views with `@defer`.                                                  |\n| [Expression syntax](guide/templates/expression-syntax)                      | Learn similarities and differences between Angular expressions and standard JavaScript. |\n| [Whitespace in templates](guide/templates/whitespace)                       | Learn how Angular handles whitespace.                                                   |\n\n\n\n================================================\n",
    "endLine": 16834
  },
  {
    "id": 85,
    "file": "pipes",
    "fullFileName": "adev/src/content/guide/templates/pipes.md",
    "startLine": 16838,
    "content": "# Pipes\n\n## Overview\n\nPipes are a special operator in Angular template expressions that allows you to transform data declaratively in your template. Pipes let you declare a transformation function once and then use that transformation across multiple templates. Angular pipes use the vertical bar character (`|`), inspired by the [Unix pipe](<https://en.wikipedia.org/wiki/Pipeline_(Unix)>).\n\nNOTE: Angular's pipe syntax deviates from standard JavaScript, which uses the vertical bar character for the [bitwise OR operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR). Angular template expressions do not support bitwise operators.\n\nHere is an example using some built-in pipes that Angular provides:\n\n```angular-ts\nimport { Component } from '@angular/core';\nimport { CurrencyPipe, DatePipe, TitleCasePipe } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [CurrencyPipe, DatePipe, TitleCasePipe],\n  template: `\n    <main>\n       <!-- Transform the company name to title-case and\n       transform the purchasedOn date to a locale-formatted string -->\n<h1>Purchases from {{ company | titlecase }} on {{ purchasedOn | date }}</h1>\n\n\t    <!-- Transform the amount to a currency-formatted string -->\n      <p>Total: {{ amount | currency }}</p>\n    </main>\n  `,\n})\nexport class ShoppingCartComponent {\n  amount = 123.45;\n  company = 'acme corporation';\n  purchasedOn = '2024-07-08';\n}\n```\n\nWhen Angular renders the component, it will ensure that the appropriate date format and currency is based on the locale of the user. If the user is in the United States, it would render:\n\n```angular-html\n<main>\n  <h1>Purchases from Acme Corporation on Jul 8, 2024</h1>\n  <p>Total: $123.45</p>\n</main>\n```\n\nSee the [in-depth guide on i18n](/guide/i18n) to learn more about how Angular localizes values.\n\n### Built-in Pipes\n\nAngular includes a set of built-in pipes in the `@angular/common` package:\n\n| Name                                          | Description                                                                                   |\n| --------------------------------------------- | --------------------------------------------------------------------------------------------- |\n| [`AsyncPipe`](api/common/AsyncPipe)           | Read the value from a `Promise` or an RxJS `Observable`.                                      |\n| [`CurrencyPipe`](api/common/CurrencyPipe)     | Transforms a number to a currency string, formatted according to locale rules.                |\n| [`DatePipe`](api/common/DatePipe)             | Formats a `Date` value according to locale rules.                                             |\n| [`DecimalPipe`](api/common/DecimalPipe)       | Transforms a number into a string with a decimal point, formatted according to locale rules.  |\n| [`I18nPluralPipe`](api/common/I18nPluralPipe) | Maps a value to a string that pluralizes the value according to locale rules.                 |\n| [`I18nSelectPipe`](api/common/I18nSelectPipe) | Maps a key to a custom selector that returns a desired value.                                 |\n| [`JsonPipe`](api/common/JsonPipe)             | Transforms an object to a string representation via `JSON.stringify`, intended for debugging. |\n| [`KeyValuePipe`](api/common/KeyValuePipe)     | Transforms Object or Map into an array of key value pairs.                                    |\n| [`LowerCasePipe`](api/common/LowerCasePipe)   | Transforms text to all lower case.                                                            |\n| [`PercentPipe`](api/common/PercentPipe)       | Transforms a number to a percentage string, formatted according to locale rules.              |\n| [`SlicePipe`](api/common/SlicePipe)           | Creates a new Array or String containing a subset (slice) of the elements.                    |\n| [`TitleCasePipe`](api/common/TitleCasePipe)   | Transforms text to title case.                                                                |\n| [`UpperCasePipe`](api/common/UpperCasePipe)   | Transforms text to all upper case.                                                            |\n\n## Using pipes\n\nAngular's pipe operator uses the vertical bar character (`|`), within a template expression. The pipe operator is a binary operator– the left-hand operand is the value passed to the transformation function, and the right side operand is the name of the pipe and any additional arguments (described below).\n\n```angular-html\n<p>Total: {{ amount | currency }}</p>\n```\n\nIn this example, the value of `amount` is passed into the `CurrencyPipe` where the pipe name is `currency`. It then renders the default currency for the user’s locale.\n\n### Combining multiple pipes in the same expression\n\nYou can apply multiple transformations to a value by using multiple pipe operators. Angular runs the pipes from left to right.\n\nThe following example demonstrates a combination of pipes to display a localized date in all uppercase:\n\n```angular-html\n<p>The event will occur on {{ scheduledOn | date | uppercase }}.</p>\n```\n\n### Passing parameters to pipes\n\nSome pipes accept parameters to configure the transformation. To specify a parameter, append the pipe name with a colon (`:`) followed by the parameter value.\n\nFor example, the `DatePipe` is able to take parameters to format the date in a specific way.\n\n```angular-html\n<p>The event will occur at {{ scheduledOn | date:'hh:mm' }}.</p>\n```\n\nSome pipes may accept multiple parameters. You can specify additional parameter values separated by the colon character (`:`).\n\nFor example, we can also pass a second optional parameter to control the timezone.\n\n```angular-html\n<p>The event will occur at {{ scheduledOn | date:'hh:mm':'UTC' }}.</p>\n```\n\n## How pipes work\n\nConceptually, pipes are functions that accept an input value and return a transformed value.\n\n```angular-ts\nimport { Component } from '@angular/core';\nimport { CurrencyPipe} from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  imports: [CurrencyPipe],\n  template: `\n    <main>\n      <p>Total: {{ amount | currency }}</p>\n    </main>\n  `,\n})\nexport class AppComponent {\n  amount = 123.45;\n}\n```\n\nIn this example:\n\n1. `CurrencyPipe` is imported from `@angular/common`\n1. `CurrencyPipe` is added to the `imports` array\n1. The `amount` data is passed to the `currency` pipe\n\n### Pipe operator precedence\n\nThe pipe operator has lower precedence than other binary operators, including `+`, `-`, `*`, `/`, `%`, `&&`, `||`, and `??`.\n\n```angular-html\n<!-- firstName and lastName are concatenated before the result is passed to the uppercase pipe -->\n{{ firstName + lastName | uppercase }}\n```\n\nThe pipe operator has higher precedence than the conditional (ternary) operator.\n\n```angular-html\n{{ (isAdmin ? 'Access granted' : 'Access denied') | uppercase }}\n```\n\nIf the same expression were written without parentheses:\n\n```angular-html\n{{ isAdmin ? 'Access granted' : 'Access denied' | uppercase }}\n```\n\nIt will be parsed instead as:\n\n```angular-html\n{{ isAdmin ? 'Access granted' : ('Access denied' | uppercase) }}\n```\n\nAlways use parentheses in your expressions when operator precedence may be ambiguous.\n\n### Change detection with pipes\n\nBy default, all pipes are considered `pure`, which means that it only executes when a primitive input value (such as a `String`, `Number`, `Boolean`, or `Symbol`) or a changed object reference (such as `Array`, `Object`, `Function`, or `Date`). Pure pipes offer a performance advantage because Angular can avoid calling the transformation function if the passed value has not changed.\n\nAs a result, this means that mutations to object properties or array items are not detected unless the entire object or array reference is replaced with a different instance. If you want this level of change detection, refer to [detecting changes within arrays or objects](#detecting-change-within-arrays-or-objects).\n\n## Creating custom pipes\n\nYou can define a custom pipe by implementing a TypeScript class with the `@Pipe` decorator. A pipe must have two things:\n\n- A name, specified in the pipe decorator\n- A method named `transform` that performs the value transformation.\n\nThe TypeScript class should additionally implement the `PipeTransform` interface to ensure that it satisfies the type signature for a pipe.\n\nHere is an example of a custom pipe that transforms strings to kebab case:\n\n```angular-ts\n// kebab-case.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'kebabCase',\n})\nexport class KebabCasePipe implements PipeTransform {\n  transform(value: string): string {\n    return value.toLowerCase().replace(/ /g, '-');\n  }\n}\n```\n\n### Using the `@Pipe` decorator\n\nWhen creating a custom pipe, import `Pipe` from the `@angular/core` package and use it as a decorator for the TypeScript class.\n\n```angular-ts\nimport { Pipe } from '@angular/core';\n\n@Pipe({\n  name: 'myCustomTransformation',\n})\nexport class MyCustomTransformationPipe {}\n```\n\nThe `@Pipe` decorator requires a `name` that controls how the pipe is used in a template.\n\n### Naming convention for custom pipes\n\nThe naming convention for custom pipes consists of two conventions:\n\n- `name` - camelCase is recommended. Do not use hyphens.\n- `class name` - PascalCase version of the `name` with `Pipe` appended to the end\n\n### Implement the `PipeTransform` interface\n\nIn addition to the `@Pipe` decorator, custom pipes should always implement the `PipeTransform` interface from `@angular/core`.\n\n```angular-ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'myCustomTransformation',\n})\nexport class MyCustomTransformationPipe implements PipeTransform {}\n```\n\nImplementing this interface ensures that your pipe class has the correct structure.\n\n### Transforming the value of a pipe\n\nEvery transformation is invoked by the `transform` method with the first parameter being the value being passed in and the return value being the transformed value.\n\n```angular-ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'myCustomTransformation',\n})\nexport class MyCustomTransformationPipe implements PipeTransform {\n  transform(value: string): string {\n    return `My custom transformation of ${value}.`\n  }\n}\n```\n\n### Adding parameters to a custom pipe\n\nYou can add parameters to your transformation by adding additional parameters to the `transform` method:\n\n```angular-ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'myCustomTransformation',\n})\nexport class MyCustomTransformationPipe implements PipeTransform {\n  transform(value: string, format: string): string {\n    let msg = `My custom transformation of ${value}.`\n\n    if (format === 'uppercase') {\n      return msg.toUpperCase()\n    } else {\n      return msg\n    }\n  }\n}\n```\n\n### Detecting change within arrays or objects\n\nWhen you want a pipe to detect changes within arrays or objects, it must be marked as an impure function by passing the `pure` flag with a value of `false`.\n\nAvoid creating impure pipes unless absolutely necessary, as they can incur a significant performance penalty if used without care.\n\n```angular-ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'joinNamesImpure',\n  pure: false,\n})\nexport class JoinNamesImpurePipe implements PipeTransform {\n  transform(names: string[]): string {\n    return names.join();\n  }\n}\n```\n\nAngular developers often adopt the convention of including `Impure` in the pipe `name` and class name to indicate the potential performance pitfall to other developers.\n\n\n\n================================================\n",
    "endLine": 17130
  },
  {
    "id": 86,
    "file": "two-way-binding",
    "fullFileName": "adev/src/content/guide/templates/two-way-binding.md",
    "startLine": 17134,
    "content": "# Two-way binding\n\n**Two way binding** is a shorthand to simultaneously bind a value into an element, while also giving that element the ability to propagate changes back through this binding.\n\n## Syntax\n\nThe syntax for two-way binding is a combination of square brackets and parentheses, `[()]`. It combines the syntax from property binding, `[]`, and the syntax from event binding, `()`. The Angular community informally refers to this syntax as \"banana-in-a-box\".\n\n## Two-way binding with form controls\n\nDevelopers commonly use two-way binding to keep component data in sync with a form control as a user interacts with the control. For example, when a user fills out a text input, it should update the state in the component.\n\nThe following example dynamically updates the `firstName` attribute on the page:\n\n```angular-ts\nimport { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  imports: [FormsModule],\n  template: `\n    <main>\n      <h2>Hello {{ firstName }}!</h2>\n      <input type=\"text\" [(ngModel)]=\"firstName\" />\n    </main>\n  `\n})\nexport class AppComponent {\n  firstName = 'Ada';\n}\n```\n\nTo use two-way binding with native form controls, you need to:\n\n1. Import the `FormsModule` from `@angular/forms`\n1. Use the `ngModel` directive with the two-way binding syntax (e.g., `[(ngModel)]`)\n1. Assign it the state that you want it to update (e.g., `firstName`)\n\nOnce that is set up, Angular will ensure that any updates in the text input will reflect correctly inside of the component state!\n\nLearn more about [`NgModel`](guide/directives#displaying-and-updating-properties-with-ngmodel) in the official docs.\n\n## Two-way binding between components\n\nLeveraging two-way binding between a parent and child component requires more configuration compared to form elements.\n\nHere is an example where the `AppComponent` is responsible for setting the initial count state, but the logic for updating and rendering the UI for the counter primarily resides inside its child `CounterComponent`.\n\n```angular-ts\n// ./app.component.ts\nimport { Component } from '@angular/core';\nimport { CounterComponent } from './counter/counter.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [CounterComponent],\n  template: `\n    <main>\n      <h1>Counter: {{ initialCount }}</h1>\n      <app-counter [(count)]=\"initialCount\"></app-counter>\n    </main>\n  `,\n})\nexport class AppComponent {\n  initialCount = 18;\n}\n```\n\n```angular-ts\n// './counter/counter.component.ts';\nimport { Component, model } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <button (click)=\"updateCount(-1)\">-</button>\n    <span>{{ count() }}</span>\n    <button (click)=\"updateCount(+1)\">+</button>\n  `,\n})\nexport class CounterComponent {\n  count = model<number>(0);\n\n  updateCount(amount: number): void {\n    this.count.update(currentCount => currentCount + amount);\n  }\n}\n```\n\n### Enabling two-way binding between components\n\nIf we break down the example above to its core, each two-way binding for components requires the following:\n\nThe child component must contain a `model` property.\n\nHere is a simplified example:\n\n```angular-ts\n// './counter/counter.component.ts';\nimport { Component, model } from '@angular/core';\n\n@Component({ // Omitted for brevity })\nexport class CounterComponent {\n  count = model<number>(0);\n\n  updateCount(amount: number): void {\n    this.count.update(currentCount => currentCount + amount);\n  }\n}\n```\n\nThe parent component must:\n\n1. Wrap the `model` property name in the two-way binding syntax.\n1. Assign a property or a signal to the `model` property.\n\nHere is a simplified example:\n\n```angular-ts\n// ./app.component.ts\nimport { Component } from '@angular/core';\nimport { CounterComponent } from './counter/counter.component';\n\n@Component({\n  selector: 'app-root',\n  imports: [CounterComponent],\n  template: `\n    <main>\n      <app-counter [(count)]=\"initialCount\"></app-counter>\n    </main>\n  `,\n})\nexport class AppComponent {\n  initialCount = 18;\n}\n```\n\n\n\n================================================\n",
    "endLine": 17272
  },
  {
    "id": 87,
    "file": "variables",
    "fullFileName": "adev/src/content/guide/templates/variables.md",
    "startLine": 17276,
    "content": "# Variables in templates\n\nAngular has two types of variable declarations in templates: local template variables and template reference variables.\n\n## Local template variables with `@let`\n\nAngular's `@let` syntax allows you to define a local variable and re-use it across a template, similar to the [JavaScript `let` syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let).\n\n### Using `@let`\n\nUse `@let` to declare a variable whose value is based on the result of a template expression. Angular automatically keeps the variable's value up-to-date with the given expression, similar to [bindings](./templates/bindings).\n\n```angular-html\n@let name = user.name;\n@let greeting = 'Hello, ' + name;\n@let data = data$ | async;\n@let pi = 3.1459;\n@let coordinates = {x: 50, y: 100};\n@let longExpression = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit ' +\n                      'sed do eiusmod tempor incididunt ut labore et dolore magna ' +\n                      'Ut enim ad minim veniam...';\n```\n\nEach `@let` block can declare exactly one variable. You cannot declare multiple variables in the same block with a comma.\n\n### Referencing the value of `@let`\n\nOnce you've declared a variable with `@let`, you can reuse it in the same template:\n\n```angular-html\n@let user = user$ | async;\n\n@if (user) {\n  <h1>Hello, {{user.name}}</h1>\n  <user-avatar [photo]=\"user.photo\"/>\n\n  <ul>\n    @for (snack of user.favoriteSnacks; track snack.id) {\n      <li>{{snack.name}}</li>\n    }\n  </ul>\n\n  <button (click)=\"update(user)\">Update profile</button>\n}\n```\n\n### Assignability\n\nA key difference between `@let` and JavaScript's `let` is that `@let` cannot be reassigned after declaration. However, Angular automatically keeps the variable's value up-to-date with the given expression.\n\n```angular-html\n@let value = 1;\n\n<!-- Invalid - This does not work! -->\n<button (click)=\"value = value + 1\">Increment the value</button>\n```\n\n### Variable scope\n\n`@let` declarations are scoped to the current view and its descendants. Angular creates a new view at component boundaries and wherever a template might contain dynamic content, such as control flow blocks, `@defer` blocks, or structural directives.\n\nSince `@let` declarations are not hoisted, they **cannot** be accessed by parent views or siblings:\n\n```angular-html\n@let topLevel = value;\n\n<div>\n  @let insideDiv = value;\n</div>\n\n{{topLevel}} <!-- Valid -->\n{{insideDiv}} <!-- Valid -->\n\n@if (condition) {\n  {{topLevel + insideDiv}} <!-- Valid -->\n\n  @let nested = value;\n\n  @if (condition) {\n    {{topLevel + insideDiv + nested}} <!-- Valid -->\n  }\n}\n\n<div *ngIf=\"condition\">\n  {{topLevel + insideDiv}} <!-- Valid -->\n\n  @let nestedNgIf = value;\n\n  <div *ngIf=\"condition\">\n     {{topLevel + insideDiv + nestedNgIf}} <!-- Valid -->\n  </div>\n</div>\n\n{{nested}} <!-- Error, not hoisted from @if -->\n{{nestedNgIf}} <!-- Error, not hoisted from *ngIf -->\n```\n\n### Full syntax\n\nThe `@let` syntax is formally defined as:\n\n- The `@let` keyword.\n- Followed by one or more whitespaces, not including new lines.\n- Followed by a valid JavaScript name and zero or more whitespaces.\n- Followed by the = symbol and zero or more whitespaces.\n- Followed by an Angular expression which can be multi-line.\n- Terminated by the `;` symbol.\n\n## Template reference variables\n\nTemplate reference variables give you a way to declare a variable that references a value from an element in your template.\n\nA template reference variable can refer to the following:\n\n- a DOM element within a template (including [custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements))\n- an Angular component or directive\n- a [TemplateRef](/api/core/TemplateRef) from an [ng-template](/api/core/ng-template)\n\nYou can use template reference variables to read information from one part of the template in another part of the same template.\n\n### Declaring a template reference variable\n\nYou can declare a variable on an element in a template by adding an attribute that starts with the hash character (`#`) followed by the variable name.\n\n```angular-html\n<!-- Create a template reference variable named \"taskInput\", referring to the HTMLInputElement. -->\n<input #taskInput placeholder=\"Enter task name\">\n```\n\n### Assigning values to template reference variables\n\nAngular assigns a value to template variables based on the element on which the variable is declared.\n\nIf you declare the variable on a Angular component, the variable refers to the component instance.\n\n```angular-html\n<!-- The `startDate` variable is assigned the instance of `MyDatepicker`. -->\n<my-datepicker #startDate />\n```\n\nIf you declare the variable on an `<ng-template>` element, the variable refers to a TemplateRef instance which represents the template. For more information, see [How Angular uses the asterisk, \\*, syntax](/guide/directives/structural-directives#asterisk) in [Structural directives](/guide/directives/structural-directives).\n\n```angular-html\n<!-- The `myFragment` variable is assigned the `TemplateRef` instance corresponding to this template fragment. -->\n<ng-template #myFragment>\n  <p>This is a template fragment</p>\n</ng-template>\n```\n\nIf you declare the variable on any other displayed element, the variable refers to the `HTMLElement` instance.\n\n```angular-html\n<!-- The \"taskInput\" variable refers to the HTMLInputElement instance. -->\n<input #taskInput placeholder=\"Enter task name\">\n```\n\n#### Assigning a reference to an Angular directive\n\nAngular directives may have an `exportAs` property that defines a name by which the directive can be referenced in a template:\n\n```angular-ts\n@Directive({\n  selector: '[dropZone]',\n  exportAs: 'dropZone',\n})\nexport class DropZone { /* ... */ }\n```\n\nWhen you declare a template variable on an element, you can assign that variable a directive instance by specifying this `exportAs` name:\n\n```angular-html\n<!-- The `firstZone` variable refers to the `DropZone` directive instance. -->\n<section dropZone #firstZone=\"dropZone\"> ... </section>\n```\n\nYou cannot refer to a directive that does not specify an `exportAs` name.\n\n### Using template reference variables with queries\n\nIn addition to using template variables to read values from another part of the same template, you can also use this style of variable declaration to \"mark\" an element for [component and directive queries](/guide/components/queries).\n\nWhen you want to query for a specific element in a template, you can declare a template variable on that element and then query for the element based on the variable name.\n\n```angular-html\n <input #description value=\"Original description\">\n```\n\n```angular-ts\n@Component({\n  /* ... */,\n  template: `<input #description value=\"Original description\">`,\n})\nexport class AppComponent {\n  // Query for the input element based on the template variable name.\n  @ViewChild('description') input: ElementRef | undefined;\n}\n```\n\nSee [Referencing children with queries](/guide/components/queries) for more information on queries.\n\n\n\n================================================\n",
    "endLine": 17477
  },
  {
    "id": 88,
    "file": "whitespace",
    "fullFileName": "adev/src/content/guide/templates/whitespace.md",
    "startLine": 17481,
    "content": "# Whitespace in templates\n\nBy default, Angular templates do not preserve whitespace that the framework considers unnecessary. This commonly occurs in two situations: whitespace between elements, and collapsible whitespace inside of text.\n\n## Whitespace between elements\n\nMost developers prefer to format their templates with newlines and indentation to make the template readable:\n\n```angular-html\n<section>\n  <h3>User profile</p>\n  <label>\n    User name\n    <input>\n  </label>\n</section>\n```\n\nThis template contains whitespace between all of the elements. The following snippet shows the same HTML with each whitespace character replaced with the hash (`#`) character to highlight how much whitespace is present:\n\n```angular-html\n<!-- Total Whitespace: 20 -->\n<section>###<h3>User profile</p>###<label>#####User name#####<input>###</label>#</section>\n```\n\nPreserving the whitespace as written in the template would result in many unnecessary [text nodes](https://developer.mozilla.org/en-US/docs/Web/API/Text) and increase page rendering overhead. By ignoring this whitespace between elements, Angular performs less work when rendering the template on the page, improving overall performance.\n\n## Collapsible whitespace inside text\n\nWhen your web browser renders HTML on a page, it collapses multiple consecutive whitespace characters to a single character:\n\n```angular-html\n<!-- What it looks like in the template -->\n<p>Hello         world</p>\n```\n\nIn this example, the browser displays only a single space between \"Hello\" and \"world\".\n\n```angular-html\n<!-- What shows up in the browser -->\n<p>Hello world</p>\n```\n\nSee [How whitespace is handled by HTML, CSS, and in the DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace) for more context on how this works.\n\nAngular avoids sending these unnecessary whitespace characters to the browser in the first place by collapsing them to a single character when it compiles the template.\n\n## Preserving whitespace\n\nYou can tell Angular to preserve whitespace in a template by specifying `preserveWhitespaces: true` in the `@Component` decorator for a template.\n\n```angular-ts\n@Component({\n  /* ... */,\n  preserveWhitespaces: true,\n  template: `\n    <p>Hello         world</p>\n  `\n})\n```\n\nAvoid setting this option unless absolutely necessary. Preserving whitespace can cause Angular to produce significantly more nodes while rendering, slowing down your application.\n\nYou can additionally use a special HTML entity unique to Angular, `&ngsp;`. This entity produces a single space character that's preserved in the compiled output.\n\n\n\n================================================\n",
    "endLine": 17547
  },
  {
    "id": 89,
    "file": "attribute-directives",
    "fullFileName": "adev/src/content/guide/testing/attribute-directives.md",
    "startLine": 17551,
    "content": "\n# Testing Attribute Directives\n\nAn *attribute directive* modifies the behavior of an element, component or another directive.\nIts name reflects the way the directive is applied: as an attribute on a host element.\n\n## Testing the `HighlightDirective`\n\nThe sample application's `HighlightDirective` sets the background color of an element based on either a data bound color or a default color \\(lightgray\\).\nIt also sets a custom property of the element \\(`customProperty`\\) to `true` for no reason other than to show that it can.\n\n<docs-code header=\"app/shared/highlight.directive.ts\" path=\"adev/src/content/examples/testing/src/app/shared/highlight.directive.ts\"/>\n\nIt's used throughout the application, perhaps most simply in the `AboutComponent`:\n\n<docs-code header=\"app/about/about.component.ts\" path=\"adev/src/content/examples/testing/src/app/about/about.component.ts\"/>\n\nTesting the specific use of the `HighlightDirective` within the `AboutComponent` requires only the techniques explored in the [\"Nested component tests\"](guide/testing/components-scenarios#nested-component-tests) section of [Component testing scenarios](guide/testing/components-scenarios).\n\n<docs-code header=\"app/about/about.component.spec.ts\" path=\"adev/src/content/examples/testing/src/app/about/about.component.spec.ts\" visibleRegion=\"tests\"/>\n\nHowever, testing a single use case is unlikely to explore the full range of a directive's capabilities.\nFinding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.\n\n*Class-only tests* might be helpful, but attribute directives like this one tend to manipulate the DOM.\nIsolated unit tests don't touch the DOM and, therefore, do not inspire confidence in the directive's efficacy.\n\nA better solution is to create an artificial test component that demonstrates all ways to apply the directive.\n\n<docs-code header=\"app/shared/highlight.directive.spec.ts (TestComponent)\" path=\"adev/src/content/examples/testing/src/app/shared/highlight.directive.spec.ts\" visibleRegion=\"test-component\"/>\n\n<img alt=\"HighlightDirective spec in action\" src=\"assets/images/guide/testing/highlight-directive-spec.png\">\n\nHELPFUL: The `<input>` case binds the `HighlightDirective` to the name of a color value in the input box.\nThe initial value is the word \"cyan\" which should be the background color of the input box.\n\nHere are some tests of this component:\n\n<docs-code header=\"app/shared/highlight.directive.spec.ts (selected tests)\" path=\"adev/src/content/examples/testing/src/app/shared/highlight.directive.spec.ts\" visibleRegion=\"selected-tests\"/>\n\nA few techniques are noteworthy:\n\n* The `By.directive` predicate is a great way to get the elements that have this directive *when their element types are unknown*\n* The [`:not` pseudo-class](https://developer.mozilla.org/docs/Web/CSS/:not) in `By.css('h2:not([highlight])')` helps find `<h2>` elements that *do not* have the directive.\n    `By.css('*:not([highlight])')` finds *any* element that does not have the directive.\n\n* `DebugElement.styles` affords access to element styles even in the absence of a real browser, thanks to the `DebugElement` abstraction.\n    But feel free to exploit the `nativeElement` when that seems easier or more clear than the abstraction.\n\n* Angular adds a directive to the injector of the element to which it is applied.\n    The test for the default color uses the injector of the second `<h2>` to get its `HighlightDirective` instance and its `defaultColor`.\n\n* `DebugElement.properties` affords access to the artificial custom property that is set by the directive\n\n\n\n================================================\nFILE: adev/src/content/guide/testing/BUILD.bazel\n================================================\nload(\"//adev/shared-docs:index.bzl\", \"generate_guides\")\n\ngenerate_guides(\n    name = \"testing\",\n    srcs = glob([\n        \"*.md\",\n    ]),\n    data = [\n        \"//adev/src/content/examples\",\n    ],\n    visibility = [\"//adev:__subpackages__\"],\n)\n\n\n\n================================================\n",
    "endLine": 17624
  },
  {
    "id": 90,
    "file": "code-coverage",
    "fullFileName": "adev/src/content/guide/testing/code-coverage.md",
    "startLine": 17628,
    "content": "\n# Find out how much code you're testing\n\nThe Angular CLI can run unit tests and create code coverage reports.\nCode coverage reports show you any parts of your code base that might not be properly tested by your unit tests.\n\nTo generate a coverage report run the following command in the root of your project.\n\n<docs-code language=\"shell\">\nng test --no-watch --code-coverage\n</docs-code>\n\nWhen the tests are complete, the command creates a new `/coverage` directory in the project.\nOpen the `index.html` file to see a report with your source code and code coverage values.\n\nIf you want to create code-coverage reports every time you test, set the following option in the Angular CLI configuration file, `angular.json`:\n\n<docs-code language=\"json\">\n\"test\": {\n  \"options\": {\n    \"codeCoverage\": true\n  }\n}\n</docs-code>\n\n## Code coverage enforcement\n\nThe code coverage percentages let you estimate how much of your code is tested.\nIf your team decides on a set minimum amount to be unit tested, enforce this minimum with the Angular CLI.\n\nFor example, suppose you want the code base to have a minimum of 80% code coverage.\nTo enable this, open the [Karma](https://karma-runner.github.io) test platform configuration file, `karma.conf.js`, and add the `check` property in the `coverageReporter:` key.\n\n<docs-code language=\"javascript\">\ncoverageReporter: {\n  dir: require('path').join(__dirname, './coverage/<project-name>'),\n  subdir: '.',\n  reporters: [\n    { type: 'html' },\n    { type: 'text-summary' }\n  ],\n  check: {\n    global: {\n      statements: 80,\n      branches: 80,\n      functions: 80,\n      lines: 80\n    }\n  }\n}\n</docs-code>\n\nHELPFUL: Read more about creating and fine tuning Karma configuration in the [testing guide](guide/testing#configuration).\n\nThe `check` property causes the tool to enforce a minimum of 80% code coverage when the unit tests are run in the project.\n\nRead more on coverage configuration options in the [karma coverage documentation](https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md).\n\n\n\n================================================\n",
    "endLine": 17687
  },
  {
    "id": 91,
    "file": "component-harnesses-overview",
    "fullFileName": "adev/src/content/guide/testing/component-harnesses-overview.md",
    "startLine": 17691,
    "content": "# Component harnesses overview\n\nA <strong>component harness</strong> is a class that allows tests to interact with components the way an end user does via a supported API. You can create test harnesses for any component, ranging from small reusable widgets to full pages.\n\nHarnesses offer several benefits:\n- They make tests less brittle by insulating themselves against implementation details of a component, such as its DOM structure\n- They make tests become more readable and easier to maintain\n- They can be used across multiple testing environments\n\n<docs-code language=\"typescript\">\n// Example of test with a harness for a component called MyButtonComponent\nit('should load button with exact text', async () => {\n  const button = await loader.getHarness(MyButtonComponentHarness);\n  expect(await button.getText()).toBe('Confirm');\n});\n</docs-code>\n\nComponent harnesses are especially useful for shared UI widgets. Developers often write tests that depend on private implementation details of widgets, such as DOM structure and CSS classes. Those dependencies make tests brittle and hard to maintain. Harnesses offer an alternative— a supported API that interacts with the widget the same way an end-user does. Widget implementation changes now become less likely to break user tests. For example, [Angular Material](https://material.angular.io/components/categories) provides a test harness for each component in the library.\n\nComponent harnesses support multiple testing environments. You can use the same harness implementation in both unit and end-to-end tests. Test authors only need to learn one API and component authors don't have to maintain separate unit and end-to-end test implementations.\n\nMany developers can be categorized by one of the following developer type categories: test authors, component harness authors, and harness environment authors. Use the table below to find the most relevant section in this guide based on these categories:\n\n| Developer Type              | Description           | Relevant Section      |\n|:---                         | :---                  | :---                  |\n| Test Authors                | Developers that use component harnesses written by someone else to test their application. For example, this could be an app developer who uses a third-party menu component and needs to interact with the menu in a unit test. | [Using component harnesses in tests](guide/testing/using-component-harnesses) |\n| Component harness authors   | Developers who maintain some reusable Angular components and want to create a test harness for its users to use in their tests. For example, an author of a third party Angular component library or a developer who maintains a set of common components for a large Angular application. | [Creating component harnesses for your components](guide/testing/creating-component-harnesses ) |\n| Harness environment authors | Developers who want to add support for using component harnesses in additional testing environments. For information on supported testing environments out-of-the-box, see the [test harness environments and loaders](guide/testing/using-component-harnesses#test-harness-environments-and-loaders). | [Adding support for additional testing environments](guide/testing/component-harnesses-testing-environments) |\n\nFor the full API reference, please see the [Angular CDK's component harness API reference page](https://material.angular.io/cdk/testing/api).\n\n\n\n================================================\n",
    "endLine": 17723
  },
  {
    "id": 92,
    "file": "component-harnesses-testing-environments",
    "fullFileName": "adev/src/content/guide/testing/component-harnesses-testing-environments.md",
    "startLine": 17727,
    "content": "# Adding harness support for additional testing environments\n\n## Before you start\n\nTIP: This guide assumes you've already read the [component harnesses overview guide](guide/testing/component-harnesses-overview). Read that first if you're new to using component harnesses.\n\n### When does adding support for a test environment make sense?\n\nTo use component harnesses in the following environments, you can use Angular CDK's two built-in environments:\n- Unit tests\n- WebDriver end-to-end tests\n\nTo use a supported testing environment, read the [Creating harnesses for your components guide](guide/testing/creating-component-harnesses).\n\nOtherwise, to add support for other environments, you need to define how to interact with a DOM element and how DOM interactions work in your environment. Continue reading to learn more.\n\n### CDK Installation\n\nThe [Component Dev Kit (CDK)](https://material.angular.io/cdk/categories) is a set of behavior primitives for building components. To use the component harnesses, first install `@angular/cdk` from npm. You can do this from your terminal using the Angular CLI:\n\n<docs-code language=\"shell\">\n  ng add @angular/cdk\n</docs-code>\n\n## Creating a `TestElement` implementation\n\nEvery test environment must define a `TestElement` implementation. The `TestElement` interface serves as an environment-agnostic representation of a DOM element. It enables harnesses to interact with DOM elements regardless of the underlying environment. Because some environments don't support interacting with DOM elements synchronously (e.g. WebDriver), all `TestElement` methods are asynchronous, returning a `Promise` with the result of the operation.\n\n`TestElement` offers a number of methods to interact with the underlying DOM such as `blur()`, `click()`, `getAttribute()`, and more. See the [TestElement API reference page](https://material.angular.io/cdk/testing/api#TestElement) for the full list of methods.\n\nThe `TestElement` interface consists largely of methods that resemble methods available on `HTMLElement`. Similar methods exist in most test environments, which makes implementing the methods fairly straightforward. However, one important difference to note when implementing the `sendKeys` method, is that the key codes in the `TestKey` enum likely differ from the key codes used in the test environment. Environment authors should maintain a mapping from `TestKey` codes to the codes used in the particular testing environment.\n\nThe [UnitTestElement](https://github.com/angular/components/blob/main/src/cdk/testing/testbed/unit-test-element.ts#L33) and [SeleniumWebDriverElement](https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-webdriver-keys.ts#L16) implementations in Angular CDK serve as good examples of implementations of this interface.\n\n## Creating a `HarnessEnvironment` implementation\nTest authors use `HarnessEnvironment` to create component harness instances for use in tests. `HarnessEnvironment` is an abstract class that must be extended to create a concrete subclass for the new environment. When supporting a new test environment, create a `HarnessEnvironment` subclass that adds concrete implementations for all abstract members.\n\n`HarnessEnvironment` has a generic type parameter: `HarnessEnvironment<E>`. This parameter, `E`, represents the raw element type of the environment. For example, this parameter is Element for unit test environments.\n\nThe following are the abstract methods that must be implemented:\n\n| Method                                                        | Description           |\n|:---                                                           | :---                  |\n| `abstract getDocumentRoot(): E`                               | Gets the root element for the environment (e.g. `document.body`). |\n| `abstract createTestElement(element: E): TestElement`         | Creates a `TestElement` for the given raw element. |\n| `abstract createEnvironment(element: E): HarnessEnvironment`  | Creates a `HarnessEnvironment` rooted at the given raw element. |\n| `abstract getAllRawElements(selector: string): Promise<E[]>`  | Gets all of the raw elements under the root element of the environment matching the given selector. |\n| `abstract forceStabilize(): Promise<void>`                    | Gets a `Promise` that resolves when the `NgZone` is stable. Additionally, if applicable, tells `NgZone` to stabilize (e.g. calling `flush()` in a `fakeAsync` test). |\n| `abstract waitForTasksOutsideAngular(): Promise<void>`        | Gets a `Promise` that resolves when the parent zone of `NgZone` is stable. |\n\nIn addition to implementing the missing methods, this class should provide a way for test authors to get `ComponentHarness` instances. You should define a protected constructor and provide a static method called `loader` that returns a `HarnessLoader` instance. This allows test authors to write code like: `SomeHarnessEnvironment.loader().getHarness(...)`. Depending on the needs of the particular environment, the class may provide several different static methods or require arguments to be passed. (e.g. the `loader` method on `TestbedHarnessEnvironment` takes a `ComponentFixture`, and the class provides additional static methods called `documentRootLoader` and `harnessForFixture`).\n\nThe [`TestbedHarnessEnvironment`](https://github.com/angular/components/blob/main/src/cdk/testing/testbed/testbed-harness-environment.ts#L89) and [SeleniumWebDriverHarnessEnvironment](https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts#L71) implementations in Angular CDK serve as good examples of implementations of this interface.\n\n## Handling auto change detection\nIn order to support the `manualChangeDetection` and parallel APIs, your environment should install a handler for the auto change detection status.\n\nWhen your environment wants to start handling the auto change detection status it can call `handleAutoChangeDetectionStatus(handler)`. The handler function will receive a `AutoChangeDetectionStatus` which has two properties `isDisabled` and `onDetectChangesNow()`. See the [AutoChangeDetectionStatus API reference page](https://material.angular.io/cdk/testing/api#AutoChangeDetectionStatus) for more information.\nIf your environment wants to stop handling auto change detection status it can call `stopHandlingAutoChangeDetectionStatus()`.\n\n\n\n================================================\n",
    "endLine": 17788
  },
  {
    "id": 93,
    "file": "components-basics",
    "fullFileName": "adev/src/content/guide/testing/components-basics.md",
    "startLine": 17792,
    "content": "# Basics of testing components\n\nA component, unlike all other parts of an Angular application, combines an HTML template and a TypeScript class.\nThe component truly is the template and the class *working together*.\nTo adequately test a component, you should test that they work together as intended.\n\nSuch tests require creating the component's host element in the browser DOM, as Angular does, and investigating the component class's interaction with the DOM as described by its template.\n\nThe Angular `TestBed` facilitates this kind of testing as you'll see in the following sections.\nBut in many cases, *testing the component class alone*, without DOM involvement, can validate much of the component's behavior in a straightforward, more obvious way.\n\n## Component DOM testing\n\nA component is more than just its class.\nA component interacts with the DOM and with other components.\nClasses alone cannot tell you if the component is going to render properly, respond to user input and gestures, or integrate with its parent and child components.\n\n* Is `Lightswitch.clicked()` bound to anything such that the user can invoke it?\n* Is the `Lightswitch.message` displayed?\n* Can the user actually select the hero displayed by `DashboardHeroComponent`?\n* Is the hero name displayed as expected \\(such as uppercase\\)?\n* Is the welcome message displayed by the template of `WelcomeComponent`?\n\nThese might not be troubling questions for the preceding simple components illustrated.\nBut many components have complex interactions with the DOM elements described in their templates, causing HTML to appear and disappear as the component state changes.\n\nTo answer these kinds of questions, you have to create the DOM elements associated with the components, you must examine the DOM to confirm that component state displays properly at the appropriate times, and you must simulate user interaction with the screen to determine whether those interactions cause the component to behave as expected.\n\nTo write these kinds of test, you'll use additional features of the `TestBed` as well as other testing helpers.\n\n### CLI-generated tests\n\nThe CLI creates an initial test file for you by default when you ask it to generate a new component.\n\nFor example, the following CLI command generates a `BannerComponent` in the `app/banner` folder \\(with inline template and styles\\):\n\n<docs-code language=\"shell\">\n\nng generate component banner --inline-template --inline-style --module app\n\n</docs-code>\n\nIt also generates an initial test file for the component, `banner-external.component.spec.ts`, that looks like this:\n\n<docs-code header=\"app/banner/banner-external.component.spec.ts (initial)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v1\"/>\n\nHELPFUL: Because `compileComponents` is asynchronous, it uses the [`waitForAsync`](api/core/testing/waitForAsync) utility function imported from `@angular/core/testing`.\n\nRefer to the [waitForAsync](guide/testing/components-scenarios#waitForAsync) section for more details.\n\n### Reduce the setup\n\nOnly the last three lines of this file actually test the component and all they do is assert that Angular can create the component.\n\nThe rest of the file is boilerplate setup code anticipating more advanced tests that *might* become necessary if the component evolves into something substantial.\n\nYou'll learn about these advanced test features in the following sections.\nFor now, you can radically reduce this test file to a more manageable size:\n\n<docs-code header=\"app/banner/banner-initial.component.spec.ts (minimal)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v2\"/>\n\nIn this example, the metadata object passed to `TestBed.configureTestingModule` simply declares `BannerComponent`, the component to test.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"configureTestingModule\"/>\n\nHELPFUL: There's no need to declare or import anything else.\nThe default test module is pre-configured with something like the `BrowserModule` from `@angular/platform-browser`.\n\nLater you'll call `TestBed.configureTestingModule()` with imports, providers, and more declarations to suit your testing needs.\nOptional `override` methods can further fine-tune aspects of the configuration.\n\n### `createComponent()`\n\nAfter configuring `TestBed`, you call its `createComponent()` method.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"createComponent\"/>\n\n`TestBed.createComponent()` creates an instance of the `BannerComponent`, adds a corresponding element to the test-runner DOM, and returns a [`ComponentFixture`](#componentfixture).\n\nIMPORTANT: Do not re-configure `TestBed` after calling `createComponent`.\n\nThe `createComponent` method freezes the current `TestBed` definition, closing it to further configuration.\n\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()`, nor `get()`, nor any of the `override...` methods.\nIf you try, `TestBed` throws an error.\n\n### `ComponentFixture`\n\nThe [ComponentFixture](api/core/testing/ComponentFixture) is a test harness for interacting with the created component and its corresponding element.\n\nAccess the component instance through the fixture and confirm it exists with a Jasmine expectation:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"componentInstance\"/>\n\n### `beforeEach()`\n\nYou will add more tests as this component evolves.\nRather than duplicate the `TestBed` configuration for each test, you refactor to pull the setup into a Jasmine `beforeEach()` and some supporting variables:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v3\"/>\n\nNow add a test that gets the component's element from `fixture.nativeElement` and looks for the expected text.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v4-test-2\"/>\n\n### `nativeElement`\n\nThe value of `ComponentFixture.nativeElement` has the `any` type.\nLater you'll encounter the `DebugElement.nativeElement` and it too has the `any` type.\n\nAngular can't know at compile time what kind of HTML element the `nativeElement` is or if it even is an HTML element.\nThe application might be running on a *non-browser platform*, such as the server or a [Web Worker](https://developer.mozilla.org/docs/Web/API/Web_Workers_API), where the element might have a diminished API or not exist at all.\n\nThe tests in this guide are designed to run in a browser so a `nativeElement` value will always be an `HTMLElement` or one of its derived classes.\n\nKnowing that it is an `HTMLElement` of some sort, use the standard HTML `querySelector` to dive deeper into the element tree.\n\nHere's another test that calls `HTMLElement.querySelector` to get the paragraph element and look for the banner text:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v4-test-3\"/>\n\n### `DebugElement`\n\nThe Angular *fixture* provides the component's element directly through the `fixture.nativeElement`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"nativeElement\"/>\n\nThis is actually a convenience method, implemented as `fixture.debugElement.nativeElement`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"debugElement-nativeElement\"/>\n\nThere's a good reason for this circuitous path to the element.\n\nThe properties of the `nativeElement` depend upon the runtime environment.\nYou could be running these tests on a *non-browser* platform that doesn't have a DOM or whose DOM-emulation doesn't support the full `HTMLElement` API.\n\nAngular relies on the `DebugElement` abstraction to work safely across *all supported platforms*.\nInstead of creating an HTML element tree, Angular creates a `DebugElement` tree that wraps the *native elements* for the runtime platform.\nThe `nativeElement` property unwraps the `DebugElement` and returns the platform-specific element object.\n\nBecause the sample tests for this guide are designed to run only in a browser, a `nativeElement` in these tests is always an `HTMLElement` whose familiar methods and properties you can explore within a test.\n\nHere's the previous test, re-implemented with `fixture.debugElement.nativeElement`:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v4-test-4\"/>\n\nThe `DebugElement` has other methods and properties that are useful in tests, as you'll see elsewhere in this guide.\n\nYou import the `DebugElement` symbol from the Angular core library.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"import-debug-element\"/>\n\n### `By.css()`\n\nAlthough the tests in this guide all run in the browser, some applications might run on a different platform at least some of the time.\n\nFor example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices.\nThe server-side renderer might not support the full HTML element API.\nIf it doesn't support `querySelector`, the previous test could fail.\n\nThe `DebugElement` offers query methods that work for all supported platforms.\nThese query methods take a *predicate* function that returns `true` when a node in the `DebugElement` tree matches the selection criteria.\n\nYou create a *predicate* with the help of a `By` class imported from a library for the runtime platform.\nHere's the `By` import for the browser platform:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"import-by\"/>\n\nThe following example re-implements the previous test with `DebugElement.query()` and the browser's `By.css` method.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner-initial.component.spec.ts\" visibleRegion=\"v4-test-5\"/>\n\nSome noteworthy observations:\n\n* The `By.css()` static method selects `DebugElement` nodes with a [standard CSS selector](https://developer.mozilla.org/docs/Learn/CSS/Building_blocks/Selectors 'CSS selectors').\n* The query returns a `DebugElement` for the paragraph.\n* You must unwrap that result to get the paragraph element.\n\nWhen you're filtering by CSS selector and only testing properties of a browser's *native element*, the `By.css` approach might be overkill.\n\nIt's often more straightforward and clear to filter with a standard `HTMLElement` method such as `querySelector()` or `querySelectorAll()`.\n\n\n\n================================================\n",
    "endLine": 17975
  },
  {
    "id": 94,
    "file": "components-scenarios",
    "fullFileName": "adev/src/content/guide/testing/components-scenarios.md",
    "startLine": 17979,
    "content": "# Component testing scenarios\n\nThis guide explores common component testing use cases.\n\n## Component binding\n\nIn the example application, the `BannerComponent` presents static title text in the HTML template.\n\nAfter a few changes, the `BannerComponent` presents a dynamic title by binding to the component's `title` property like this.\n\n<docs-code header=\"app/banner/banner.component.ts\" path=\"adev/src/content/examples/testing/src/app/banner/banner.component.ts\" visibleRegion=\"component\"/>\n\nAs minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.\n\n### Query for the `<h1>`\n\nYou'll write a sequence of tests that inspect the value of the `<h1>` element that wraps the *title* property interpolation binding.\n\nYou update the `beforeEach` to find that element with a standard HTML `querySelector` and assign it to the `h1` variable.\n\n<docs-code header=\"app/banner/banner.component.spec.ts (setup)\" path=\"adev/src/content/examples/testing/src/app/banner/banner.component.spec.ts\" visibleRegion=\"setup\"/>\n\n### `createComponent()` does not bind data\n\nFor your first test you'd like to see that the screen displays the default `title`.\nYour instinct is to write a test that immediately inspects the `<h1>` like this:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner.component.spec.ts\" visibleRegion=\"expect-h1-default-v1\"/>\n\n*That test fails* with the message:\n\n<docs-code language=\"javascript\">\n\nexpected '' to contain 'Test Tour of Heroes'.\n\n</docs-code>\n\nBinding happens when Angular performs **change detection**.\n\nIn production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke, for example.\n\nThe `TestBed.createComponent` does not trigger change detection by default; a fact confirmed in the revised test:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner.component.spec.ts\" visibleRegion=\"test-w-o-detect-changes\"/>\n\n### `detectChanges()`\n\nYou can tell the `TestBed` to perform data binding by calling `fixture.detectChanges()`.\nOnly then does the `<h1>` have the expected title.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner.component.spec.ts\" visibleRegion=\"expect-h1-default\"/>\n\nDelayed change detection is intentional and useful.\nIt gives the tester an opportunity to inspect and change the state of the component *before Angular initiates data binding and calls [lifecycle hooks](guide/components/lifecycle)*.\n\nHere's another test that changes the component's `title` property *before* calling `fixture.detectChanges()`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/banner/banner.component.spec.ts\" visibleRegion=\"after-change\"/>\n\n### Automatic change detection\n\nThe `BannerComponent` tests frequently call `detectChanges`.\nMany testers prefer that the Angular test environment run change detection automatically like it does in production.\n\nThat's possible by configuring the `TestBed` with the `ComponentFixtureAutoDetect` provider.\nFirst import it from the testing utility library:\n\n<docs-code header=\"app/banner/banner.component.detect-changes.spec.ts (import)\" path=\"adev/src/content/examples/testing/src/app/banner/banner.component.detect-changes.spec.ts\" visibleRegion=\"import-ComponentFixtureAutoDetect\"/>\n\nThen add it to the `providers` array of the testing module configuration:\n\n<docs-code header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" path=\"adev/src/content/examples/testing/src/app/banner/banner.component.detect-changes.spec.ts\" visibleRegion=\"auto-detect\"/>\n\nHELPFUL: You can also use the `fixture.autoDetectChanges()` function instead if you only want to enable automatic change detection\nafter making updates to the state of the fixture's component. In addition, automatic change detection is on by default\nwhen using `provideExperimentalZonelessChangeDetection` and turning it off is not recommended.\n\nHere are three tests that illustrate how automatic change detection works.\n\n<docs-code header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" path=\"adev/src/content/examples/testing/src/app/banner/banner.component.detect-changes.spec.ts\" visibleRegion=\"auto-detect-tests\"/>\n\nThe first test shows the benefit of automatic change detection.\n\nThe second and third test reveal an important limitation.\nThe Angular testing environment does not run change detection synchronously when updates happen inside the test case that changed the component's `title`.\nThe test must call `await fixture.whenStable` to wait for another round of change detection.\n\nHELPFUL: Angular does not know about direct updates to values that are not signals. The easiest way to ensure that\nchange detection will be scheduled is to use signals for values read in the template.\n\n### Change an input value with `dispatchEvent()`\n\nTo simulate user input, find the input element and set its `value` property.\n\nBut there is an essential, intermediate step.\n\nAngular doesn't know that you set the input element's `value` property.\nIt won't read that property until you raise the element's `input` event by calling `dispatchEvent()`.\n\nThe following example demonstrates the proper sequence.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (pipe test)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"title-case-pipe\"/>\n\n## Component with external files\n\nThe preceding `BannerComponent` is defined with an *inline template* and *inline css*, specified in the `@Component.template` and `@Component.styles` properties respectively.\n\nMany components specify *external templates* and *external css* with the `@Component.templateUrl` and `@Component.styleUrls` properties respectively, as the following variant of `BannerComponent` does.\n\n<docs-code header=\"app/banner/banner-external.component.ts (metadata)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.ts\" visibleRegion=\"metadata\"/>\n\nThis syntax tells the Angular compiler to read the external files during component compilation.\n\nThat's not a problem when you run the CLI `ng test` command because it *compiles the application before running the tests*.\n\nHowever, if you run the tests in a **non-CLI environment**, tests of this component might fail.\nFor example, if you run the `BannerComponent` tests in a web coding environment such as [plunker](https://plnkr.co), you'll see a message like this one:\n\n<docs-code hideCopy language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</docs-code>\n\nYou get this test failure message when the runtime environment compiles the source code *during the tests themselves*.\n\nTo correct the problem, call `compileComponents()` as explained in the following [Calling compileComponents](#calling-compilecomponents) section.\n\n## Component with a dependency\n\nComponents often have service dependencies.\n\nThe `WelcomeComponent` displays a welcome message to the logged-in user.\nIt knows who the user is based on a property of the injected `UserService`:\n\n<docs-code header=\"app/welcome/welcome.component.ts\" path=\"adev/src/content/examples/testing/src/app/welcome/welcome.component.ts\"/>\n\nThe `WelcomeComponent` has decision logic that interacts with the service, logic that makes this component worth testing.\n\n### Provide service test doubles\n\nA *component-under-test* doesn't have to be provided with real services.\n\nInjecting the real `UserService` could be difficult.\nThe real service might ask the user for login credentials and attempt to reach an authentication server.\nThese behaviors can be hard to intercept. Be aware that using test doubles makes the test behave differently from production so use them sparingly.\n\n### Get injected services\n\nThe tests need access to the `UserService` injected into the `WelcomeComponent`.\n\nAngular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the `TestBed` down through the component tree.\n\nThe safest way to get the injected service, the way that ***always works***,\nis to **get it from the injector of the *component-under-test***.\nThe component injector is a property of the fixture's `DebugElement`.\n\n<docs-code header=\"WelcomeComponent's injector\" path=\"adev/src/content/examples/testing/src/app/welcome/welcome.component.spec.ts\" visibleRegion=\"injected-service\"/>\n\nHELPFUL: This is _usually_ not necessary. Services are often provided in the root or the TestBed overrides and can be retrieved more easily with `TestBed.inject()` (see below).\n\n### `TestBed.inject()`\n\nThis is easier to remember and less verbose than retrieving a service using the fixture's `DebugElement`.\n\nIn this test suite, the *only* provider of `UserService` is the root testing module, so it is safe to call `TestBed.inject()` as follows:\n\n<docs-code header=\"TestBed injector\" path=\"adev/src/content/examples/testing/src/app/welcome/welcome.component.spec.ts\" visibleRegion=\"inject-from-testbed\" />\n\nHELPFUL: For a use case in which `TestBed.inject()` does not work, see the [*Override component providers*](#override-component-providers) section that explains when and why you must get the service from the component's injector instead.\n\n### Final setup and tests\n\nHere's the complete `beforeEach()`, using `TestBed.inject()`:\n\n<docs-code header=\"app/welcome/welcome.component.spec.ts\" path=\"adev/src/content/examples/testing/src/app/welcome/welcome.component.spec.ts\" visibleRegion=\"setup\"/>\n\nAnd here are some tests:\n\n<docs-code header=\"app/welcome/welcome.component.spec.ts\" path=\"adev/src/content/examples/testing/src/app/welcome/welcome.component.spec.ts\" visibleRegion=\"tests\"/>\n\nThe first is a sanity test; it confirms that the `UserService` is called and working.\n\nHELPFUL: The withContext function \\(for example, `'expected name'`\\) is an optional failure label.\nIf the expectation fails, Jasmine appends this label to the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.\n\nThe remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.\n\n## Component with async service\n\nIn this sample, the `AboutComponent` template hosts a `TwainComponent`.\nThe `TwainComponent` displays Mark Twain quotes.\n\n<docs-code header=\"app/twain/twain.component.ts (template)\" path=\"adev/src/content/examples/testing/src/app/twain/twain.component.ts\" visibleRegion=\"template\" />\n\nHELPFUL: The value of the component's `quote` property passes through an `AsyncPipe`.\nThat means the property returns either a `Promise` or an `Observable`.\n\nIn this example, the `TwainComponent.getQuote()` method tells you that the `quote` property returns an `Observable`.\n\n<docs-code header=\"app/twain/twain.component.ts (getQuote)\" path=\"adev/src/content/examples/testing/src/app/twain/twain.component.ts\" visibleRegion=\"get-quote\"/>\n\nThe `TwainComponent` gets quotes from an injected `TwainService`.\nThe component starts the returned `Observable` with a placeholder value \\(`'...'`\\), before the service can return its first quote.\n\nThe `catchError` intercepts service errors, prepares an error message, and returns the placeholder value on the success channel.\n\nThese are all features you'll want to test.\n\n### Testing with a spy\n\nWhen testing a component, only the service's public API should matter.\nIn general, tests themselves should not make calls to remote servers.\nThey should emulate such calls.\nThe setup in this `app/twain/twain.component.spec.ts` shows one way to do that:\n\n<docs-code header=\"app/twain/twain.component.spec.ts (setup)\" path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"setup\"/>\n\nFocus on the spy.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"spy\"/>\n\nThe spy is designed such that any call to `getQuote` receives an observable with a test quote.\nUnlike the real `getQuote()` method, this spy bypasses the server and returns a synchronous observable whose value is available immediately.\n\nYou can write many useful tests with this spy, even though its `Observable` is synchronous.\n\nHELPFUL: It is best to limit the usage of spies to only what is necessary for the test. Creating mocks or spies for more than what's necessary can be brittle. As the component and injectable evolves, the unrelated tests can fail because they no longer mock enough behaviors that would otherwise not affect the test.\n\n\n### Async test with `fakeAsync()`\n\nTo use `fakeAsync()` functionality, you must import `zone.js/testing` in your test setup file.\nIf you created your project with the Angular CLI, `zone-testing` is already imported in `src/test.ts`.\n\nThe following test confirms the expected behavior when the service returns an `ErrorObservable`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"error-test\"/>\n\nHELPFUL: The `it()` function receives an argument of the following form.\n\n<docs-code language=\"javascript\">\n\nfakeAsync(() => { /*test body*/ })\n\n</docs-code>\n\nThe `fakeAsync()` function enables a linear coding style by running the test body in a special `fakeAsync test zone`.\nThe test body appears to be synchronous.\nThere is no nested syntax \\(like a `Promise.then()`\\) to disrupt the flow of control.\n\nHELPFUL: Limitation: The `fakeAsync()` function won't work if the test body makes an `XMLHttpRequest` \\(XHR\\) call.\nXHR calls within a test are rare, but if you need to call XHR, see the [`waitForAsync()`](#waitForAsync) section.\n\nIMPORTANT: Be aware that asynchronous tasks that happen inside the `fakeAsync` zone need to be manually executed with `flush` or `tick`. If you attempt to\nwait for them to complete (i.e. using `fixture.whenStable`) without using the\n`fakeAsync` test helpers to advance time, your test will likely fail. See below for more information.\n\n### The `tick()` function\n\nYou do have to call [tick()](api/core/testing/tick) to advance the virtual clock.\n\nCalling [tick()](api/core/testing/tick) simulates the passage of time until all pending asynchronous activities finish.\nIn this case, it waits for the observable's `setTimeout()`.\n\nThe [tick()](api/core/testing/tick) function accepts `millis` and `tickOptions` as parameters. The `millis` parameter specifies how much the virtual clock advances and defaults to `0` if not provided.\nFor example, if you have a `setTimeout(fn, 100)` in a `fakeAsync()` test, you need to use `tick(100)` to trigger the fn callback.\nThe optional `tickOptions` parameter has a property named `processNewMacroTasksSynchronously`. The `processNewMacroTasksSynchronously` property represents whether to invoke new generated macro tasks when ticking and defaults to `true`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-tick\"/>\n\nThe [tick()](api/core/testing/tick) function is one of the Angular testing utilities that you import with `TestBed`.\nIt's a companion to `fakeAsync()` and you can only call it within a `fakeAsync()` body.\n\n### tickOptions\n\nIn this example, you have a new macro task, the nested `setTimeout` function. By default, when the `tick` is setTimeout, `outside` and `nested` will both be triggered.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-tick-new-macro-task-sync\"/>\n\nIn some case, you don't want to trigger the new macro task when ticking. You can use `tick(millis, {processNewMacroTasksSynchronously: false})` to not invoke a new macro task.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-tick-new-macro-task-async\"/>\n\n### Comparing dates inside fakeAsync()\n\n`fakeAsync()` simulates passage of time, which lets you calculate the difference between dates inside `fakeAsync()`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-date\"/>\n\n### jasmine.clock with fakeAsync()\n\nJasmine also provides a `clock` feature to mock dates.\nAngular automatically runs tests that are run after `jasmine.clock().install()` is called inside a `fakeAsync()` method until `jasmine.clock().uninstall()` is called.\n`fakeAsync()` is not needed and throws an error if nested.\n\nBy default, this feature is disabled.\nTo enable it, set a global flag before importing `zone-testing`.\n\nIf you use the Angular CLI, configure this flag in `src/test.ts`.\n\n<docs-code language=\"typescript\">\n\n[window as any]('&lowbar;&lowbar;zone&lowbar;symbol__fakeAsyncPatchLock') = true;\nimport 'zone.js/testing';\n\n</docs-code>\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-clock\"/>\n\n### Using the RxJS scheduler inside fakeAsync()\n\nYou can also use RxJS scheduler in `fakeAsync()` just like using `setTimeout()` or `setInterval()`, but you need to import `zone.js/plugins/zone-patch-rxjs-fake-async` to patch RxJS scheduler.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/async-helper.spec.ts\" visibleRegion=\"fake-async-test-rxjs\"/>\n\n### Support more macroTasks\n\nBy default, `fakeAsync()` supports the following macro tasks.\n\n* `setTimeout`\n* `setInterval`\n* `requestAnimationFrame`\n* `webkitRequestAnimationFrame`\n* `mozRequestAnimationFrame`\n\nIf you run other macro tasks such as `HTMLCanvasElement.toBlob()`, an *\"Unknown macroTask scheduled in fake async test\"* error is thrown.\n\n<docs-code-multifile>\n    <docs-code header=\"src/app/shared/canvas.component.spec.ts (failing)\" path=\"adev/src/content/examples/testing/src/app/shared/canvas.component.spec.ts\" visibleRegion=\"without-toBlob-macrotask\"/>\n    <docs-code header=\"src/app/shared/canvas.component.ts\" path=\"adev/src/content/examples/testing/src/app/shared/canvas.component.ts\" visibleRegion=\"main\"/>\n</docs-code-multifile>\n\nIf you want to support such a case, you need to define the macro task you want to support in `beforeEach()`.\nFor example:\n\n<docs-code header=\"src/app/shared/canvas.component.spec.ts (excerpt)\" path=\"adev/src/content/examples/testing/src/app/shared/canvas.component.spec.ts\" visibleRegion=\"enable-toBlob-macrotask\"/>\n\nHELPFUL: In order to make the `<canvas>` element Zone.js-aware in your app, you need to import the `zone-patch-canvas` patch \\(either in `polyfills.ts` or in the specific file that uses `<canvas>`\\):\n\n<docs-code header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"adev/src/content/examples/testing/src/app/shared/canvas.component.ts\" visibleRegion=\"import-canvas-patch\"/>\n\n### Async observables\n\nYou might be satisfied with the test coverage of these tests.\n\nHowever, you might be troubled by the fact that the real service doesn't quite behave this way.\nThe real service sends requests to a remote server.\nA server takes time to respond and the response certainly won't be available immediately as in the previous two tests.\n\nYour tests will reflect the real world more faithfully if you return an *asynchronous* observable from the `getQuote()` spy like this.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"async-setup\"/>\n\n### Async observable helpers\n\nThe async observable was produced by an `asyncData` helper.\nThe `asyncData` helper is a utility function that you'll have to write yourself, or copy this one from the sample code.\n\n<docs-code header=\"testing/async-observable-helpers.ts\" path=\"adev/src/content/examples/testing/src/testing/async-observable-helpers.ts\" visibleRegion=\"async-data\"/>\n\nThis helper's observable emits the `data` value in the next turn of the JavaScript engine.\n\nThe [RxJS `defer()` operator](http://reactivex.io/documentation/operators/defer.html) returns an observable.\nIt takes a factory function that returns either a promise or an observable.\nWhen something subscribes to *defer*'s observable, it adds the subscriber to a new observable created with that factory.\n\nThe `defer()` operator transforms the `Promise.resolve()` into a new observable that, like `HttpClient`, emits once and completes.\nSubscribers are unsubscribed after they receive the data value.\n\nThere's a similar helper for producing an async error.\n\n<docs-code path=\"adev/src/content/examples/testing/src/testing/async-observable-helpers.ts\" visibleRegion=\"async-error\"/>\n\n### More async tests\n\nNow that the `getQuote()` spy is returning async observables, most of your tests will have to be async as well.\n\nHere's a `fakeAsync()` test that demonstrates the data flow you'd expect in the real world.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"fake-async-test\"/>\n\nNotice that the quote element displays the placeholder value \\(`'...'`\\) after `ngOnInit()`.\nThe first quote hasn't arrived yet.\n\nTo flush the first quote from the observable, you call [tick()](api/core/testing/tick).\nThen call `detectChanges()` to tell Angular to update the screen.\n\nThen you can assert that the quote element displays the expected text.\n\n### Async test without `fakeAsync()`\n\nHere's the previous `fakeAsync()` test, re-written with the `async`.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/twain/twain.component.spec.ts\" visibleRegion=\"async-test\"/>\n\n### `whenStable`\n\nThe test must wait for the `getQuote()` observable to emit the next quote.\nInstead of calling [tick()](api/core/testing/tick), it calls `fixture.whenStable()`.\n\nThe `fixture.whenStable()` returns a promise that resolves when the JavaScript engine's task queue becomes empty.\nIn this example, the task queue becomes empty when the observable emits the first quote.\n\n\n## Component with inputs and outputs\n\nA component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to listen to events raised by the output property.\n\nThe testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.\n\nThe `DashboardHeroComponent` is a tiny example of a component in this role.\nIt displays an individual hero provided by the `DashboardComponent`.\nClicking that hero tells the `DashboardComponent` that the user has selected the hero.\n\nThe `DashboardHeroComponent` is embedded in the `DashboardComponent` template like this:\n\n<docs-code header=\"app/dashboard/dashboard.component.html (excerpt)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard.component.html\" visibleRegion=\"dashboard-hero\"/>\n\nThe `DashboardHeroComponent` appears in an `*ngFor` repeater, which sets each component's `hero` input property to the looping value and listens for the component's `selected` event.\n\nHere's the component's full definition:\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.ts\" visibleRegion=\"component\"/>\n\nWhile testing a component this simple has little intrinsic value, it's worth knowing how.\nUse one of these approaches:\n\n* Test it as used by `DashboardComponent`\n* Test it as a standalone component\n* Test it as used by a substitute for `DashboardComponent`\n\nThe immediate goal is to test the `DashboardHeroComponent`, not the `DashboardComponent`, so, try the second and third options.\n\n### Test `DashboardHeroComponent` standalone\n\nHere's the meat of the spec file setup.\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"setup\"/>\n\nNotice how the setup code assigns a test hero \\(`expectedHero`\\) to the component's `hero` property, emulating the way the `DashboardComponent` would set it using the property binding in its repeater.\n\nThe following test verifies that the hero name is propagated to the template using a binding.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"name-test\"/>\n\nBecause the [template](#dashboard-hero-component) passes the hero name through the Angular `UpperCasePipe`, the test must match the element value with the upper-cased name.\n\n### Clicking\n\nClicking the hero should raise a `selected` event that the host component \\(`DashboardComponent` presumably\\) can hear:\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"click-test\"/>\n\nThe component's `selected` property returns an `EventEmitter`, which looks like an RxJS synchronous `Observable` to consumers.\nThe test subscribes to it *explicitly* just as the host component does *implicitly*.\n\nIf the component behaves as expected, clicking the hero's element should tell the component's `selected` property to emit the `hero` object.\n\nThe test detects that event through its subscription to `selected`.\n\n### `triggerEventHandler`\n\nThe `heroDe` in the previous test is a `DebugElement` that represents the hero `<div>`.\n\nIt has Angular properties and methods that abstract interaction with the native element.\nThis test calls the `DebugElement.triggerEventHandler` with the \"click\" event name.\nThe \"click\" event binding responds by calling `DashboardHeroComponent.click()`.\n\nThe Angular `DebugElement.triggerEventHandler` can raise *any data-bound event* by its *event name*.\nThe second parameter is the event object passed to the handler.\n\nThe test triggered a \"click\" event.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"trigger-event-handler\"/>\n\nIn this case, the test correctly assumes that the runtime event handler, the component's `click()` method, doesn't care about the event object.\n\nHELPFUL: Other handlers are less forgiving.\nFor example, the `RouterLink` directive expects an object with a `button` property that identifies which mouse button, if any, was pressed during the click.\nThe `RouterLink` directive throws an error if the event object is missing.\n\n### Click the element\n\nThe following test alternative calls the native element's own `click()` method, which is perfectly fine for *this component*.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"click-test-2\"/>\n\n### `click()` helper\n\nClicking a button, an anchor, or an arbitrary HTML element is a common test task.\n\nMake that consistent and straightforward by encapsulating the *click-triggering* process in a helper such as the following `click()` function:\n\n<docs-code header=\"testing/index.ts (click helper)\" path=\"adev/src/content/examples/testing/src/testing/index.ts\" visibleRegion=\"click-event\"/>\n\nThe first parameter is the *element-to-click*.\nIf you want, pass a custom event object as the second parameter.\nThe default is a partial [left-button mouse event object](https://developer.mozilla.org/docs/Web/API/MouseEvent/button) accepted by many handlers including the `RouterLink` directive.\n\nIMPORTANT: The `click()` helper function is **not** one of the Angular testing utilities.\nIt's a function defined in *this guide's sample code*.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.\n\nHere's the previous test, rewritten using the click helper.\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"click-test-3\"/>\n\n## Component inside a test host\n\nThe previous tests played the role of the host `DashboardComponent` themselves.\nBut does the `DashboardHeroComponent` work correctly when properly data-bound to a host component?\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"test-host\"/>\n\nThe test host sets the component's `hero` input property with its test hero.\nIt binds the component's `selected` event with its `onSelected` handler, which records the emitted hero in its `selectedHero` property.\n\nLater, the tests will be able to check `selectedHero` to verify that the `DashboardHeroComponent.selected` event emitted the expected hero.\n\nThe setup for the `test-host` tests is similar to the setup for the stand-alone tests:\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"test-host-setup\"/>\n\nThis testing module configuration shows three important differences:\n\n* It *imports* both the `DashboardHeroComponent` and the `TestHostComponent`\n* It *creates* the `TestHostComponent` instead of the `DashboardHeroComponent`\n* The `TestHostComponent` sets the `DashboardHeroComponent.hero` with a binding\n\nThe `createComponent` returns a `fixture` that holds an instance of `TestHostComponent` instead of an instance of `DashboardHeroComponent`.\n\nCreating the `TestHostComponent` has the side effect of creating a `DashboardHeroComponent` because the latter appears within the template of the former.\nThe query for the hero element \\(`heroEl`\\) still finds it in the test DOM, albeit at greater depth in the element tree than before.\n\nThe tests themselves are almost identical to the stand-alone version:\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"test-host-tests\"/>\n\nOnly the selected event test differs.\nIt confirms that the selected `DashboardHeroComponent` hero really does find its way up through the event binding to the host component.\n\n## Routing component\n\nA *routing component* is a component that tells the `Router` to navigate to another component.\nThe `DashboardComponent` is a *routing component* because the user can navigate to the `HeroDetailComponent` by clicking on one of the *hero buttons* on the dashboard.\n\nAngular provides test helpers to reduce boilerplate and more effectively test code which depends on `HttpClient`. The `provideRouter` function can be used directly in the test module as well.\n\n<docs-code header=\"app/dashboard/dashboard.component.spec.ts\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard.component.spec.ts\" visibleRegion=\"router-harness\"/>\n\nThe following test clicks the displayed hero and confirms that we navigate to the expected URL.\n\n<docs-code header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard.component.spec.ts\" visibleRegion=\"navigate-test\"/>\n\n## Routed components\n\nA *routed component* is the destination of a `Router` navigation.\nIt can be trickier to test, especially when the route to the component *includes parameters*.\nThe `HeroDetailComponent` is a *routed component* that is the destination of such a route.\n\nWhen a user clicks a *Dashboard* hero, the `DashboardComponent` tells the `Router` to navigate to `heroes/:id`.\nThe `:id` is a route parameter whose value is the `id` of the hero to edit.\n\nThe `Router` matches that URL to a route to the `HeroDetailComponent`.\nIt creates an `ActivatedRoute` object with the routing information and injects it into a new instance of the `HeroDetailComponent`.\n\nHere are the services injected into `HeroDetailComponent`:\n\n<docs-code header=\"app/hero/hero-detail.component.ts (inject)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.ts\" visibleRegion=\"ctor\"/>\n\nThe `HeroDetail` component needs the `id` parameter so it can fetch the corresponding hero using the `HeroDetailService`.\nThe component has to get the `id` from the `ActivatedRoute.paramMap` property which is an `Observable`.\n\nIt can't just reference the `id` property of the `ActivatedRoute.paramMap`.\nThe component has to *subscribe* to the `ActivatedRoute.paramMap` observable and be prepared for the `id` to change during its lifetime.\n\n<docs-code header=\"app/hero/hero-detail.component.ts (constructor)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.ts\" visibleRegion=\"ctor\"/>\n\nTests can explore how the `HeroDetailComponent` responds to different `id` parameter values by navigating to different routes.\n\n### Testing with the `RouterTestingHarness`\n\nHere's a test demonstrating the component's behavior when the observed `id` refers to an existing hero:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (existing id)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"route-good-id\"/>\n\nHELPFUL: In the following section, the `createComponent()` method and `page` object are discussed.\nRely on your intuition for now.\n\nWhen the `id` cannot be found, the component should re-route to the `HeroListComponent`.\n\nThe test suite setup provided the same router harness [described above](#routing-component).\n\nThis test expects the component to try to navigate to the `HeroListComponent`.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (bad id)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"route-bad-id\"/>\n\n## Nested component tests\n\nComponent templates often have nested components, whose templates might contain more components.\n\nThe component tree can be very deep and sometimes the nested components play no role in testing the component at the top of the tree.\n\nThe `AppComponent`, for example, displays a navigation bar with anchors and their `RouterLink` directives.\n\n<docs-code header=\"app/app.component.html\" path=\"adev/src/content/examples/testing/src/app/app.component.html\"/>\n\nTo validate the links but not the navigation, you don't need the `Router` to navigate and you don't need the `<router-outlet>` to mark where the `Router` inserts *routed components*.\n\nThe `BannerComponent` and `WelcomeComponent` \\(indicated by `<app-banner>` and `<app-welcome>`\\) are also irrelevant.\n\nYet any test that creates the `AppComponent` in the DOM also creates instances of these three components and, if you let that happen, you'll have to configure the `TestBed` to create them.\n\nIf you neglect to declare them, the Angular compiler won't recognize the `<app-banner>`, `<app-welcome>`, and `<router-outlet>` tags in the `AppComponent` template and will throw an error.\n\nIf you declare the real components, you'll also have to declare *their* nested components and provide for *all* services injected in *any* component in the tree.\n\nThis section describes two techniques for minimizing the setup.\nUse them, alone or in combination, to stay focused on testing the primary component.\n\n### Stubbing unneeded components\n\nIn the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests.\n\n<docs-code header=\"app/app.component.spec.ts (stub declaration)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"component-stubs\"/>\n\nThe stub selectors match the selectors for the corresponding real components.\nBut their templates and classes are empty.\n\nThen declare them in the `TestBed` configuration next to the components, directives, and pipes that need to be real.\n\n<docs-code header=\"app/app.component.spec.ts (TestBed stubs)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"testbed-stubs\"/>\n\nThe `AppComponent` is the test subject, so of course you declare the real version.\n\nThe rest are stubs.\n\n### `NO_ERRORS_SCHEMA`\n\nIn the second approach, add `NO_ERRORS_SCHEMA` to the `TestBed.schemas` metadata.\n\n<docs-code header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"no-errors-schema\"/>\n\nThe `NO_ERRORS_SCHEMA` tells the Angular compiler to ignore unrecognized elements and attributes.\n\nThe compiler recognizes the `<app-root>` element and the `routerLink` attribute because you declared a corresponding `AppComponent` and `RouterLink` in the `TestBed` configuration.\n\nBut the compiler won't throw an error when it encounters `<app-banner>`, `<app-welcome>`, or `<router-outlet>`.\nIt simply renders them as empty tags and the browser ignores them.\n\nYou no longer need the stub components.\n\n### Use both techniques together\n\nThese are techniques for *Shallow Component Testing*, so-named because they reduce the visual surface of the component to just those elements in the component's template that matter for tests.\n\nThe `NO_ERRORS_SCHEMA` approach is the easier of the two but don't overuse it.\n\nThe `NO_ERRORS_SCHEMA` also prevents the compiler from telling you about the missing components and attributes that you omitted inadvertently or misspelled.\nYou could waste hours chasing phantom bugs that the compiler would have caught in an instant.\n\nThe *stub component* approach has another advantage.\nWhile the stubs in *this* example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way.\n\nIn practice you will combine the two techniques in the same setup, as seen in this example.\n\n<docs-code header=\"app/app.component.spec.ts (mixed setup)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"mixed-setup\"/>\n\nThe Angular compiler creates the `BannerStubComponent` for the `<app-banner>` element and applies the `RouterLink` to the anchors with the `routerLink` attribute, but it ignores the `<app-welcome>` and `<router-outlet>` tags.\n\n### `By.directive` and injected directives\n\nA little more setup triggers the initial data binding and gets references to the navigation links:\n\n<docs-code header=\"app/app.component.spec.ts (test setup)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"test-setup\"/>\n\nThree points of special interest:\n\n* Locate the anchor elements with an attached directive using `By.directive`\n* The query returns `DebugElement` wrappers around the matching elements\n* Each `DebugElement` exposes a dependency injector with the specific instance of the directive attached to that element\n\nThe `AppComponent` links to validate are as follows:\n\n<docs-code header=\"app/app.component.html (navigation links)\" path=\"adev/src/content/examples/testing/src/app/app.component.html\" visibleRegion=\"links\"/>\n\nHere are some tests that confirm those links are wired to the `routerLink` directives as expected:\n\n<docs-code header=\"app/app.component.spec.ts (selected tests)\" path=\"adev/src/content/examples/testing/src/app/app.component.spec.ts\" visibleRegion=\"tests\"/>\n\n## Use a `page` object\n\nThe `HeroDetailComponent` is a simple view with a title, two hero fields, and two buttons.\n\nBut there's plenty of template complexity even in this simple form.\n\n<docs-code\n  path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\"/>\n\nTests that exercise the component need …\n\n* To wait until a hero arrives before elements appear in the DOM\n* A reference to the title text\n* A reference to the name input box to inspect and set it\n* References to the two buttons so they can click them\n\nEven a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.\n\nTame the complexity with a `Page` class that handles access to component properties and encapsulates the logic that sets them.\n\nHere is such a `Page` class for the `hero-detail.component.spec.ts`\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (Page)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"page\"/>\n\nNow the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of `Page`.\n\nA `createComponent` method creates a `page` object and fills in the blanks once the `hero` arrives.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (createComponent)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"create-component\"/>\n\nHere are a few more `HeroDetailComponent` tests to reinforce the point.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (selected tests)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"selected-tests\"/>\n\n## Calling `compileComponents()`\n\nHELPFUL: Ignore this section if you *only* run tests with the CLI `ng test` command because the CLI compiles the application before running the tests.\n\nIf you run tests in a **non-CLI environment**, the tests might fail with a message like this one:\n\n<docs-code hideCopy language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</docs-code>\n\nThe root of the problem is at least one of the components involved in the test specifies an external template or CSS file as the following version of the `BannerComponent` does.\n\n<docs-code header=\"app/banner/banner-external.component.ts (external template & css)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.ts\"/>\n\nThe test fails when the `TestBed` tries to create the component.\n\n<docs-code avoid header=\"app/banner/banner-external.component.spec.ts (setup that fails)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.spec.ts\" visibleRegion=\"setup-may-fail\"/>\n\nRecall that the application hasn't been compiled.\nSo when you call `createComponent()`, the `TestBed` compiles implicitly.\n\nThat's not a problem when the source code is in memory.\nBut the `BannerComponent` requires external files that the compiler must read from the file system, an inherently *asynchronous* operation.\n\nIf the `TestBed` were allowed to continue, the tests would run and fail mysteriously before the compiler could finish.\n\nThe preemptive error message tells you to compile explicitly with `compileComponents()`.\n\n### `compileComponents()` is async\n\nYou must call `compileComponents()` within an asynchronous test function.\n\nCRITICAL: If you neglect to make the test function async (for example, forget to use `waitForAsync()` as described), you'll see this error message\n\n<docs-code hideCopy language=\"shell\">\n\nError: ViewDestroyedError: Attempt to use a destroyed view\n\n</docs-code>\n\nA typical approach is to divide the setup logic into two separate `beforeEach()` functions:\n\n| Functions                   | Details                      |\n| :-------------------------- | :--------------------------- |\n| Asynchronous `beforeEach()` | Compiles the components      |\n| Synchronous `beforeEach()`  | Performs the remaining setup |\n\n### The async `beforeEach`\n\nWrite the first async `beforeEach` like this.\n\n<docs-code header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.spec.ts\" visibleRegion=\"async-before-each\"/>\n\nThe `TestBed.configureTestingModule()` method returns the `TestBed` class so you can chain calls to other `TestBed` static methods such as `compileComponents()`.\n\nIn this example, the `BannerComponent` is the only component to compile.\nOther examples configure the testing module with multiple components and might import application modules that hold yet more components.\nAny of them could require external files.\n\nThe `TestBed.compileComponents` method asynchronously compiles all components configured in the testing module.\n\nIMPORTANT: Do not re-configure the `TestBed` after calling `compileComponents()`.\n\nCalling `compileComponents()` closes the current `TestBed` instance to further configuration.\nYou cannot call any more `TestBed` configuration methods, not `configureTestingModule()` nor any of the `override...` methods.\nThe `TestBed` throws an error if you try.\n\nMake `compileComponents()` the last step before calling `TestBed.createComponent()`.\n\n### The synchronous `beforeEach`\n\nThe second, synchronous `beforeEach()` contains the remaining setup steps, which include creating the component and querying for elements to inspect.\n\n<docs-code header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.spec.ts\" visibleRegion=\"sync-before-each\"/>\n\nCount on the test runner to wait for the first asynchronous `beforeEach` to finish before calling the second.\n\n### Consolidated setup\n\nYou can consolidate the two `beforeEach()` functions into a single, async `beforeEach()`.\n\nThe `compileComponents()` method returns a promise so you can perform the synchronous setup tasks *after* compilation by moving the synchronous code after the `await` keyword, where the promise has been resolved.\n\n<docs-code header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" path=\"adev/src/content/examples/testing/src/app/banner/banner-external.component.spec.ts\" visibleRegion=\"one-before-each\"/>\n\n### `compileComponents()` is harmless\n\nThere's no harm in calling `compileComponents()` when it's not required.\n\nThe component test file generated by the CLI calls `compileComponents()` even though it is never required when running `ng test`.\n\nThe tests in this guide only call `compileComponents` when necessary.\n\n## Setup with module imports\n\nEarlier component tests configured the testing module with a few `declarations` like this:\n\n<docs-code header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\" path=\"adev/src/content/examples/testing/src/app/dashboard/dashboard-hero.component.spec.ts\" visibleRegion=\"config-testbed\"/>\n\nThe `DashboardComponent` is simple.\nIt needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too.\n\nFortunately, the `TestBed.configureTestingModule` parameter parallels the metadata passed to the `@NgModule` decorator which means you can also specify `providers` and `imports`.\n\nThe `HeroDetailComponent` requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module `CommonModule`, it needs:\n\n* `NgModel` and friends in the `FormsModule` to enable two-way data binding\n* The `TitleCasePipe` from the `shared` folder\n* The Router services\n* The Hero data access services\n\nOne approach is to configure the testing module from the individual pieces as in this example:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"setup-forms-module\"/>\n\nHELPFUL: Notice that the `beforeEach()` is asynchronous and calls `TestBed.compileComponents` because the `HeroDetailComponent` has an external template and css file.\n\nAs explained in [Calling `compileComponents()`](#calling-compilecomponents), these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.\n\n### Import a shared module\n\nBecause many application components need the `FormsModule` and the `TitleCasePipe`, the developer created a `SharedModule` to combine these and other frequently requested parts.\n\nThe test configuration can use the `SharedModule` too as seen in this alternative setup:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"setup-shared-module\"/>\n\nIt's a bit tighter and smaller, with fewer import statements, which are not shown in this example.\n\n### Import a feature module\n\nThe `HeroDetailComponent` is part of the `HeroModule` [Feature Module](guide/ngmodules/feature-modules) that aggregates more of the interdependent pieces including the `SharedModule`.\nTry a test configuration that imports the `HeroModule` like this one:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"setup-hero-module\"/>\n\nOnly the *test doubles* in the `providers` remain.\nEven the `HeroDetailComponent` declaration is gone.\n\nIn fact, if you try to declare it, Angular will throw an error because `HeroDetailComponent` is declared in both the `HeroModule` and the `DynamicTestModule` created by the `TestBed`.\n\nHELPFUL: Importing the component's feature module can be the best way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be.\n\n## Override component providers\n\nThe `HeroDetailComponent` provides its own `HeroDetailService`.\n\n<docs-code header=\"app/hero/hero-detail.component.ts (prototype)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.ts\" visibleRegion=\"prototype\"/>\n\nIt's not possible to stub the component's `HeroDetailService` in the `providers` of the `TestBed.configureTestingModule`.\nThose are providers for the *testing module*, not the component.\nThey prepare the dependency injector at the *fixture level*.\n\nAngular creates the component with its *own* injector, which is a *child* of the fixture injector.\nIt registers the component's providers \\(the `HeroDetailService` in this case\\) with the child injector.\n\nA test cannot get to child injector services from the fixture injector.\nAnd `TestBed.configureTestingModule` can't configure them either.\n\nAngular has created new instances of the real `HeroDetailService` all along!\n\nHELPFUL: These tests could fail or timeout if the `HeroDetailService` made its own XHR calls to a remote server.\nThere might not be a remote server to call.\n\nFortunately, the `HeroDetailService` delegates responsibility for remote data access to an injected `HeroService`.\n\n<docs-code header=\"app/hero/hero-detail.service.ts (prototype)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.service.ts\" visibleRegion=\"prototype\"/>\n\nThe [previous test configuration](#import-a-feature-module) replaces the real `HeroService` with a `TestHeroService` that intercepts server requests and fakes their responses.\n\nWhat if you aren't so lucky.\nWhat if faking the `HeroService` is hard?\nWhat if `HeroDetailService` makes its own server requests?\n\nThe `TestBed.overrideComponent` method can replace the component's `providers` with easy-to-manage *test doubles* as seen in the following setup variation:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (Override setup)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"setup-override\"/>\n\nNotice that `TestBed.configureTestingModule` no longer provides a fake `HeroService` because it's [not needed](#spy-stub).\n\n### The `overrideComponent` method\n\nFocus on the `overrideComponent` method.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"override-component-method\"/>\n\nIt takes two arguments: the component type to override \\(`HeroDetailComponent`\\) and an override metadata object.\nThe [override metadata object](guide/testing/utility-apis#metadata-override-object) is a generic defined as follows:\n\n<docs-code language=\"javascript\">\n\ntype MetadataOverride<T> = {\n  add?: Partial<T>;\n  remove?: Partial<T>;\n  set?: Partial<T>;\n};\n\n</docs-code>\n\nA metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's `providers` metadata.\n\nThe type parameter, `T`, is the kind of metadata you'd pass to the `@Component` decorator:\n\n<docs-code language=\"javascript\">\n\nselector?: string;\ntemplate?: string;\ntemplateUrl?: string;\nproviders?: any[];\n…\n\n</docs-code>\n\n### Provide a *spy stub* (`HeroDetailServiceSpy`)\n\nThis example completely replaces the component's `providers` array with a new array containing a `HeroDetailServiceSpy`.\n\nThe `HeroDetailServiceSpy` is a stubbed version of the real `HeroDetailService` that fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level `HeroService` so there's no need to provide a test double for that.\n\nThe related `HeroDetailComponent` tests will assert that methods of the `HeroDetailService` were called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"hds-spy\"/>\n\n### The override tests\n\nNow the tests can control the component's hero directly by manipulating the spy-stub's `testHero` and confirm that service methods were called.\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (override tests)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"override-tests\"/>\n\n### More overrides\n\nThe `TestBed.overrideComponent` method can be called multiple times for the same or different components.\nThe `TestBed` offers similar `overrideDirective`, `overrideModule`, and `overridePipe` methods for digging into and replacing parts of these other classes.\n\nExplore the options and combinations on your own.\n\n\n\n================================================\n",
    "endLine": 18959
  },
  {
    "id": 95,
    "file": "creating-component-harnesses",
    "fullFileName": "adev/src/content/guide/testing/creating-component-harnesses.md",
    "startLine": 18963,
    "content": "# Creating harnesses for your components\n\n## Before you start\n\nTIP: This guide assumes you've already read the [component harnesses overview guide](guide/testing/component-harnesses-overview). Read that first if you're new to using component harnesses.\n\n### When does creating a test harness make sense?\n\nThe Angular team recommends creating component test harnesses for shared components that are used in many places and have some user interactivity. This most commonly applies to widget libraries and similar reusable components. Harnesses are valuable for these cases because they provide the consumers of these shared components a well- supported API for interacting with a component. Tests that use harnesses can avoid depending on unreliable implementation details of these shared components, such as DOM structure and specific event listeners.\n\nFor components that appear in only one place, such as a page in an application, harnesses don't provide as much benefit. In these situations, a component's tests can reasonably depend on the implementation details of this component, as the tests and components are updated at the same time. However, harnesses still provide some value if you would use the harness in both unit and end-to-end tests.\n\n### CDK Installation\n\nThe [Component Dev Kit (CDK)](https://material.angular.io/cdk/categories) is a set of behavior primitives for building components. To use the component harnesses, first install `@angular/cdk` from npm. You can do this from your terminal using the Angular CLI:\n\n<docs-code language=\"shell\">\n  ng add @angular/cdk\n</docs-code>\n\n## Extending `ComponentHarness`\n\nThe abstract `ComponentHarness` class is the base class for all component harnesses. To create a custom component harness, extend `ComponentHarness` and implement the static property `hostSelector`.\n\nThe `hostSelector` property identifies elements in the DOM that match this harness subclass. In most cases, the `hostSelector` should be the same as the selector of the corresponding `Component` or `Directive`. For example, consider a simple popup component:\n\n<docs-code language=\"typescript\">\n@Component({\n  selector: 'my-popup',\n  template: `\n    <button (click)=\"toggle()\">{{triggerText()}}</button>\n    @if (isOpen()) {\n      <div class=\"my-popup-content\"><ng-content></ng-content></div>\n    }\n  `\n})\nclass MyPopup {\n  triggerText = input('');\n\n  isOpen = signal(false);\n\n  toggle() {\n    this.isOpen.update((value) => !value);\n  }\n}\n</docs-code>\n\nIn this case, a minimal harness for the component would look like the following:\n\n<docs-code language=\"typescript\">\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n}\n</docs-code>\n\nWhile `ComponentHarness` subclasses require only the `hostSelector` property, most harnesses should also implement a static `with` method to generate `HarnessPredicate` instances. The [filtering harnesses section](guide/testing/using-component-harnesses#filtering-harnesses) covers this in more detail.\n\n## Finding elements in the component's DOM\n\nEach instance of a `ComponentHarness` subclass represents a particular instance of the corresponding component. You can access the component's host element via the `host() `method from the `ComponentHarness` base class.\n\n`ComponentHarness` also offers several methods for locating elements within the component's DOM. These methods are `locatorFor()`, `locatorForOptional()`, and `locatorForAll()`. These methods create functions that find elements, they do not directly find elements. This approach safeguards against caching references to out-of-date elements. For example, when an `ngIf` hides and then shows an element, the result is a new DOM element; using functions ensures that tests always reference the current state of the DOM.\n\nSee the [ComponentHarness API reference page](https://material.angular.io/cdk/testing/api#ComponentHarness) for the full list details of the different `locatorFor` methods.\n\nFor example, the `MyPopupHarness` example discussed above could provide methods to get the trigger and content elements as follows:\n\n<docs-code language=\"typescript\">\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  /** Gets the trigger element */\n  getTriggerElement = this.locatorFor('button');\n\n  /** Gets the content element. */\n  getContentElement = this.locatorForOptional('.my-popup-content');\n}\n</docs-code>\n\n## Working with `TestElement` instances\n\n`TestElement` is an abstraction designed to work across different test environments (Unit tests, WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface. Other means of accessing DOM elements, such as `document.querySelector()`, do not work in all test environments.\n\n`TestElement` has a number of methods to interact with the underlying DOM, such as `blur()`, `click()`, `getAttribute()`, and more. See the [TestElement API reference page](https://material.angular.io/cdk/testing/api#TestElement) for the full list of methods.\n\nDo not expose `TestElement` instances to harness users unless it's an element the component consumer defines directly, such as the component's host element. Exposing `TestElement` instances for internal elements leads users to depend on a component's internal DOM structure.\n\nInstead, provide more narrow-focused methods for specific actions the end-user may take or particular state they may observe. For example, `MyPopupHarness` from previous sections could provide methods like `toggle` and `isOpen`:\n\n<docs-code language=\"typescript\">\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  protected getTriggerElement = this.locatorFor('button');\n  protected getContentElement = this.locatorForOptional('.my-popup-content');\n\n  /** Toggles the open state of the popup. */\n  async toggle() {\n    const trigger = await this.getTriggerElement();\n    return trigger.click();\n  }\n\n  /** Checks if the popup us open. */\n  async isOpen() {\n    const content = await this.getContentElement();\n    return !!content;\n  }\n}\n</docs-code>\n\n## Loading harnesses for subcomponents\n\nLarger components often compose sub-components. You can reflect this structure in a component's harness as well. Each of the `locatorFor` methods on `ComponentHarness` has an alternate signature that can be used for locating sub-harnesses rather than elements.\n\nSee the [ComponentHarness API reference page](https://material.angular.io/cdk/testing/api#ComponentHarness) for the full list of the different locatorFor methods.\n\nFor example, consider a menu build using the popup from above:\n\n<docs-code language=\"typescript\">\n@Directive({\n  selector: 'my-menu-item'\n})\nclass MyMenuItem {}\n\n@Component({\n  selector: 'my-menu',\n  template: `\n    <my-popup>\n      <ng-content></ng-content>\n    </my-popup>\n  `\n})\nclass MyMenu {\n  triggerText = input('');\n\n  @ContentChildren(MyMenuItem) items: QueryList<MyMenuItem>;\n}\n</docs-code>\n\nThe harness for `MyMenu` can then take advantage of other harnesses for `MyPopup` and `MyMenuItem`:\n\n<docs-code language=\"typescript\">\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  protected getPopupHarness = this.locatorFor(MyPopupHarness);\n\n  /** Gets the currently shown menu items (empty list if menu is closed). */\n  getItems = this.locatorForAll(MyMenuItemHarness);\n\n  /** Toggles open state of the menu. */\n  async toggle() {\n    const popupHarness = await this.getPopupHarness();\n    return popupHarness.toggle();\n  }\n}\n\nclass MyMenuItemHarness extends ComponentHarness {\n  static hostSelector = 'my-menu-item';\n}\n</docs-code>\n\n## Filtering harness instances with `HarnessPredicate`\nWhen a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. For example, you may want a button with some specific text, or a menu with a specific ID. The `HarnessPredicate` class can capture criteria like this for a `ComponentHarness` subclass. While the test author is able to construct `HarnessPredicate` instances manually, it's easier when the `ComponentHarness` subclass provides a helper method to construct predicates for common filters.\n\nYou should create a static `with()` method on each `ComponentHarness` subclass that returns a `HarnessPredicate` for that class. This allows test authors to write easily understandable code, e.g. `loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))`. In addition to the standard selector and ancestor options, the `with` method should add any other options that make sense for the particular subclass.\n\nHarnesses that need to add additional options should extend the `BaseHarnessFilters` interface and additional optional properties as needed. `HarnessPredicate` provides several convenience methods for adding options: `stringMatches()`, `addOption()`, and `add()`. See the [HarnessPredicate API page](https://material.angular.io/cdk/testing/api#HarnessPredicate) for the full description.\n\nFor example, when working with a menu it is useful to filter based on trigger text and to filter menu items based on their text:\n\n<docs-code language=\"typescript\">\ninterface MyMenuHarnessFilters extends BaseHarnessFilters {\n  /** Filters based on the trigger text for the menu. */\n  triggerText?: string | RegExp;\n}\n\ninterface MyMenuItemHarnessFilters extends BaseHarnessFilters {\n  /** Filters based on the text of the menu item. */\n  text?: string | RegExp;\n}\n\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */\n  static with(options: MyMenuHarnessFilters): HarnessPredicate<MyMenuHarness> {\n    return new HarnessPredicate(MyMenuHarness, options)\n        .addOption('trigger text', options.triggerText,\n            (harness, text) => HarnessPredicate.stringMatches(harness.getTriggerText(), text));\n  }\n\n  protected getPopupHarness = this.locatorFor(MyPopupHarness);\n\n  /** Gets the text of the menu trigger. */\n  async getTriggerText(): Promise<string> {\n    const popupHarness = await this.getPopupHarness();\n    return popupHarness.getTriggerText();\n  }\n  ...\n}\n\nclass MyMenuItemHarness extends ComponentHarness {\n  static hostSelector = 'my-menu-item';\n\n  /** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */\n  static with(options: MyMenuItemHarnessFilters): HarnessPredicate<MyMenuItemHarness> {\n    return new HarnessPredicate(MyMenuItemHarness, options)\n        .addOption('text', options.text,\n            (harness, text) => HarnessPredicate.stringMatches(harness.getText(), text));\n  }\n\n  /** Gets the text of the menu item. */\n  async getText(): Promise<string> {\n    const host = await this.host();\n    return host.text();\n  }\n}\n</docs-code>\n\nYou can pass a `HarnessPredicate` instead of a `ComponentHarness` class to any of the APIs on `HarnessLoader`, `LocatorFactory`, or `ComponentHarness`. This allows test authors to easily target a particular component instance when creating a harness instance. It also allows the harness author to leverage the same `HarnessPredicate` to enable more powerful APIs on their harness class. For example, consider the `getItems` method on the `MyMenuHarness` shown above. Adding a filtering API allows users of the harness to search for particular menu items:\n\n<docs-code language=\"typescript\">\nclass MyMenuHarness extends ComponentHarness {\n  static hostSelector = 'my-menu';\n\n  /** Gets a list of items in the menu, optionally filtered based on the given criteria. */\n  async getItems(filters: MyMenuItemHarnessFilters = {}): Promise<MyMenuItemHarness[]> {\n    const getFilteredItems = this.locatorForAll(MyMenuItemHarness.with(filters));\n    return getFilteredItems();\n  }\n  ...\n}\n</docs-code>\n\n## Creating `HarnessLoader` for elements that use content projection\n\nSome components project additional content into the component's template. See the [content projection guide](guide/components/content-projection) for more information.\n\nAdd a `HarnessLoader` instance scoped to the element containing the `<ng-content>` when you create a harness for a component that uses content projection. This allows the user of the harness to load additional harnesses for whatever components were passed in as content. `ComponentHarness` has several methods that can be used to create HarnessLoader instances for cases like this: `harnessLoaderFor()`, `harnessLoaderForOptional()`, `harnessLoaderForAll()`. See the [HarnessLoader interface API reference page](https://material.angular.io/cdk/testing/api#HarnessLoader) for more details.\n\nFor example, the `MyPopupHarness` example from above can extend `ContentContainerComponentHarness` to add support to load harnesses within the `<ng-content>` of the component.\n\n<docs-code language=\"typescript\">\nclass MyPopupHarness extends ContentContainerComponentHarness<string> {\n  static hostSelector = 'my-popup';\n}\n</docs-code>\n\n## Accessing elements outside of the component's host element\n\nThere are times when a component harness might need to access elements outside of its corresponding component's host element. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the `Overlay` service in Angular CDK.\n\nIn this case, `ComponentHarness` provides a method that can be used to get a `LocatorFactory` for the root element of the document. The `LocatorFactory` supports most of the same APIs as the `ComponentHarness` base class, and can then be used to query relative to the document's root element.\n\nConsider if the `MyPopup` component above used the CDK overlay for the popup content, rather than an element in its own template. In this case, `MyPopupHarness` would have to access the content element via `documentRootLocatorFactory()` method that gets a locator factory rooted at the document root.\n\n<docs-code language=\"typescript\">\nclass MyPopupHarness extends ComponentHarness {\n  static hostSelector = 'my-popup';\n\n  /** Gets a `HarnessLoader` whose root element is the popup's content element. */\n  async getHarnessLoaderForContent(): Promise<HarnessLoader> {\n    const rootLocator = this.documentRootLocatorFactory();\n    return rootLocator.harnessLoaderFor('my-popup-content');\n  }\n}\n</docs-code>\n\n## Waiting for asynchronous tasks\n\nThe methods on `TestElement` automatically trigger Angular's change detection and wait for tasks inside the `NgZone`. In most cases no special effort is required for harness authors to wait on asynchronous tasks. However, there are some edge cases where this may not be sufficient.\n\nUnder some circumstances, Angular animations may require a second cycle of change detection and subsequent `NgZone` stabilization before animation events are fully flushed. In cases where this is needed, the `ComponentHarness` offers a `forceStabilize()` method that can be called to do the second round.\n\nYou can use `NgZone.runOutsideAngular()` to schedule tasks outside of NgZone. Call the `waitForTasksOutsideAngular()` method on the corresponding harness if you need to explicitly wait for tasks outside `NgZone` since this does not happen automatically.\n\n\n\n================================================\n",
    "endLine": 19241
  },
  {
    "id": 96,
    "file": "debugging",
    "fullFileName": "adev/src/content/guide/testing/debugging.md",
    "startLine": 19245,
    "content": "# Debugging tests\n\nIf your tests aren't working as you expect them to, you can inspect and debug them in the browser.\n\nDebug specs in the browser in the same way that you debug an application.\n\n1. Reveal the Karma browser window.\n    See [Set up testing](guide/testing#set-up-testing) if you need help with this step.\n\n1. Click the **DEBUG** button to open a new browser tab and re-run the tests.\n1. Open the browser's **Developer Tools**. On Windows, press `Ctrl-Shift-I`. On macOS, press `Command-Option-I`.\n1. Pick the **Sources** section.\n1. Press `Control/Command-P`, and then start typing the name of your test file to open it.\n1. Set a breakpoint in the test.\n1. Refresh the browser, and notice how it stops at the breakpoint.\n\n<img alt=\"Karma debugging\" src=\"assets/images/guide/testing/karma-1st-spec-debug.png\">\n\n\n\n================================================\n",
    "endLine": 19264
  },
  {
    "id": 97,
    "file": "overview",
    "fullFileName": "adev/src/content/guide/testing/overview.md",
    "startLine": 19268,
    "content": "# Testing\n\nTesting your Angular application helps you check that your application is working as you expect.\n\n## Set up testing\n\nThe Angular CLI downloads and installs everything you need to test an Angular application with [Jasmine testing framework](https://jasmine.github.io).\n\nThe project you create with the CLI is immediately ready to test.\nJust run the [`ng test`](cli/test) CLI command:\n\n<docs-code language=\"shell\">\n\nng test\n\n</docs-code>\n\nThe `ng test` command builds the application in *watch mode*,\nand launches the [Karma test runner](https://karma-runner.github.io).\n\nThe console output looks like below:\n\n<docs-code language=\"shell\">\n\n02 11 2022 09:08:28.605:INFO [karma-server]: Karma v6.4.1 server started at http://localhost:9876/\n02 11 2022 09:08:28.607:INFO [launcher]: Launching browsers Chrome with concurrency unlimited\n02 11 2022 09:08:28.620:INFO [launcher]: Starting browser Chrome\n02 11 2022 09:08:31.312:INFO [Chrome]: Connected on socket -LaEYvD2R7MdcS0-AAAB with id 31534482\nChrome: Executed 3 of 3 SUCCESS (0.193 secs / 0.172 secs)\nTOTAL: 3 SUCCESS\n\n</docs-code>\n\nThe last line of the log shows that Karma ran three tests that all passed.\n\nThe test output is displayed in the browser using [Karma Jasmine HTML Reporter](https://github.com/dfederm/karma-jasmine-html-reporter).\n\n<img alt=\"Jasmine HTML Reporter in the browser\" src=\"assets/images/guide/testing/initial-jasmine-html-reporter.png\">\n\nClick on a test row to re-run just that test or click on a description to re-run the tests in the selected test group \\(\"test suite\"\\).\n\nMeanwhile, the `ng test` command is watching for changes.\n\nTo see this in action, make a small change to `app.component.ts` and save.\nThe tests run again, the browser refreshes, and the new test results appear.\n\n## Configuration\n\nThe Angular CLI takes care of Jasmine and Karma configuration for you. It constructs the full configuration in memory, based on options specified in the `angular.json` file.\n\nIf you want to customize Karma, you can create a `karma.conf.js` by running the following command:\n\n<docs-code language=\"shell\">\n\nng generate config karma\n\n</docs-code>\n\nHELPFUL: Read more about Karma configuration in the [Karma configuration guide](http://karma-runner.github.io/6.4/config/configuration-file.html).\n\n### Other test frameworks\n\nYou can also unit test an Angular application with other testing libraries and test runners.\nEach library and runner has its own distinctive installation procedures, configuration, and syntax.\n\n### Test file name and location\n\nInside the `src/app` folder the Angular CLI generated a test file for the `AppComponent` named `app.component.spec.ts`.\n\nIMPORTANT: The test file extension **must be `.spec.ts`** so that tooling can identify it as a file with tests \\(also known as a *spec* file\\).\n\nThe `app.component.ts` and `app.component.spec.ts` files are siblings in the same folder.\nThe root file names \\(`app.component`\\) are the same for both files.\n\nAdopt these two conventions in your own projects for *every kind* of test file.\n\n#### Place your spec file next to the file it tests\n\nIt's a good idea to put unit test spec files in the same folder\nas the application source code files that they test:\n\n* Such tests are painless to find\n* You see at a glance if a part of your application lacks tests\n* Nearby tests can reveal how a part works in context\n* When you move the source \\(inevitable\\), you remember to move the test\n* When you rename the source file \\(inevitable\\), you remember to rename the test file\n\n#### Place your spec files in a test folder\n\nApplication integration specs can test the interactions of multiple parts\nspread across folders and modules.\nThey don't really belong to any part in particular, so they don't have a\nnatural home next to any one file.\n\nIt's often better to create an appropriate folder for them in the `tests` directory.\n\nOf course specs that test the test helpers belong in the `test` folder,\nnext to their corresponding helper files.\n\n## Testing in continuous integration\n\nOne of the best ways to keep your project bug-free is through a test suite, but you might forget to run tests all the time.\n\nContinuous integration \\(CI\\) servers let you set up your project repository so that your tests run on every commit and pull request.\n\nTo test your Angular CLI application in Continuous integration \\(CI\\) run the following command:\n\n<docs-code language=\"shell\">\nng test --no-watch --no-progress --browsers=ChromeHeadless\n</docs-code>\n\n## More information on testing\n\nAfter you've set up your application for testing, you might find the following testing guides useful.\n\n|                                                                    | Details |\n|:---                                                                |:---     |\n| [Code coverage](guide/testing/code-coverage)                       | How much of your app your tests are covering and how to specify required amounts. |\n| [Testing services](guide/testing/services)                         | How to test the services your application uses.                                   |\n| [Basics of testing components](guide/testing/components-basics)    | Basics of testing Angular components.                                             |\n| [Component testing scenarios](guide/testing/components-scenarios)  | Various kinds of component testing scenarios and use cases.                       |\n| [Testing attribute directives](guide/testing/attribute-directives) | How to test your attribute directives.                                            |\n| [Testing pipes](guide/testing/pipes)                               | How to test pipes.                                                                |\n| [Debugging tests](guide/testing/debugging)                            | Common testing bugs.                                                              |\n| [Testing utility APIs](guide/testing/utility-apis)                 | Angular testing features.                                                         |\n\n\n\n================================================\n",
    "endLine": 19395
  },
  {
    "id": 98,
    "file": "pipes",
    "fullFileName": "adev/src/content/guide/testing/pipes.md",
    "startLine": 19399,
    "content": "# Testing Pipes\n\nYou can test [pipes](guide/templates/pipes) without the Angular testing utilities.\n\n## Testing the `TitleCasePipe`\n\nA pipe class has one method, `transform`, that manipulates the input value into a transformed output value.\nThe `transform` implementation rarely interacts with the DOM.\nMost pipes have no dependence on Angular other than the `@Pipe` metadata and an interface.\n\nConsider a `TitleCasePipe` that capitalizes the first letter of each word.\nHere's an implementation with a regular expression.\n\n<docs-code header=\"app/shared/title-case.pipe.ts\" path=\"adev/src/content/examples/testing/src/app/shared/title-case.pipe.ts\"/>\n\nAnything that uses a regular expression is worth testing thoroughly.\nUse simple Jasmine to explore the expected cases and the edge cases.\n\n<docs-code header=\"app/shared/title-case.pipe.spec.ts\" path=\"adev/src/content/examples/testing/src/app/shared/title-case.pipe.spec.ts\" visibleRegion=\"excerpt\"/>\n\n## Writing DOM tests to support a pipe test\n\nThese are tests of the pipe *in isolation*.\nThey can't tell if the `TitleCasePipe` is working properly as applied in the application components.\n\nConsider adding component tests such as this one:\n\n<docs-code header=\"app/hero/hero-detail.component.spec.ts (pipe test)\" path=\"adev/src/content/examples/testing/src/app/hero/hero-detail.component.spec.ts\" visibleRegion=\"title-case-pipe\"/>\n\n\n\n================================================\n",
    "endLine": 19429
  },
  {
    "id": 99,
    "file": "services",
    "fullFileName": "adev/src/content/guide/testing/services.md",
    "startLine": 19433,
    "content": "# Testing services\n\nTo check that your services are working as you intend, you can write tests specifically for them.\n\nServices are often the smoothest files to unit test.\nHere are some synchronous and asynchronous unit tests of the `ValueService` written without assistance from Angular testing utilities.\n\n<docs-code header=\"app/demo/demo.spec.ts\" path=\"adev/src/content/examples/testing/src/app/demo/demo.spec.ts\" visibleRegion=\"ValueService\"/>\n\n## Services with dependencies\n\nServices often depend on other services that Angular injects into the constructor.\nIn many cases, you can create and *inject* these dependencies by hand while calling the service's constructor.\n\nThe `MasterService` is a simple example:\n\n<docs-code header=\"app/demo/demo.ts\" path=\"adev/src/content/examples/testing/src/app/demo/demo.ts\" visibleRegion=\"MasterService\"/>\n\n`MasterService` delegates its only method, `getValue`, to the injected `ValueService`.\n\nHere are several ways to test it.\n\n<docs-code header=\"app/demo/demo.spec.ts\" path=\"adev/src/content/examples/testing/src/app/demo/demo.spec.ts\" visibleRegion=\"MasterService\"/>\n\nThe first test creates a `ValueService` with `new` and passes it to the `MasterService` constructor.\n\nHowever, injecting the real service rarely works well as most dependent services are difficult to create and control.\n\nInstead, mock the dependency, use a dummy value, or create a [spy](https://jasmine.github.io/tutorials/your_first_suite#section-Spies) on the pertinent service method.\n\nHELPFUL: Prefer spies as they are usually the best way to mock services.\n\nThese standard testing techniques are great for unit testing services in isolation.\n\nHowever, you almost always inject services into application classes using Angular dependency injection and you should have tests that reflect that usage pattern.\nAngular testing utilities make it straightforward to investigate how injected services behave.\n\n## Testing services with the `TestBed`\n\nYour application relies on Angular [dependency injection (DI)](guide/di) to create services.\nWhen a service has a dependent service, DI finds or creates that dependent service.\nAnd if that dependent service has its own dependencies, DI finds-or-creates them as well.\n\nAs a service *consumer*, you don't worry about any of this.\nYou don't worry about the order of constructor arguments or how they're created.\n\nAs a service *tester*, you must at least think about the first level of service dependencies but you *can* let Angular DI do the service creation and deal with constructor argument order when you use the `TestBed` testing utility to provide and create services.\n\n## Angular `TestBed`\n\nThe `TestBed` is the most important of the Angular testing utilities.\nThe `TestBed` creates a dynamically-constructed Angular *test* module that emulates an Angular [@NgModule](guide/ngmodules).\n\nThe `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an [@NgModule](guide/ngmodules).\n\nTo test a service, you set the `providers` metadata property with an array of the services that you'll test or mock.\n\n<docs-code header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\" path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"value-service-before-each\"/>\n\nThen inject it inside a test by calling `TestBed.inject()` with the service class as the argument.\n\nHELPFUL: `TestBed.get()` was deprecated as of Angular version 9.\nTo help minimize breaking changes, Angular introduces a new function called `TestBed.inject()`, which you should use instead.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"value-service-inject-it\"/>\n\nOr inside the `beforeEach()` if you prefer to inject the service as part of your setup.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"value-service-inject-before-each\"> </docs-code>\n\nWhen testing a service with a dependency, provide the mock in the `providers` array.\n\nIn the following example, the mock is a spy object.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"master-service-before-each\"/>\n\nThe test consumes that spy in the same way it did earlier.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"master-service-it\"/>\n\n## Testing without `beforeEach()`\n\nMost test suites in this guide call `beforeEach()` to set the preconditions for each `it()` test and rely on the `TestBed` to create classes and inject services.\n\nThere's another school of testing that never calls `beforeEach()` and prefers to create classes explicitly rather than use the `TestBed`.\n\nHere's how you might rewrite one of the `MasterService` tests in that style.\n\nBegin by putting re-usable, preparatory code in a *setup* function instead of `beforeEach()`.\n\n<docs-code header=\"app/demo/demo.spec.ts (setup)\" path=\"adev/src/content/examples/testing/src/app/demo/demo.spec.ts\" visibleRegion=\"no-before-each-setup\"/>\n\nThe `setup()` function returns an object literal with the variables, such as `masterService`, that a test might reference.\nYou don't define *semi-global* variables \\(for example, `let masterService: MasterService`\\) in the body of the `describe()`.\n\nThen each test invokes `setup()` in its first line, before continuing with steps that manipulate the test subject and assert expectations.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.spec.ts\" visibleRegion=\"no-before-each-test\"/>\n\nNotice how the test uses [*destructuring assignment*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) to extract the setup variables that it needs.\n\n<docs-code path=\"adev/src/content/examples/testing/src/app/demo/demo.spec.ts\" visibleRegion=\"no-before-each-setup-call\"/>\n\nMany developers feel this approach is cleaner and more explicit than the traditional `beforeEach()` style.\n\nAlthough this testing guide follows the traditional style and the default [CLI schematics](https://github.com/angular/angular-cli) generate test files with `beforeEach()` and `TestBed`, feel free to adopt *this alternative approach* in your own projects.\n\n## Testing HTTP services\n\nData services that make HTTP calls to remote servers typically inject and delegate to the Angular [`HttpClient`](guide/http/testing) service for XHR calls.\n\nYou can test a data service with an injected `HttpClient` spy as you would test any service with a dependency.\n\n<docs-code header=\"app/model/hero.service.spec.ts (tests with spies)\" path=\"adev/src/content/examples/testing/src/app/model/hero.service.spec.ts\" visibleRegion=\"test-with-spies\"/>\n\nIMPORTANT: The `HeroService` methods return `Observables`.\nYou must *subscribe* to an observable to \\(a\\) cause it to execute and \\(b\\) assert that the method succeeds or fails.\n\nThe `subscribe()` method takes a success \\(`next`\\) and fail \\(`error`\\) callback.\nMake sure you provide *both* callbacks so that you capture errors.\nNeglecting to do so produces an asynchronous uncaught observable error that the test runner will likely attribute to a completely different test.\n\n## `HttpClientTestingModule`\n\nExtended interactions between a data service and the `HttpClient` can be complex and difficult to mock with spies.\n\nThe `HttpClientTestingModule` can make these testing scenarios more manageable.\n\nWhile the *code sample* accompanying this guide demonstrates `HttpClientTestingModule`, this page defers to the [Http guide](guide/http/testing), which covers testing with the `HttpClientTestingModule` in detail.\n\n\n\n================================================\n",
    "endLine": 19564
  },
  {
    "id": 100,
    "file": "using-component-harnesses",
    "fullFileName": "adev/src/content/guide/testing/using-component-harnesses.md",
    "startLine": 19568,
    "content": "# Using component harnesses in tests\n\n## Before you start\n\nTIP: This guide assumes you've already read the [component harnesses overview guide](guide/testing/component-harnesses-overview). Read that first if you're new to using component harnesses.\n\n### CDK Installation\n\nThe [Component Dev Kit (CDK)](https://material.angular.io/cdk/categories) is a set of behavior primitives for building components. To use the component harnesses, first install `@angular/cdk` from npm. You can do this from your terminal using the Angular CLI:\n\n<docs-code language=\"shell\">\n  ng add @angular/cdk\n</docs-code>\n\n## Test harness environments and loaders\n\nYou can use component test harnesses in different test environments. Angular CDK supports two built-in environments:\n- Unit tests with Angular's `TestBed`\n- End-to-end tests with [WebDriver](https://developer.mozilla.org/en-US/docs/Web/WebDriver)\n\n\nEach environment provides a <strong>harness loader</strong>. The loader creates the harness instances you use throughout your tests. See below for more specific guidance on supported testing environments.\n\nAdditional testing environments require custom bindings. See the [adding harness support for additional testing environments guide](guide/testing/component-harnesses-testing-environments) for more information.\n\n### Using the loader from `TestbedHarnessEnvironment` for unit tests\n\nFor unit tests you can create a harness loader from [TestbedHarnessEnvironment](https://material.angular.io/cdk/testing/api#TestbedHarnessEnvironment). This environment uses a [component fixture](api/core/testing/ComponentFixture) created by Angular's `TestBed`.\n\nTo create a harness loader rooted at the fixture's root element, use the `loader()` method:\n\n<docs-code language=\"typescript\">\nconst fixture = TestBed.createComponent(MyComponent);\n\n// Create a harness loader from the fixture\nconst loader = TestbedHarnessEnvironment.loader(fixture);\n...\n\n// Use the loader to get harness instances\nconst myComponentHarness = await loader.getHarness(MyComponent);\n</docs-code>\n\nTo create a harness loader for harnesses for elements that fall outside the fixture, use the `documentRootLoader()` method. For example, code that displays a floating element or pop-up often attaches DOM elements directly to the document body, such as the `Overlay` service in Angular CDK.\n\nYou can also create a harness loader directly with `harnessForFixture()` for a harness at that fixture's root element directly.\n\n### Using the loader from `SeleniumWebDriverHarnessEnvironment` for end-to-end tests\n\nFor WebDriver-based end-to-end tests you can create a harness loader with `SeleniumWebDriverHarnessEnvironment`.\n\nUse the `loader()` method to get the harness loader instance for the current HTML document, rooted at the document's root element. This environment uses a WebDriver client.\n\n<docs-code language=\"typescript\">\nlet wd: webdriver.WebDriver = getMyWebDriverClient();\nconst loader = SeleniumWebDriverHarnessEnvironment.loader(wd);\n...\nconst myComponentHarness = await loader.getHarness(MyComponent);\n</docs-code>\n\n## Using a harness loader\n\nHarness loader instances correspond to a specific DOM element and are used to create component harness instances for elements under that specific element.\n\nTo get `ComponentHarness` for the first instance of the element, use the `getHarness()` method. To get all `ComponentHarness` instances, use the `getAllHarnesses()` method.\n\n<docs-code language=\"typescript\">\n// Get harness for first instance of the element\nconst myComponentHarness = await loader.getHarness(MyComponent);\n\n// Get harnesses for all instances of the element\nconst myComponentHarnesses = await loader.getHarnesses(MyComponent);\n</docs-code>\n\nAs an example, consider a reusable dialog-button component that opens a dialog on click. It contains the following components, each with a corresponding harness:\n- `MyDialogButton` (composes the `MyButton` and `MyDialog` with a convenient API)\n- `MyButton` (a standard button component)\n- `MyDialog` (a dialog appended to `document.body` by `MyDialogButton` upon click)\n\nThe following test loads harnesses for each of these components:\n\n<docs-code language=\"typescript\">\nlet fixture: ComponentFixture<MyDialogButton>;\nlet loader: HarnessLoader;\nlet rootLoader: HarnessLoader;\n\nbeforeEach(() => {\n  fixture = TestBed.createComponent(MyDialogButton);\n  loader = TestbedHarnessEnvironment.loader(fixture);\n  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);\n});\n\nit('loads harnesses', async () => {\n  // Load a harness for the bootstrapped component with `harnessForFixture`\n  dialogButtonHarness =\n      await TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);\n  // The button element is inside the fixture's root element, so we use `loader`.\n  const buttonHarness = await loader.getHarness(MyButtonHarness);\n  // Click the button to open the dialog\n  await buttonHarness.click();\n  // The dialog is appended to `document.body`, outside of the fixture's root element,\n  // so we use `rootLoader` in this case.\n  const dialogHarness = await rootLoader.getHarness(MyDialogHarness);\n  // ... make some assertions\n});\n</docs-code>\n\n### Harness behavior in different environments\n\nHarnesses may not behave exactly the same in all environments. Some differences are unavoidable between the real user interaction versus the simulated events generated in unit tests. Angular CDK makes a best effort to normalize the behavior to the extent possible.\n\n### Interacting with child elements\n\nTo interact with elements below the root element of this harness loader, use the `HarnessLoader` instance of a child element. For the first instance of the child element, use the `getChildLoader()` method. For all instances of the child element, use the `getAllChildLoaders()` method.\n\n<docs-code language=\"typescript\">\nconst myComponentHarness = await loader.getHarness(MyComponent);\n\n// Get loader for first instance of child element with '.child' selector\nconst childLoader = await myComponentHarness.getLoader('.child');\n\n// Get loaders for all instances of child elements with '.child' selector\nconst allChildLoaders = await myComponentHarness.getAllChildLoaders('.child');\n</docs-code>\n\n### Filtering harnesses\n\nWhen a page contains multiple instances of a particular component, you may want to filter based on some property of the component to get a particular component instance. You can use a <strong>harness predicate</strong>, a class used to associate a `ComponentHarness` class with predicates functions that can be used to filter component instances, to do so.\n\nWhen you ask a `HarnessLoader` for a harness, you're actually providing a HarnessQuery. A query can be one of two things:\n- A harness constructor. This just gets that harness\n- A `HarnessPredicate`, which gets harnesses that are filtered based on one or more conditions\n\n`HarnessPredicate` does support some base filters (selector, ancestor) that work on anything that extends `ComponentHarness`.\n\n<docs-code language=\"typescript\">\n// Example of loading a MyButtonComponentHarness with a harness predicate\nconst disabledButtonPredicate = new HarnessPredicate(MyButtonComponentHarness, {selector: '[disabled]'});\nconst disabledButton = await loader.getHarness(disabledButtonPredicate);\n</docs-code>\n\nHowever it's common for harnesses to implement a static `with()` method that accepts component-specific filtering options and returns a `HarnessPredicate`.\n\n<docs-code language=\"typescript\">\n// Example of loading a MyButtonComponentHarness with a specific selector\nconst button = await loader.getHarness(MyButtonComponentHarness.with({selector: 'btn'}))\n</docs-code>\n\nFor more details refer to the specific harness documentation since additional filtering options are specific to each harness implementation.\n\n## Using test harness APIs\n\nWhile every harness defines an API specific to its corresponding component, they all share a common base class, [ComponentHarness](https://material.angular.io/cdk/testing/api#ComponentHarness). This base class defines a static property, `hostSelector`, that matches the harness class to instances of the component in the DOM.\n\nBeyond that, the API of any given harness is specific to its corresponding component; refer to the component's documentation to learn how to use a specific harness.\n\nAs an example, the following is a test for a component that uses the [Angular Material slider component harness](https://material.angular.io/components/slider/api#MatSliderHarness):\n\n<docs-code language=\"typescript\">\nit('should get value of slider thumb', async () => {\n    const slider = await loader.getHarness(MatSliderHarness);\n    const thumb = await slider.getEndThumb();\n    expect(await thumb.getValue()).toBe(50);\n});\n</docs-code>\n\n## Interop with Angular change detection\n\nBy default, test harnesses runs Angular's [change detection](https://angular.dev/best-practices/runtime-performance) before reading the state of a DOM element and after interacting with a DOM element.\n\nThere may be times that you need finer-grained control over change detection in your tests. such as checking the state of a component while an async operation is pending. In these cases use the `manualChangeDetection` function to disable automatic handling of change detection for a block of code.\n\n<docs-code language=\"typescript\">\nit('checks state while async action is in progress', async () => {\n  const buttonHarness = loader.getHarness(MyButtonHarness);\n  await manualChangeDetection(async () => {\n    await buttonHarness.click();\n    fixture.detectChanges();\n    // Check expectations while async click operation is in progress.\n    expect(isProgressSpinnerVisible()).toBe(true);\n    await fixture.whenStable();\n    // Check expectations after async click operation complete.\n    expect(isProgressSpinnerVisible()).toBe(false);\n  });\n});\n</docs-code>\n\nAlmost all harness methods are asynchronous and return a `Promise` to support the following:\n- Support for unit tests\n- Support for end-to-end tests\n- Insulate tests against changes in asynchronous behavior\n\nThe Angular team recommends using [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) to improve the test readability. Calling `await` blocks the execution of your test until the associated `Promise` resolves.\n\nOccasionally, you may want to perform multiple actions simultaneously and wait until they're all done rather than performing each action sequentially. For example, read multiple properties of a single component. In these situations use the `parallel` function to parallelize the operations. The parallel function works similarly to `Promise.all`, while also optimizing change detection checks.\n\n<docs-code language=\"typescript\">\nit('reads properties in parallel', async () => {\n  const checkboxHarness = loader.getHarness(MyCheckboxHarness);\n  // Read the checked and intermediate properties simultaneously.\n  const [checked, indeterminate] = await parallel(() => [\n    checkboxHarness.isChecked(),\n    checkboxHarness.isIndeterminate()\n  ]);\n  expect(checked).toBe(false);\n  expect(indeterminate).toBe(true);\n});\n</docs-code>\n\n\n\n================================================\n",
    "endLine": 19777
  },
  {
    "id": 101,
    "file": "utility-apis",
    "fullFileName": "adev/src/content/guide/testing/utility-apis.md",
    "startLine": 19781,
    "content": "# Testing Utility APIs\n\nThis page describes the most useful Angular testing features.\n\nThe Angular testing utilities include the `TestBed`, the `ComponentFixture`, and a handful of functions that control the test environment.\nThe [`TestBed`](#testbed-api-summary) and [`ComponentFixture`](#component-fixture-api-summary) classes are covered separately.\n\nHere's a summary of the stand-alone functions, in order of likely utility:\n\n| Function                     | Details |\n|:---                          |:---     |\n| `waitForAsync`               | Runs the body of a test \\(`it`\\) or setup \\(`beforeEach`\\) function within a special *async test zone*. See [waitForAsync](guide/testing/components-scenarios#waitForAsync).                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| `fakeAsync`                  | Runs the body of a test \\(`it`\\) within a special *fakeAsync test zone*, enabling a linear control flow coding style. See [fakeAsync](guide/testing/components-scenarios#fake-async).                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| `tick`                       | Simulates the passage of time and the completion of pending asynchronous activities by flushing both *timer* and *micro-task* queues within the *fakeAsync test zone*.  The curious, dedicated reader might enjoy this lengthy blog post, [\"*Tasks, microtasks, queues and schedules*\"](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules).  Accepts an optional argument that moves the virtual clock forward by the specified number of milliseconds, clearing asynchronous activities scheduled within that timeframe. See [tick](guide/testing/components-scenarios#tick). |\n| `inject`                     | Injects one or more services from the current `TestBed` injector into a test function. It cannot inject a service provided by the component itself. See discussion of the [debugElement.injector](guide/testing/components-scenarios#get-injected-services).                                                                                                                                                                                                                                                                                                                                                                          |\n| `discardPeriodicTasks`       | When a `fakeAsync()` test ends with pending timer event *tasks* \\(queued `setTimeOut` and `setInterval` callbacks\\), the test fails with a clear error message. <br /> In general, a test should end with no queued tasks. When pending timer tasks are expected, call `discardPeriodicTasks` to flush the *task* queue and avoid the error.                                                                                                                                                                                                                                                                                          |\n| `flushMicrotasks`            | When a `fakeAsync()` test ends with pending *micro-tasks* such as unresolved promises, the test fails with a clear error message. <br /> In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call `flushMicrotasks` to flush the  *micro-task* queue and avoid the error.                                                                                                                                                                                                                                                                                                                 |\n| `ComponentFixtureAutoDetect` | A provider token for a service that turns on [automatic change detection](guide/testing/components-scenarios#automatic-change-detection).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| `getTestBed`                 | Gets the current instance of the `TestBed`. Usually unnecessary because the static class methods of the `TestBed` class are typically sufficient. The `TestBed` instance exposes a few rarely used members that are not available as static methods.                                                                                                                                                                                                                                                                                                                                                                                  |\n\n## `TestBed` class summary\n\nThe `TestBed` class is one of the principal Angular testing utilities.\nIts API is quite large and can be overwhelming until you've explored it, a little at a time.\nRead the early part of this guide first to get the basics before trying to absorb the full API.\n\nThe module definition passed to `configureTestingModule` is a subset of the `@NgModule` metadata properties.\n\n<docs-code language=\"javascript\">\n\ntype TestModuleMetadata = {\n  providers?: any[];\n  declarations?: any[];\n  imports?: any[];\n  schemas?: Array<SchemaMetadata | any[]>;\n};\n\n</docs-code>\n\nEach override method takes a `MetadataOverride<T>` where `T` is the kind of metadata appropriate to the method, that is, the parameter of an `@NgModule`, `@Component`, `@Directive`, or `@Pipe`.\n\n<docs-code language=\"javascript\">\n\ntype MetadataOverride<T> = {\n  add?: Partial<T>;\n  remove?: Partial<T>;\n  set?: Partial<T>;\n};\n\n</docs-code>\n\nThe `TestBed` API consists of static class methods that either update or reference a *global* instance of the `TestBed`.\n\nInternally, all static methods cover methods of the current runtime `TestBed` instance, which is also returned by the `getTestBed()` function.\n\nCall `TestBed` methods *within* a `beforeEach()` to ensure a fresh start before each individual test.\n\nHere are the most important static methods, in order of likely utility.\n\n| Methods                                                        | Details |\n|:---                                                            |:---     |\n| `configureTestingModule`                                       | The testing shims \\(`karma-test-shim`, `browser-test-shim`\\) establish the [initial test environment](guide/testing) and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs. <br /> Call `configureTestingModule` to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations \\(of components, directives, and pipes\\), and providers.                                                                                                                                              |\n| `compileComponents`                                            | Compile the testing module asynchronously after you've finished configuring it. You **must** call this method if *any* of the testing module components have a `templateUrl` or `styleUrls` because fetching component template and style files is necessarily asynchronous. See [compileComponents](guide/testing/components-scenarios#calling-compilecomponents). <br /> After calling `compileComponents`, the `TestBed` configuration is frozen for the duration of the current spec.                                                                                                                                                                 |\n| `createComponent<T>`                                     | Create an instance of a component of type `T` based on the current `TestBed` configuration. After calling `createComponent`, the `TestBed` configuration is frozen for the duration of the current spec.                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| `overrideModule`                                               | Replace metadata for the given `NgModule`. Recall that modules can import other modules. The `overrideModule` method can reach deeply into the current testing module to modify one of these inner modules.                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| `overrideComponent`                                            | Replace metadata for the given component class, which could be nested deeply within an inner module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| `overrideDirective`                                            | Replace metadata for the given directive class, which could be nested deeply within an inner module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| `overridePipe`                                                 | Replace metadata for the given pipe class, which could be nested deeply within an inner module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n|\n `inject`                           | Retrieve a service from the current `TestBed` injector. The `inject` function is often adequate for this purpose. But `inject` throws an error if it can't provide the service. <br /> What if the service is optional? <br /> The `TestBed.inject()` method takes an optional second parameter, the object to return if Angular can't find the provider \\(`null` in this example\\): <docs-code header=\"app/demo/demo.testbed.spec.ts\" path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"testbed-get-w-null\"/> After calling `TestBed.inject`, the `TestBed` configuration is frozen for the duration of the current spec. |\n|\n `initTestEnvironment` | Initialize the testing environment for the entire test run. <br /> The testing shims \\(`karma-test-shim`, `browser-test-shim`\\) call it for you so there is rarely a reason for you to call it yourself. <br /> Call this method *exactly once*. To change this default in the middle of a test run, call `resetTestEnvironment` first. <br /> Specify the Angular compiler factory, a `PlatformRef`, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form `@angular/platform-<platform_name>/testing/<platform_name>`.                                                                  |\n| `resetTestEnvironment`                                         | Reset the initial test environment, including the default testing module.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\nA few of the `TestBed` instance methods are not covered by static `TestBed` *class* methods.\nThese are rarely needed.\n\n## The `ComponentFixture`\n\nThe `TestBed.createComponent<T>` creates an instance of the component `T` and returns a strongly typed `ComponentFixture` for that component.\n\nThe `ComponentFixture` properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment.\n\n### `ComponentFixture` properties\n\nHere are the most important properties for testers, in order of likely utility.\n\n| Properties          | Details |\n|:---                 |:---     |\n| `componentInstance` | The instance of the component class created by `TestBed.createComponent`.                                                                                                                                                                                                                          |\n| `debugElement`      | The `DebugElement` associated with the root element of the component. <br /> The `debugElement` provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered [below](#debug-element-details). |\n| `nativeElement`     | The native DOM element at the root of the component.                                                                                                                                                                                                                                               |\n| `changeDetectorRef` | The `ChangeDetectorRef` for the component. <br /> The `ChangeDetectorRef` is most valuable when testing a component that has the `ChangeDetectionStrategy.OnPush` method or the component's change detection is under your programmatic control.                                                   |\n\n### `ComponentFixture` methods\n\nThe *fixture* methods cause Angular to perform certain tasks on the component tree.\nCall these method to trigger Angular behavior in response to simulated user action.\n\nHere are the most useful methods for testers.\n\n| Methods             | Details |\n|:---                 |:---     |\n| `detectChanges`     | Trigger a change detection cycle for the component. <br /> Call it to initialize the component \\(it calls `ngOnInit`\\) and after your test code, change the component's data bound property values. Angular can't see that you've changed `personComponent.name` and won't update the `name` binding until you call `detectChanges`. <br /> Runs `checkNoChanges` afterwards to confirm that there are no circular updates unless called as `detectChanges(false)`;                                                                                    |\n| `autoDetectChanges` | Set this to `true` when you want the fixture to detect changes automatically. <br /> When autodetect is `true`, the test fixture calls `detectChanges` immediately after creating the component. Then it listens for pertinent zone events and calls `detectChanges` accordingly. When your test code modifies component property values directly, you probably still have to call `fixture.detectChanges` to trigger data binding updates. <br /> The default is `false`. Testers who prefer fine control over test behavior tend to keep it `false`. |\n| `checkNoChanges`    | Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are.                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| `isStable`          | If the fixture is currently *stable*, returns `true`. If there are async tasks that have not completed, returns `false`.                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| `whenStable`        | Returns a promise that resolves when the fixture is stable. <br /> To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See [whenStable](guide/testing/components-scenarios#whenstable).                                                                                                                                                                                                                                                                                                  |\n| `destroy`           | Trigger component destruction.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n\n#### `DebugElement`\n\nThe `DebugElement` provides crucial insights into the component's DOM representation.\n\nFrom the test root component's `DebugElement` returned by `fixture.debugElement`, you can walk \\(and query\\) the fixture's entire element and component subtrees.\n\nHere are the most useful `DebugElement` members for testers, in approximate order of utility:\n\n| Members               | Details |\n|:---                   |:---     |\n| `nativeElement`       | The corresponding DOM element in the browser                                                                                                                                                                                                                                                                        |\n| `query`               | Calling `query(predicate: Predicate<DebugElement>)` returns the first `DebugElement` that matches the [predicate](#query-predicate) at any depth in the subtree.                                                                                                                                                                                                                                        |\n| `queryAll`            | Calling `queryAll(predicate: Predicate<DebugElement>)` returns all `DebugElements` that matches the [predicate](#query-predicate) at any depth in subtree.                                                                                                                                                                                                                                              |\n| `injector`            | The host dependency injector. For example, the root element's component instance injector.                                                                                                                                                                                                                                                                                                              |\n| `componentInstance`   | The element's own component instance, if it has one.                                                                                                                                                                                                                                                                                                                                                    |\n| `context`             | An object that provides parent context for this element. Often an ancestor component instance that governs this element. <br /> When an element is repeated within `*ngFor`, the context is an `NgForOf` whose `$implicit` property is the value of the row instance value. For example, the `hero` in `*ngFor=\"let hero of heroes\"`.                                                                   |\n| `children`            | The immediate `DebugElement` children. Walk the tree by descending through `children`.  `DebugElement` also has `childNodes`, a list of `DebugNode` objects. `DebugElement` derives from `DebugNode` objects and there are often more nodes than elements. Testers can usually ignore plain nodes.                                                                  |\n| `parent`              | The `DebugElement` parent. Null if this is the root element.                                                                                                                                                                                                                                                                                                                                            |\n| `name`                | The element tag name, if it is an element.                                                                                                                                                                                                                                                                                                                                                              |\n| `triggerEventHandler` | Triggers the event by its name if there is a corresponding listener in the element's `listeners` collection. The second parameter is the *event object* expected by the handler. See [triggerEventHandler](guide/testing/components-scenarios#trigger-event-handler). <br /> If the event lacks a listener or there's some other problem, consider calling `nativeElement.dispatchEvent(eventObject)`. |\n| `listeners`           | The callbacks attached to the component's `@Output` properties and/or the element's event properties.                                                                                                                                                                                                                                                                                                   |\n| `providerTokens`      | This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its `providers` metadata.                                                                                                                                                                                                                                                            |\n| `source`              | Where to find this element in the source component template.                                                                                                                                                                                                                                                                                                                                            |\n| `references`          | Dictionary of objects associated with template local variables \\(for example, `#foo`\\), keyed by the local variable name.                                                                                                                                                                                                                                                                                        |\n\nThe `DebugElement.query(predicate)` and `DebugElement.queryAll(predicate)` methods take a predicate that filters the source element's subtree for matching `DebugElement`.\n\nThe predicate is any method that takes a `DebugElement` and returns a *truthy* value.\nThe following example finds all `DebugElements` with a reference to a template local variable named \"content\":\n\n<docs-code header=\"app/demo/demo.testbed.spec.ts\" path=\"adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts\" visibleRegion=\"custom-predicate\"/>\n\nThe Angular `By` class has three static methods for common predicates:\n\n| Static method             | Details |\n|:---                       |:---     |\n| `By.all`                  | Return all elements                                                        |\n| `By.css(selector)`        | Return elements with matching CSS selectors                                |\n| `By.directive(directive)` | Return elements that Angular matched to an instance of the directive class |\n\n<docs-code header=\"app/hero/hero-list.component.spec.ts\" path=\"adev/src/content/examples/testing/src/app/hero/hero-list.component.spec.ts\" visibleRegion=\"by\"/>\n",
    "endLine": 19930
  }
];